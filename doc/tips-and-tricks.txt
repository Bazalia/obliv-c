This file is meant to collect the various "here's how to do X" advice
we like to send around in emails and then promptly forget.


----------------------- slicer for globals ----------------------

I (Scott) just implemented a simple extension to cilly.asm.exe
(really, just a small modification to 'rmtmps') which lets you slice a
given C file so that it only contains things which contribute to a
given global's type (actually, you can name as many root globals as
you want).  I think this will be useful for tracking down merger
problems in big programs.

To use this, just add

  #pragma cilnoremove("my_symbol")

to the file in question, and then run

  cilly.asm.exe --sliceGlobal --out file.cil.c file.i

(where file.i is preprocessed file.c).  This will slice file.i so it only
contains things which are needed for 'my_symbol' to compile successfully,
and write the output to file.cil.c.

The symbol in question can be a function, enum tag, struct tag, typedef
name, or global variable.  Add more #pragma cilnoremove's to add more
things to the root set.

Update: It doesn't work very well for types.  Instead, if you want to
slice on a type, add at the end of the file

  #pragma cilnoremove("myGlobalVar")
  struct typeOfInterest myGlobalVar;

then the slicer will retain 'typeOfInterest'.


------------------- trusted expressions ------------------

> Here's another idea: can we mark certain expressions as "trusted"?

Yes. Enclose the expression (say, "x=a;") as follows:

        { __NOBOXBLOCK x=a; }

This causes markptr to ignore the expression (so no edges/flags are
generated and thus the solver won't become upset by anything that happens
there) and boxing to ... do the best it can, with everything in there lean.


--------------------- invoking the Ocaml debugger ----------------------

I have just written some Elisp code that allows you to enter the debugger very easily:

First the usage:
 Say you want to debug the ccured invocation for the command

  make test/array1 INFERBOX=infer

 You start emacs, go to directory cil/test (in which the above command makes sense) and then do

 M-x my-camldebug
 This will ask you how to run the debugger. You write the following

  make test/array1 INFERBOX=infer OCAMLDEBUG=1

 This will call ocamldebug when appropriately with the right arguments and with proper setting of source directories. 

 After that it feels like gdb (see the manual though). The time travel (i.e. backwards stepping) is great. 

 Now the Lisp magic. Put this in your .emacs:

(defvar ocamldebug-history nil)
(defun my-camldebug (command-line)
  "Run camldebug on program FILE in buffer *camldebug-FILE*. The directory containing FILE becomes the initial working directory and source-file directory for camldebug.  If you wish to change this, use the camldebug commands `cd DIR' and `directory'."
  (interactive
   (list (read-from-minibuffer "Run ocamldebug (like this): "
			       (if (consp ocamldebug-history)
				   (car ocamldebug-history)
				 "ocamldebug")
                                 nil
                               nil
			       '(ocamldebug-history . 1))))
  ; call something from camldebug.el to make sure it is loaded
  (camldebug-numeric-arg 1)
  (pop-to-buffer (concat "*camldebug*"))
  (setq words (gud-chop-words command-line)) 
  (message "Current directory is %s" default-directory)
  (apply 'make-comint (cons "camldebug"
                      (cons (car words)
                      (cons nil (cdr words)))))
  (set-process-filter (get-buffer-process (current-buffer))
                      'camldebug-filter)
  (set-process-sentinel (get-buffer-process (current-buffer))
                        'camldebug-sentinel)
  (camldebug-mode)
  (camldebug-set-buffer))
