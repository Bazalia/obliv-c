\documentclass{book}
\def\t#1{{\tt #1}}
\def\DYNAMIC{\t{DYNAMIC}}
\title{CCured: User Manual}

\begin{document}
\maketitle
\chapter{Installing CCured}


\chapter{Using CCured}

\chapter{Customizing CCured}

  \section{Polymorphic functions}

 C programmers use \t{void *} to implement parametric polymorphism. Take for
example the simple \t{identity} function defined below:

\begin{verbatim}
void* identity(void *x) { return x; }
\end{verbatim}

 If we use this function multiple times with incompatible types then CCured
will be forced to infer the \t{DYNAMIC} type for the type of the argument
\t{x}. Alternatively the following pragma can be used {\bf before the first
use of \t{identity}}. 

\begin{verbatim}
#pragma boxpoly("identity")
\end{verbatim}
 
 Upon seeing this pragma CCured will pretend that each call site of
\t{identity} calls a distinct function. In fact, if \t{identity} is also
defined in the project, CCured will create a copy of its body for each
invocation. This will allow the type inferencer to infer appropriate types for
each call site. After inference, CCured coalesces those copies that have the
same adjusted type.

 Notice that if the body of the function refers to globals, then all copies
will refer to the same global. This includes functions. An exception is made
when the body of the polymorphic function calls another polymorphic function
(or itself). In this case the call site is changed to use a new instance of
the called function, for which recursively we will make a copy of the body as
well. For a recursive function, the call site is changed to use the copy of
the function that is being created, thus preserving the recursion and ensuring
the termination of the process. Note that you can construct a program whose
size will grow exponentially if you have a chain of polymorphic functions that
call each other several times. 

  \section{Models for external functions}

 When CCured handles an external function it does not assume anything about
its behavior. A good example is the \t{fgets} function from the C library:
\begin{verbatim}
char* fgets(char* buff, int size, FILE *f);
\end{verbatim}

 This function returns the exact character buffer that was passed in. However,
will not see any connection between the return value and the \t{buff} argument
and might legitimately infer incompatible types for them, such as \t{SAFE} and
\t{DYNAMIC}. To prevent this, the programmer can declare a model for the
function as follows:

\begin{verbatim}
static inline
char *fgets_model(char *buff, int size, FILE *f) __BOXMODEL("fgets");
static inline
char *fgets_model(char *buff, int size, FILE *f) {
     return buff;
}
\end{verbatim}

 (The specifiers \t{static} and \t{inline} are recommended if the above code
 is placed in an include file. The function has a separate prototype because
 \t{gcc} does not allow function attributes to be associated with function
 definitions.)

 Functions that are defined cannot have models. One model can have several
 \t{\_\_BOXMODEL} attributes. 

 For each function with a model CCured creates a dummy body that just invokes
 the model, as follows: 

\begin{verbatim}
char *fgets(char *buff, int size, FILE *f) {
    return fgets_model(buff, size, f);
}
\end{verbatim}

 This will eventually ensure the proper connection between the \t{buff}
argument and the return value. 

 In the model you can use the function \t{\_\_endof} applied to a pointer to
specify that the pointer's representation must be one that allows the
computation of the end of the home area of the pointer. Similarly, use
\t{\_\_startof} to say that you want to be able to computer the start of the
home area. 

 The dummy bodies are removed after type inference. 

 The model can contain any code. In fact, the best model would the the code of
 the function itself, but typically one much smalled suffices.

     \subsection{Polymorphic models}

 For a polymorphic function you should have polymorphic models (use the
\t{\#pragma boxpoly} described above. A separate dummy body is created {\bf for
each invocation of the modeled function}. When these dummy bodies are
processed the calls to the polymorphic model lead to new instances of the
model function. 
 

    \chapter{Using the patcher}

 Occasionally for the purposes of CCured we have needed to modify slightly the
standard include files. So, we developed a simple mechanism that allows us to
create modified copies of the include files and use them instead of the
standard ones. For this purpose we specify a patch file and we run a program
caller that Patcher which makes modified copies of include files and applies
the patch. 

 The patcher is invoked as follows: 
\begin{verbatim}
perl lib/patcher.pl [options]

Options:
  --help       Prints this help message
  --verbose    Prints a lot of information about what is being done
  --mode=xxx   What tool to emulate: 
                gcc     - GNU CC
                mscl    - MS VC cl compiler

  --dest=xxx   The destination directory. Will make one if it does not exist
  --patch=xxx  Patch file (can be specified multiple times)
  --ppargs=xxx An argument to be passed to the preprocessor (can be specified
               multiple times)

  --ufile=xxx  A user-include file to be patched (treated as \#include "xxx")
  --sfile=xxx  A system-include file to be patched (treated as \#include <xxx>)
 
  --clean       Remove all files in the destination directory
  --dumpversion Print the version name used for the current compiler

 All of the other arguments are passed to the preprocessor.
\end{verbatim}

 Based on the given \t{mode} and the current version of the compiler (which
the patcher can print when given the \t{dumpversion} argument) the patcher
will create a subdirectory of the \t{dest} directory (say \t{/usr/home/necula/cil/include}), such as:
\begin{verbatim}
/usr/home/necula/cil/include/gcc_2.95.3-5
\end{verbatim}

 In that file the patcher will copy the modified versions of the include files
specified with the \t{ufile} and \t{sfile} options. Each of these options can
be specified multiple times. 

 The patch file (specified with the \t{patch} option) has a format inspired by
the Unix \t{patch} tool. The file has the following grammar:

\begin{verbatim}
<<<
patterns
===
replacement
>>>
\end{verbatim}

 The patterns can consist of several groups of lines separated by the \t{|||}
marker. Each of these group of lines is a multi-line pattern that if found in
the file will be replaced with the text given at the end of the block. 

 The matching is space-insenstive.

 All of the markers \t{<<<}, \t{|||}, \t{===} and \t{>>>} must appear at the
beginning of a line but they can be followed by arbitrary text (which is
ignored).

 The replacement text can contain the special keyword \t{@\_\_pattern\_\_@},
which is substituted with the pattern that matched. 

  \chapter{Using the combiner}


\end{document}
