
C-Cured Getting Started
-----------------------
(the project formerly known as SafeC)

5/21/01 11:52: initial version
6/29/01 12:16: updated to explain more about the system

C-Cured is a source-to-source translator for C, which instruments the
source C code with runtime checks to catch memory safety violations
at run time.  As a novel enhancement, the system infers when some (or
all!) of the checks can be safely omitted.

The translator itself is written in Ocaml (a dialect of ML).  There is
also a Perl script, safecc.pl, which functions as a drop-in
replacement for 'cc', so that software packages' existing Makefiles
can be used unmodified.  Finally, various runtime functions (including
the Boehm-Weiser conservative garbage collector) are provided by C
code which we write and is linked with the translated executable.


1. Getting the system running
-----------------------------

1.1 Get Ocaml

The first step for most people is to download and install the Ocaml
compiler system.  This is available at:

  http://caml.inria.fr/ocaml/

At the time of writing, the current version is 3.01.  I (Scott) have
been using 3.00 for some time, and have no problems to report.

Be sure to compile and install the native code compiler in addition
to the bytecode compiler.  The native code compiler is used by the
regression test scripts.

To test your ocaml distribution, try:

  % which ocaml
  /usr/local/bin/ocaml

  % ocaml
        Objective Caml version 3.00

  # exit 0;;    <-- you type "exit 0;;", and press enter


1.2 Get the C-Cured sources via CVS

You'll need CVS (Concurrent Version System) installed; version 1.10 or
greater is recommended.  If you don't have it (try "which cvs"), you can
get it from

  http://www.cvshome.org/

Next you'll need an account on brooksie.cs.berkeley.edu; talk to Rahul
(sprahul@cs.berkeley.edu) to get an account.

Next, configure your cvs to use 'ssh' as your connection method.  If you're
using csh/tcsh, use

  setenv CVS_RSH ssh
  
and for sh/bash, use

  export CVS_RSH=ssh

This should probably be put into your .cshrc or .bashrc so it gets run
every time the shell starts.

more info: http://www-inst.EECS.Berkeley.EDU/~cs164/unix.html#env
(this link will likely disappear soon..)

Now, checkout the repository.  As an example, here's how I do it:

  % cvs -d :ext:smcpeak@brooksie.cs:/home/cvs-repository checkout cil
                ^^^^^^^
         use your username instead

This will checkout all the sources into a new directory called cil/, off
the current directory.


1.21 Configuring CVS to run over the SSH protocol in Windows NT
     (might even work in Windows 9x/Me)
     (skip this if you don't intend to use Windows)

It has been observed that the cygwin version of ssh doesn't behave well
with cvs because of some CR-LF translation problems. Hence, you will need 
putty, puttygen, pageant, pscp and plink, all of which are available from:

  http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html

All of the following steps are necessary to get CVS over SSH working:

a. Create a key pair if you dont already have one using puttygen. You will
   end up with the public and private key files "identity" and "identity.pub" in
   a directory named %HOMEPATH%/.ssh

b. Setup pageant (putty ssh-agent): Add a shortcut to the following command line 
   (add/change paths as necessary) in your startup folder -

      pageant.exe  C:\.ssh\identity 

c. Add your public key in the "authorized_keys" file on the CVS server:
   Use the following command line:

       plink -ssh -pw your-password username@cvs-host "cat >> ~/.ssh/authorized_keys" <  C:\.ssh\identity.pub
  
   This appends your identity.pub file to ~/.ssh/authorized_keys file on the server.
   You may do this in any other way you like. You *have* to type your password on the 
   command line if you do it this way, though.

d. Create a "session profile" in putty for the CVS server:
   - Start putty to see the configuration screen with a category tree on the left
   - Session category: fill in the hostname (brooksie) and protocol (SSH) 
   - Connection category: Fill in the auto-login-username field
   - Connection/SSH category: Check "allow agent forwarding"
   - Session category: Save this session under a name (say, "brooksie")

e. Test your session:
   - Start pageant if its not already running. It should ask you for a password 
     for your private key (identity). 
   - Execute the ls command on the server:

	     plink brooksie "ls -a"

     The command should execute without asking for a password and return to the 
     windows prompt after executing "ls -a"

   - Also, the command-line
	   putty @brooksie
     should log you in directly now.

f. Set the environment variables

       CVSROOT=:ext:brooksie:/home/cvs-repository
       CVS_RSH=plink

g. At this point you should be able to run cvs:

      cvs checkout cil

(Send corrections/comments/questions to ab@amanb.net)


1.3 Add a new section to the Makefile for your machine

Near the top of the Makefile, you'll find a section of entries like this:

  ifeq ($(COMPUTERNAME), leetch) # scott's laptop
  BASEDIR=/home/scott/wrk/safec
  SAFECCDIR=$(BASEDIR)
  PCCDIR=$(SAFECCDIR)/cil/test/PCC
  TVDIR=$(BASEDIR)/TransVal
  CILDIR=$(BASEDIR)/cil
  _GNUCC=1
  USE_GC=1
  USER_SCOTT=1
  endif

You should copy+paste this section, and then change the entries to reflect
your setup.  Make sure to set the COMPUTERNAME environment variable in
your shell init file (.cshrc or .bashrc) and adjust the 'ifeq' statement
accordingly.  

Most of the entries simply tell which directories to use; the only one
you should have to change is BASEDIR.  If you're using gcc (as opposed to
msvc), leave _GNUCC=1 there.  USE_GC=1 means to use the garbage collector;
I recommend leaving it as-is.  You can safely remove USER_SCOTT, as that
is something specific to me.


1.4 Compile the translator

Go into the cil/ directory, and run GNU make:

  % cd cil
  % gmake       (or maybe just 'make')


1.5 Run the regression tests

There are currently two regression testers, one maintained by Scott
and the other maintained by George.

Scott's is called 'regrtest' in the base cil directory:

  % cd cil
  % ./regrtest

This should run to completion and report something like:

  All 93 regression tests passed!
  11 tests failed as expected

If a particular test fails (or unexpectedly succeeds), you can tell
the regression tester to skip past that one to proceed with the rest.
For example, if it stops like this:

  [74] A regression test command failed:
    make test/attr4 INFERBOX=4

then it failed on the 75th test (they're numbered from 0), so restart
the script with:

  % ./regrtest -skip 75

And of course, report these to us!

George's test script is much more sophisticated, but takes longer to
run in its default configuration.  It is in the 'test' directory, called
'testsafec'.  Run it like this:

  % cd cil/test
  % ./testsafec --run

This will take between one and two hours.  It produces a log (safec.log)
which can be used to review why individual tests failed.

Please see doc/REGTEST.txt for more information on George's script.


2. Using the system
-------------------

2.1 Interaction with CVS

CVS is used to synchronize changes to the project across multiple
developers.  See the CVS website for detailed information

  http://www.cvshome.org/
  
There are a few common commands you'll need.  Each of these is to be run
in the base 'cil' directory (the one with 'regrtest'):

  cvs [-n] update -d [filename]

    This retrieves any changes recently committed by others.  This is
    usually necessary before you can commit your own changes.  It is a
    good idea to run the fast regression test ('regrtest') before and
    after doing "cvs update" so you can know whether it was you or the
    update which broke something.

    The optional -n flag tells CVS to not actually change any of your
    files.  This is useful for querying the status of the repository.

    The -d argument tells cvs to create on your machine any new directories
    that somebody might have checked in. By default cvs does not create new
    directories. This flag is so useful that many people find it useful to
    create a ~/.cvsrc file with on line containing "update -d" in it. This way
    you don't have to specify the flag all the time.

    If you specify a filename (after cd'ing to the directory containing it),
    only that file will be updated, otherwise everything in the current
    directory and below is updated. Run this in the top-level project
    directory to update the entire project. A useful idiom for undoing all of
    your changes is "cd dir; rm file; cvs update file".

    
  cvs commit [filename]

    This pushes your changes into the repository, so that the next time
    someone does "cvs update" they will get your changes.  Please try to
    only commit when the regression test script passes.
    
    If you specify a filename, only that file will be committed, otherwise
    everything in the current directory and below is checked in. Run this in
    the top-level project directory to check all of your changes in.

  cvs add filename

    This adds a new file to the repository.  It isn't visible in the
    repository until you do a commit.


2.2 The Makefile

The Makefile has lots of targets.  About half are used to build the
translator itself, and half are used to build instrumented versions of
various benchmarks.  Typical usage is to explicitly specify the name
of a benchmark to build.  For example

  % make go [options]

This will build the 'go' benchmark (which as of 6/29/01 actually works!).

If you don't specify any options, the translator operates in 'cil' mode:
it reads the file in, translates it into our intermediate format, and
then spits it right back out (no instrumentation).  This is primarily a
test of the parser and the intermediate format.

To add instrumentation, use "INFERBOX=4" or "INFERBOX=wild".  The former
uses type inference to try to remove many of the runtime checks.  The
latter does not try to remove any checks.  Generally, "INFERBOX=4" is
what you want:

  % make go INFERBOX=4

There are a bunch of other options strewn throughout the Makefile; they
look like this in the Makefile:

  ifeq ($(INFERBOX), 4)
      SAFECC+= --safec=-solver --safec=fourth
  endif

One target of note is the one I use for making the small test programs
that comprise the bulk of 'regrtest': scott/% (the '%' is a pattern
wildcard).  When you drop a .c file, say foo.c, into test/small2, you
can invoke the translator on it by using this target:

  % make scott/foo [options]

If you construct a test case to exhibit some current bug, current
practice is to drop that file into test/small2 so we can use the scott/%
target to run it.


2.3 Pushing software packages through the translator

TODO: Add some info about putting new packages into the repository.

Once a package is in the repository and has its own Makefile target,
you can run the translator on it.  I'll use the 6/29/01 version of ftpd
as my example.

First we try to run it without our tool involved:

  % make ftpd-clean
  % cd test/ftpd/ftpd
  % make
  
This succeeds, generating an 'ftpd' binary.  In the case of 'ftpd', 
running it is slightly complicated:

  % ./ftpd -D -d -p 3333
  (then in another window)
  % telnet localhost 3333
  Trying 127.0.0.1...
  Connected to localhost.
  Escape character is '^]'.
  220 madrone.cs.berkeley.edu FTP server (Version 6.5/OpenBSD, linux port 0.3.2) ready.
  (etc)
  
This is (to our way of measuring) success.

Now we try it in 'cil' mode:

  % cd cil
  % make ftpd-clean
  % make ftpd
  
At the moment, this also works, producing another 'ftpd' binary.  We test
it the same way, and rejoice at its success.

Finally, we dare to try it in 'box' mode, meaning the instrumentation
module will be used:

  % make ftpd-clean
  % make ftpd INFERBOX=4
  
After crunching for a while, it reports this error (you have to scroll
back a bit to see the right one):

  ./ls_all.c:1338: Bug: Calling non-wild ioctl with too many args

This is an error from the 'box' module, complaining about what it
perceives to be a type error.  If we investigate the named source
line, we see

  if(ioctl(1, 0x5413, & win) == 0 && win.ws_col > 0)

confirming that 'ioctl' is involved.  Since the *_all.c files are the
output of our tool, and do not themselves #include any files, we can
simply search in this file for ioctl's declaration.  We do so, and see

  extern int ioctl(int __fd , unsigned long int __request , ...) ;
  
Hmmm... looks like it was declared to accept any # (>=2) of args, so
this looks like a bug in the 'box' module; it should accept this code,
but it does not.

The next step is to write a tiny C program which calls ioctl (see
test/small2/ioctl.c), and verify it fails the same way

  % make scott/ioctl INFERBOX=4
  [...]
  ioctl.c:9: Bug: Calling non-wild ioctl with too many args
  [...]
  
Yep, same problem.  Now we report this to George, since typically he's
much faster at identifying the problem, since he wrote the 'box' module.

In the meantime (waiting for George to magically fix the problem), we
could temporarily comment-out the call so we can proceed to find other
bugs.  Or, perhaps we change the ioctl call to instead call a wrapper
function (wrappers are defined in lib/safec.c, which gets linked into
the translated program).

Eventually (see "make go INFERBOX=4") we'll get an executable.  If it
runs correctly, celebration is in order.  If not, it will usually fail
because of a failed runtime check (this one is from a test vector for
which go fails);

  % make go INFERBOX=4
  % cd test/spec/099.go/src
  % ./go 5 4
  [...]
  array bug: index is 5980 (vs 5980)
  Failure: Ubound
  Abort

Tracking down the source of such failures is the most timeconsuming
part of pushing a program through.  Sometimes it's a bug in the
translator, in which case ideally a test case can be isolated for easy
diagnosis.  

Sometimes (more and more often) it's a bug in the original program (go
had 10 array bounds violation bugs at last count).  In this case you
have to change the original code to fix the bug; this may be easy or
hard.  If it's hard, try just surrounding the offending statement with
an explicit bounds check in an 'if' statement, so the program skips
the bad statements (that is what I did to cause all of the "array bug"
outputs in the "5 4" case above).


4. Tour of the translator source code

Below is a brief decription of most of the important source files.

src/: (ML code)
  box: insert runtime checks
  check: a consistency checker for CIL. The most precise "documentation" of
  the meaning of CIL.
  cil: representation of intermediate lang (C but no side
       effects in expressions); includes cil -> doc
  cilparse: parsing our stuff?
  errormsg: A few utilities for reporting error messages and for logging
  frontc: C parser (C source -> cabs -> cil)
  globinit: add initializers to modules?
  main: entry point to 'safec' tool; processes command-line flags
  markptr: marks pointers based on usage (input to inferencer)
  mllex: ?
  notes.txt: describes syntax of 'asm' statements in gcc
  oneret: a simple program transformation that pull all return statements to
  the end of the function body. A good example of how to use CIL.
  optim: rahul's bounds-check elim stuff
  pretty: generic pretty-printer (doc -> string)
  ptrnode: graph for inference algorithm
  rmtmps: remove unused temporaries introduced by 'box'
  secondsolve: 2nd solver?
  simplesolve: 1st solver; decides which pointer flavors to use
    based on how those pointers were used by programmer
  stats: a few utilities for timing the execution
  thirdsolve: 3rd solver (currently used; INFERBOX=3)
  trace: something for debugging output
  util: ?
  wildsolve: ?

lib/: (C code for use at runtime)
  fixup.h: prepended to every input source file before boxing
  safec.c: library wrappers (e.g. fopen_w)
  safec_gcc.patch: patching nonsense (for GCC)
  safec_msvc.patch: patching nonsense (for MSVC)
  safecc.pl: intended to be drop-in replacement for 'gcc' and for MS 'cl'
  safeccheck.h: "inline" macros for doing runtime checks
  safecmain.c: wrapper for 'main' in case it takes arguments
  scaninfer: ?
  gc/: boehm-weiser garbage collector (http://www.hpl.hp.com/personal/Hans_Boehm/gc/)
  

5. Useful links

  http://www.dcs.napier.ac.uk/course-notes/sml/manual.html

    Tutorial on ML

  http://caml.inria.fr/ocaml/
  
    Documentation and sources for Ocaml

  http://www.cvshome.org/

    Documentation and sources for CVS

  http://www.gnu.org/manual/make/html_chapter/make_toc.html

    Manual for GNU make

