(*
 *
 * Copyright (c) 2001 by
 *  George C. Necula	necula@cs.berkeley.edu
 *  Scott McPeak        smcpeak@cs.berkeley.edu
 *  Wes Weimer          weimer@cs.berkeley.edu
 *   
 * All rights reserved.  Permission to use, copy, modify and distribute
 * this software for research purposes only is hereby granted, 
 * provided that the following conditions are met: 
 * 1. Redistributions of source code must retain the above copyright notice, 
 * this list of conditions and the following disclaimer. 
 * 2. Redistributions in binary form must reproduce the above copyright notice, 
 * this list of conditions and the following disclaimer in the documentation 
 * and/or other materials provided with the distribution. 
 * 3. The name of the authors may not be used to endorse or promote products 
 * derived from  this software without specific prior written permission. 
 *
 * DISCLAIMER:
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR 
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES 
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
 * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT, 
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS 
 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF 
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *)


module E = Errormsg
open Pretty

exception ParseError of string

(* parse, and apply patching *)
let rec parse_to_cabs fname =
  let cabs = 
    try
      if !E.verboseFlag then 
        ignore (E.log "Frontc is parsing %s\n" fname);
      flush !E.logChannel;
      let file = open_in fname in
      E.hadErrors := false;
      let lexbuf: Lexing.lexbuf = Clexer.init fname file in
      let cabs =
        Stats.time "parse"
          (Cparser.file Clexer.initial) lexbuf in
      close_in file;
      if !E.verboseFlag then 
        ignore (E.log "Frontc finished parsing %s\n" fname);
      cabs
    with (Sys_error msg) -> begin
      ignore (E.log "Cannot open %s : %s\n" fname msg);
      raise (ParseError("Cannot open " ^ fname ^ ": " ^ msg ^ "\n"))
    end
    | Parsing.Parse_error -> begin
        ignore (E.log "Parsing error\n");
        raise (ParseError("Parse error"))
    end
    | e -> begin
        ignore (E.log "Caught %s while parsing\n" (Printexc.to_string e));
        raise e
    end
  in
  cabs

let merge (files: string list) (out: string) =
  let merged_cabs = 
    let list_of_parsed_files =
      List.map (fun file_name -> parse_to_cabs file_name) files
    in
    Stats.time "merge"
      (fun _ -> Merger.merge list_of_parsed_files) ()
  in
  try
    let o = open_out out in
    output_string o ("/* Generated by Frontc */\n");
    Stats.time "printMerged" (Cprint.printFile o) merged_cabs;
    close_out o;
    if !E.hadErrors then 
      E.s (E.error "There were parsing errors\n")
  with (Sys_error msg) as e -> begin
    ignore (E.log "Cannot open %s : %s\n" out msg);
    raise e
  end

        
(***** MAIN *****)  
let rec theMain () =
  let usageMsg = "Usage: merger [options] source-files" in
  let files : string list ref = ref [] in
  let recordFile fname = files := fname :: (!files) in
  (* Parsing of files with additional names *)
  let parseExtraFile (s: string) = 
    try
      let sfile = open_in s in
      while true do
        let line = try input_line sfile with e -> (close_in sfile; raise e) in
        let linelen = String.length line in
        let rec scan (pos: int) (* next char to look at *)
                     (start: int) : unit (* start of the word, 
                                            or -1 if none *) =
          if pos >= linelen then 
            if start >= 0 then 
              recordFile (String.sub line start (pos - start))
            else 
              () (* Just move on to the next line *)
          else
            let c = String.get line pos in
            match c with 
              ' ' | '\n' | '\r' | '\t' -> 
                (* whitespace *)
                if start >= 0 then begin
                  recordFile (String.sub line start (pos - start));
                end;
                scan (pos + 1) (-1)

            | _ -> (* non-whitespace *)
                if start >= 0 then 
                  scan (pos + 1) start 
                else
                  scan (pos + 1) pos
        in
        scan 0 (-1)
      done
    with Sys_error _ -> E.s (E.error "Cannot find extra file: %s\n" s)
   |  End_of_file -> () 
  in
  let outputFile = ref "" in
  let openLog lfile =
    if !E.verboseFlag then
      ignore (Printf.printf "Setting log file to %s\n" lfile);
    try E.logChannel := open_out lfile with _ ->
      raise (Arg.Bad "Cannot open log file") in
  let setDebugFlag v name = 
    E.debugFlag := v; if v then Pretty.flushOften := true
  in
  (*********** COMMAND LINE ARGUMENTS *****************)
  let argDescr = [
    "--verbose", Arg.Unit (fun _ -> E.verboseFlag := true),
                "turn of verbose mode";
    "--debug", Arg.String (setDebugFlag true),
                     "<xxx> turns on debugging flag xxx";
    "--flush", Arg.Unit (fun _ -> Pretty.flushOften := true),
                     "Flush the output streams often (aids debugging)" ;
    "--log", Arg.String openLog, "the name of the log file";
    "--o", Arg.String (fun s -> outputFile := s),
                     "output file for the merger";
    "--MSVC", Arg.Unit (fun _ -> Cprint.msvcMode := true),
             "Produce MSVC output. Default is GNU";
    "--noPrintLn", Arg.Unit (fun _ -> Cprint.printLn := false),
               "don't output #line directives";
    "--commPrintLn", Arg.Unit (fun _ -> Cprint.printLnComment := true),
               "output #line directives in comments";
    "--extrafiles", Arg.String parseExtraFile,
    "<filename>: the name of a file that contains a list of additional files to process, separated by whitespace of newlines";
  ] in
  begin
    Stats.reset ();
    Arg.parse argDescr recordFile usageMsg;
    files := List.rev !files;
    if !outputFile = "" then 
      E.s (E.bug "No output file was specified");
    merge !files !outputFile
  end
;;
                                        (* Define a wrapper for main to 
                                         * intercept the exit *)
let failed = ref false 
let main () = 
  let term = 
    try 
      theMain (); 
      fun () -> exit (if !failed then 1 else 0)
    with e ->  
      (fun () -> 
        print_string ("Uncaught exception: " ^ (Printexc.to_string e)
                      ^ "\n");
        Stats.print stderr "Timings:\n";
        exit 2)
  in
  begin
    if !E.verboseFlag then
      Stats.print stderr "Timings:\n";
    term ()
  end
;;

Printexc.catch main ()
;;
