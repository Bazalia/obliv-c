module E = Errormsg

(* Output management *)
let out = ref stdout
let close_me = ref false

let close_output _ =
  flush !out;
  if !close_me then close_out !out else ();
  close_me := false

let set_output filename =
  close_output ();
  (try out := open_out filename (*; prerr_string (filename ^ " opened\n.")*)
  with (Sys_error msg) ->
    output_string stderr ("Error while opening output: " ^ msg); exit 1);
  close_me := true
       

(*
** Argument definition
*)
let args : (string * Arg.spec * string) list = 
[
  "-cabsout", Arg.String set_output, "Output file";
  "-cabsindent", Arg.Int Cprint.set_tab, "Identation step";
  "-cabswidth", Arg.Int Cprint.set_width, "Page width";
]

exception ParseError of string
let parse fname = 
  try
    ignore (E.log "Frontc is parsing %s\n" fname);
    let file = open_in fname in
    Clexer.init (false, file, "", "", 0, 0, stderr, fname);
    let cabs = 
      Stats.time "parse"
        (Cparser.file Clexer.initial)
	(Lexing.from_function 
           (Clexer.get_buffer Clexer.current_handle)) in
    close_in file;
    ignore (E.log "Frontc finished parsing\n");
    output_string !out ("/* Generated by Frontc */\n");
    Cprint.print !out cabs;
    close_output ();
    (* Now convert to CIL *)
    let cil = Stats.time "conv" Cabs2cil.convFile cabs in
    ignore (E.log "FrontC finished conversion to CIL\n");
    cil
  with (Sys_error msg) -> begin
    ignore (E.log "Cannot open %s : %s\n" fname msg);
    close_output ();
    raise (ParseError("Cannot open " ^ fname ^ ": " ^ msg ^ "\n"))
  end
  | Parsing.Parse_error -> begin
      ignore (E.log "Parsing error");
      close_output ();
      raise (ParseError("Parse error"))
  end
  | e -> begin
      ignore (E.log "Caught %s while parsing\n" (Printexc.to_string e));
      raise e
  end
    






