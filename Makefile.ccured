# toplevel Makefile for CCured project
# author: George Necula
#

# Debugging. Set ECHO= to debug this Makefile 
ECHO := @

# First stuff that makes the executable 

SOURCEDIRS  := src
OBJDIR      := obj
MLLS        := 
MLYS        := 
MODULES     := pretty trace errormsg stats util clist \
               cil cfg logcalls logwrites check ptrnode \
               solveutil solver globinit \
               oneret boxsplit boxstats box markptr \
               rmtmps optim seoptim
EXECUTABLE  := $(OBJDIR)/ccured
CAMLUSEUNIX := 1
ifdef RELEASE
  UNSAFE    := 1
endif
CAMLLIBS    := 

# Front end stuff
SOURCEDIRS += src/frontc
MLLS       += clexer.mll
MLYS       += cparser.mly
MODULES    += cabs cprint clexer cparser cabs2cil cabsvisit \
              frontc

# Add main late
MODULES    += main


# Additional things to clean
EXTRACLEAN += $(OBJDIR)/*.obj $(OBJDIR)/*.a $(OBJDIR)/*.o


    # Include now the common set of rules for OCAML
    # This file will add the rules to make $(EXECUTABLE)$(EXE) along with 
    # cleancaml and realcleancaml
include Makefile.ocaml


# sm: this is checked in the outer Makefile, but it won't hurt here
ifndef CCUREDHOME
  $(error You have not defined the CCUREDHOME variable)
endif

CCURED := perl $(CCUREDHOME)/lib/ccured.pl 
PATCHER := perl $(CCUREDHOME)/lib/patcher.pl

# Now do the user-specific customization
# It is Ok if this file does not exist
-include $(CCUREDHOME)/.ccuredrc

# By default use GCC, unless you set MSVC
ifndef _MSVC
  _GNUCC := 1
endif

# Now include the compiler specific stuff
ifdef _MSVC
 include Makefile.msvc
else
  ifdef _GNUCC
    include Makefile.gcc
  endif
endif

# sm: separating release library from release tools
ifdef RELEASELIB
  COMPILEREXT := $(COMPILERNAME)_releaselib
else
  COMPILEREXT := $(COMPILERNAME)_debug
endif



PATCHER +=--mode=$(COMPILERNAME)


CCUREDLIB := obj/ccured_$(COMPILEREXT).$(LIBEXT)

# garbage collector options
#ifdef _MSVC
#  # No garbage collection on MSVC for now
#NOGC:= 1
#endif

GCLIB := $(CCUREDHOME)/lib/gc/$(COMPILERNAME)/gc.$(LIBEXT)
ifdef _MSVC 
  GCMAKE := make -f Makefile.msvc srcdir=..
else
  GCMAKE := make -f ../Makefile srcdir=..
endif
# pretend it's only dependent on one file; that's not true of course,
# but we rarely (ever?) modify the gc's sources, and one dependency
# is better than none (which causes recompile every time!)
$(GCLIB): $(CCUREDHOME)/lib/gc/mark.c
	cd $(CCUREDHOME)/lib/gc/$(COMPILERNAME); $(GCMAKE)
	cd $(CCUREDHOME)/lib/gc/$(COMPILERNAME); \
            rm -f gc.log; ./gctest; if test -f gc.log ;then cat gc.log; fi

###
###
###    # Now the rules to make the library
###
###
CCUREDLIBARG :=

# RELEASELIB means we try for performance, with terse error messages
# !RELEASELIB means enable more debugging checking, and try to produce
#             better error messages
ifdef RELEASELIB
  CCUREDLIBARG+= $(DEF)RELEASELIB
endif

# _DEBUG means to try to drop into the debugger on failure
ifndef RELEASELIB
  CCUREDLIBARG+= $(DEF)_DEBUG
endif

# NO_FPFAIL_SYSLOG means the syslog(2) call in safec.c will be omitted
ifdef NO_FPFAIL_SYSLOG
  CCUREDLIBARG+= $(DEF)NO_FPFAIL_SYSLOG
endif

# we build the library from source each time, so that we don't end up
# with .o files built with Makefile arguments that have changed
$(CCUREDLIB): lib/safec.c lib/safec.h lib/safeccheck.h lib/splay.c $(GCLIB) 
	@echo "Trying to build $(CCUREDLIB)"
	$(CC) $(CFLAGS) $(INC)./lib $(CONLY) $(CCUREDLIBARG) \
                    $(OBJOUT)obj/safec.$(OBJEXT) lib/safec.c
	$(CC) $(CFLAGS) $(INC)./lib $(CONLY) $(CCUREDLIBARG) \
                    $(OBJOUT)obj/splay.$(OBJEXT) lib/splay.c
ifdef _GNUCC
	cp -f $(GCLIB) $@
	ar -rs $@                  obj/safec.$(OBJEXT) obj/splay.$(OBJEXT) 
else
	$(AR) $(LIBOUT)$@ $(GCLIB) obj/safec.$(OBJEXT) obj/splay.$(OBJEXT) 
endif

# we need to know what the patcher will think the compiler's version is
COMPILERVERSION := $(shell $(PATCHER) --dumpversion)

# names all of the patched include files, so we can have a proper dependency
PATCHEDHEADERS := $(foreach file, $(PATCH_SYSINCLUDES), \
                    $(CCUREDHOME)/include/$(COMPILERVERSION)/$(file))

######################
.PHONY : combiner cilly presetup all setup includes cleanincludes

combiner:
	$(MAKE) -r -f Makefile.combiner $(MAKEOVERRIDES)

cilly: 
	$(MAKE) -r -f Makefile.cil $(MAKEOVERRIDES)

libraries: $(CCUREDLIB) $(PATCHEDHEADERS)

all: combiner cilly $(EXECUTABLE)$(EXE) libraries


#foo := $(shell echo "PATCHEDHEADERS = $(PATCHEDHEADERS)" 1>&2; echo hi)

setup:
	$(MAKE) -f Makefile.ccured all $(MAKEOVERRIDES) RELEASE= 
	$(MAKE) -f Makefile.ccured all $(MAKEOVERRIDES) RELEASE=1
ifdef _MSVC
	$(MAKE) -f Makefile.ccured libraries _GNUCC=1 RELEASE= \
                                             $(MAKEOVERRIDES) 
	$(MAKE) -f Makefile.ccured libraries _GNUCC=1 RELEASE=1 \
                                             $(MAKEOVERRIDES) 
endif

quickbuild:  combiner $(EXECUTABLE)$(EXE) libraries

# the patch template file
PATCHTEMPLATE := $(CCUREDHOME)/lib/ccured_$(COMPILERNAME).patch

$(PATCHEDHEADERS): $(CCUREDHOME)/lib/patcher.pl $(PATCHTEMPLATE)
#       throw away all the existing patched includes
	$(PATCHER) --dest=$(CCUREDHOME)/include --clean
#       now re-regenerate them
	$(PATCHER) --patch=$(PATCHTEMPLATE) \
                   --dest=$(CCUREDHOME)/include \
	           $(foreach file,$(PATCH_SYSINCLUDES), --sfile=$(file))

# don't be confused by presence of odoc/ directory
.PHONY: odoc
odoc:
	mkdir odoc 2>/dev/null || true
	odoc -d odoc -html -t "CCured Module Documentation" \
	     -I obj src/*.mli src/frontc/*.mli

clean: cleancaml
	$(PATCHER) --dest=$(CCUREDHOME)/include --clean
	rm -f $(CCUREDLIB)
	make -C $(CCUREDHOME)/lib/gc clean
	cd $(CCUREDHOME)/lib/gc; \
	     	rm -f $(foreach COMP, GNUCC MSVC, \
                     $(foreach EXT, exe o a obj lib, $(COMP)/*.$(EXT)))
testgc:
	rm -f $(GCLIB)
	make
	objdump --syms $(CCUREDLIB) | grep GC_