#include <stdio.h>
#include <string.h>

//matth: On Cygwin, the call to _mcount doesn't link, so only override mcount
//on Linux.  This tests whether @ARCHOS@ == x86_LINUX:
#define ARCHOS  @ARCHOS@
#if ARCHOS == x86_LINUX

// Try to put here the new mcount function
extern int _mcount(unsigned long, unsigned long);
static int tableLoaded = 0; // Whether we have loaded the table
// The table contains the ranges we must skip
#define MAX_RANGE 128
struct range {
  unsigned long low, high;
} rangetable[MAX_RANGE];
int nextIdx = 0; // The index of the next free element

int findInTable(unsigned long pc) {
  int l = 0, h = nextIdx; // If the element exists its index is >= l and < h
  while(l < h) {
    int m = (l + h) >> 1;
    // l <= m < h
    if(pc < rangetable[m].low) {
      h = m; // make progress because m < h
    } else
      if(pc >= rangetable[m].high) {
        l = m + 1; // make progress because m + 1 > l
      } else {
        // m is the one we need
        return 1;
      }
  }
  return 0;
}
void loadTable() {
  // See if we have defined the magic environment variable
  char *f = getenv("PROFILE_SKIP_RANGE_FILE");
  if(f) {
    FILE *ff = fopen(f, "r");
    while(! feof(ff))  {
      unsigned long low, high;
      int i;
      if(nextIdx >= MAX_RANGE) {
        fprintf(stderr, "Too many profile ranges");
        break;
      }
      if(2 != fscanf(ff, "%ld-%ld ", &low, &high)) {
        fprintf(stderr, "Invalid line in profile ranges file %s\n", f);
        break;
      }
      fprintf(stderr,
              "Loaded profile skip range %ld-%ld\n", low, high);
      // Insert it sorted in the table
      for(i=0;i<nextIdx;i++) {
        if(rangetable[i].low == low)
          break;

        if(rangetable[i].low > low) {
          memmove(& rangetable[i + 1], &rangetable[i],
                  sizeof(rangetable[0]) * (nextIdx - i));
          rangetable[i].low = low;
          rangetable[i].high = high;
          nextIdx ++;
          break;
        } 
      }
      if(i == nextIdx) {
        // We have not inserted it yet
        rangetable[i].low = low;
        rangetable[i].high = high;
        nextIdx ++;
      }
    }
    fclose(ff);
  }
  tableLoaded = 1;
  if(1) {
    int i;
    fprintf(stderr, "Table is:\n");
    for(i=0;i<nextIdx;i++) {
      fprintf(stderr, "  %ld-%ld\n", rangetable[i].low, rangetable[i].high);
    }
  }
}

// We must tell GCC not to instrument this function for profiling  
void mcount1() {
  unsigned long selfpc, frompc;
  selfpc = (unsigned long)__builtin_return_address(0);
  frompc = (unsigned long)__builtin_return_address(1);
  /*
  printf("You called mcount. PC=0x%lx, FROM=0x%lx, GRAND=0x%lx\n",
         selfpc, frompc, grand); 
  */
  if(! tableLoaded) loadTable ();

  // fprintf(stderr, "findInTable %ld\n", frompc);
  if(0 && findInTable(frompc)) {
    // fprintf(stderr, "  found\n");
    frompc = (unsigned long)__builtin_return_address(2);
  } else {
    // fprintf(stderr, "  not found\n");
  }
  _mcount(frompc, selfpc);
}

#endif  //ARCHOS == "x86_LINUX"
