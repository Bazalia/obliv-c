// -*- Mode: c -*-
//
/*
 * A module that allows the reading of performance counters on Pentium.
 *
 * This file contains both code that uses the performance counters to 
 * compute the number of cycles per second (to be used during ./configure) 
 * and also code to read the performance counters from Ocaml.
 *
 * Author: George Necula (necula@cs.berkeley.edu)
 */
#include <stdio.h>
#include <string.h>
/* Store here the first value read from the performance counter */
unsigned static long long first_value;

/* This is the function that actually reads the performance counter. */
inline static unsigned long long read_ppc() {
  unsigned long low, high;
  unsigned long long lowhigh;

#if !defined(__i386__)
  printf ("Reading of performance counters is supported only on Intel x86\n");
  exit(1);
#endif

  // RDTSC puts the result in EAX and EDX. We tell gcc to use those registers
  // for "low" and "high"
  __asm__ volatile ("rdtsc" : "=a" (low), "=d" (high));

  // printf ("Read low=0x%08lx high=0x%08lx\n", low, high);

  // Put the 64-bit value together
  lowhigh = ((unsigned long long)low) | ((unsigned long long)high << 32);

  if(first_value == 0) {
    first_value = lowhigh;
  }
  return lowhigh - first_value;
}


#ifndef CONFIGURATION_ONLY
/*** This is the OCAML stub for the read_ppc ***/
#include <caml/mlvalues.h>
#include <caml/alloc.h>
#include <caml/memory.h>

#define CYCLES_PER_USEC @CYCLES_PER_USEC@
value read_pentium_perfcount()
{
  double counter = (double)read_ppc() / (1000000.0 * CYCLES_PER_USEC);
  return copy_double(counter);
}

/* The Ocaml system can use this function to figure out if there are 
 * performance counters available */
value has_performance_counters() {
  // HAS_PERFCOUNT is set by the configuration code at the end of
  // this file, during ./configure
#if @HAS_PERFCOUNT@ != 0
  return Val_true;
#else
  return Val_false;
#endif  
}

#endif


/* Now we have a function that tries to compute the number of cycles per 
 * second (to be used during ./configure) */
#ifdef CONFIGURATION_ONLY
#include <sys/times.h>
#include <unistd.h>
#include <math.h>

int main() {
  struct tms t;
  clock_t start, finish, diff;
  unsigned long long start_pc, finish_pc, diff_pc;
  long clk_per_sec = sysconf(_SC_CLK_TCK);
  double cycles_per_usec;
  
  if(clk_per_sec <= 0) {
    printf("Cannot find clk_per_sec (got %ld)\n", clk_per_sec);
    exit(1);
  }
  
  times(&t); start = t.tms_utime;
  start_pc = read_ppc();
  // Do something for a while
  {
    int i;
    double a = 5.678;
    for(i=0;i<10000000;i++) {
      a = (i & 1) ? (a * a) : (sqrt(a));
    }
  }
  times(&t); finish = t.tms_utime;
  finish_pc = read_ppc();
  diff = finish - start;
  diff_pc = finish_pc - start_pc;
  if(diff == 0) {
    printf("Cannot use Unix.times\n");
    exit(1);
  }
  if(diff_pc == 0) {
    printf("Invalid result from the peformance counters\n");
    exit(1);
  }
  diff_pc /= 1000000; // We care about cycles per microsecond
//  printf("diff = %ld, diff_pc = %ld, clk = %ld\n",
//         (long)diff,
//         (long)diff_pc, (long)clk_per_sec);

  cycles_per_usec = (((double)diff_pc / (double)diff)
                               * (double)clk_per_sec);

  /* Whatever value we print here will be used as the CYCLES_PER_USEC
   * below */
  printf("%.3lf\n", cycles_per_usec);
  exit(0);
}
#endif

// Try to put here the new mcount function
extern int _mcount(unsigned long, unsigned long);
static int tableLoaded = 0; // Whether we have loaded the table
// The table contains the ranges we must skip
#define MAX_RANGE 128
struct range {
  unsigned long low, high;
} rangetable[MAX_RANGE];
int nextIdx = 0; // The index of the next free element

int findInTable(unsigned long pc) {
  int l = 0, h = nextIdx; // If the element exists its index is >= l and < h
  while(l < h) {
    int m = (l + h) >> 1;
    // l <= m < h
    if(pc < rangetable[m].low) {
      h = m; // make progress because m < h
    } else
      if(pc >= rangetable[m].high) {
        l = m + 1; // make progress because m + 1 > l
      } else {
        // m is the one we need
        return 1;
      }
  }
  return 0;
}
void loadTable() {
  // See if we have defined the magic environment variable
  char *f = getenv("PROFILE_SKIP_RANGE_FILE");
  if(f) {
    FILE *ff = fopen(f, "r");
    while(! feof(ff))  {
      unsigned long low, high;
      int i;
      if(nextIdx >= MAX_RANGE) {
        fprintf(stderr, "Too many profile ranges");
        break;
      }
      if(2 != fscanf(ff, "%ld-%ld ", &low, &high)) {
        fprintf(stderr, "Invalid line in profile ranges file %s\n", f);
        break;
      }
      fprintf(stderr,
              "Loaded profile skip range %ld-%ld\n", low, high);
      // Insert it sorted in the table
      for(i=0;i<nextIdx;i++) {
        if(rangetable[i].low == low)
          break;

        if(rangetable[i].low > low) {
          memmove(& rangetable[i + 1], &rangetable[i],
                  sizeof(rangetable[0]) * (nextIdx - i));
          rangetable[i].low = low;
          rangetable[i].high = high;
          nextIdx ++;
          break;
        } 
      }
      if(i == nextIdx) {
        // We have not inserted it yet
        rangetable[i].low = low;
        rangetable[i].high = high;
        nextIdx ++;
      }
    }
    fclose(ff);
  }
  tableLoaded = 1;
  if(1) {
    int i;
    fprintf(stderr, "Table is:\n");
    for(i=0;i<nextIdx;i++) {
      fprintf(stderr, "  %ld-%ld\n", rangetable[i].low, rangetable[i].high);
    }
  }
}

// We must tell GCC not to instrument this function for profiling  
void mcount1() {
  unsigned long selfpc, frompc;
  selfpc = (unsigned long)__builtin_return_address(0);
  frompc = (unsigned long)__builtin_return_address(1);
  /*
  printf("You called mcount. PC=0x%lx, FROM=0x%lx, GRAND=0x%lx\n",
         selfpc, frompc, grand); 
  */
  if(! tableLoaded) loadTable ();

  // fprintf(stderr, "findInTable %ld\n", frompc);
  if(0 && findInTable(frompc)) {
    // fprintf(stderr, "  found\n");
    frompc = (unsigned long)__builtin_return_address(2);
  } else {
    // fprintf(stderr, "  not found\n");
  }
  _mcount(frompc, selfpc);
}
