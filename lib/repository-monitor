#!/usr/bin/perl -w
# Monitor the repository for new checkins, and when that
# happens, automatically check it out and try to build.

# configuration
$home = $ENV{HOME};
$ph = "$home/public_html";
$statusFilename = "$ph/status.txt";      # what I am doing now
$logFilename = "$ph/log.txt";            # all output gets appended here
$sleepTime = 60;                         # seconds to sleep while waiting

# cause ctrl-c to bail (this doesn't work?)
sub intHandler {
  print("I saw ctrl-c\n");
  die("interrupted\n");
}
$SIG{'INT'} = \&intHandler;


# print something for debugging purposes
sub diagnostic {
  my ($line) = @_;
  print ($line, "\n");
}

# write a line to status file
sub status {
  my ($line) = @_;
  diagnostic($line);
  open (STATUS, ">>$statusFilename") || die("can't open $statusFilename: $!\n");
  print STATUS (firstLine("date"), ": ", $line, "\n");
  close(STATUS);
}

# write a bunch of stuff to the log file, preceeded by a header;
# the stuff is indented by 2 spaces, and each line is expected
# to already be newline-terminated
sub mylog {
  my ($title) = $_[0];
  open (LOG, ">>$logFilename") || die("can't open $logFilename: $!\n");
  print LOG (firstLine("date"), ": ", $title, ":\n");
  for ($i=1; $i < @_; $i++) {
    print LOG ("  ", $_[$i]);
  }
  close(LOG);
}

# get first line of a command's output, without a newline
sub firstLine {
  my ($cmd) = @_;
  @lines = `$cmd`;
  if (($? >> 8) > 0) {
    die("command failed: $cmd\n");
  }
  chomp($lines[0]);
  return $lines[0];
}

# run a command, log its output, and return true for success
sub logrun {
  my ($cmd, $outfile) = @_;

  # show what we're doing
  status("running $cmd");

  # time execution
  my $start = time();

  # run the command
  my $ok = system("($cmd) >$outfile 2>&1") == 0;
  my $elapsed = time() - $start;
  @output = `cat $outfile`;

  # log the results
  mylog("output of $cmd [$elapsed seconds]", @output);

  @output = ();      # "free"

  if ($ok) {
    status("$cmd succeeded");
  }
  else {
    status("$cmd failed");
  }

  return $ok;
}


# main loop
while (1) {
  # see whether anything new got committed
  diagnostic ("updating...");
  @changes = `cvs -q update`;
  if (($? >> 8) > 0) {
    die("cvs update failed\n");
  }

  # remove lines indicated files unknown to cvs
  @changes = grep(!/^\?/, @changes);

  # or modified locally (because I'm debugging this script..)
  @changes = grep(!/^M/, @changes);

  if (@changes == 0) {
    # nothing changed; wait for 5 minutes (don't change status,
    # so we keep prior build success/fail info)
    diagnostic ("nothing changed");
    sleep($sleepTime);
    next;
  }

  # clear the status file
  unlink($statusFilename);
  status("updated from repository, and something has changed");

  mylog("output from cvs update", @changes);
  @changes = ();    # "free"


  # rebuild the system
  if (!logrun("make clean setup", "$ph/build.txt")) {
    status("build failed; waiting for repository to change");
    sleep($sleepTime);
    next;
  }

  # run the quick regression test
  logrun("./regrtest -contin && ./regrtest -release -contin", "$ph/regrtest.txt");

  # run the long regression test
  logrun("cd test; ./testsafec --run", "$ph/testsafec.txt");

  # done
  status("done doing stuff; waiting for repository to change");
}
