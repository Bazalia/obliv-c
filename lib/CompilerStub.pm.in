#
#
# Copyright (c) 2001 by
#  George C. Necula	necula@cs.berkeley.edu
#  Scott McPeak        smcpeak@cs.berkeley.edu
#  Wes Weimer          weimer@cs.berkeley.edu
#   
# All rights reserved.  Permission to use, copy, modify and distribute
# this software for research purposes only is hereby granted, 
# provided that the following conditions are met: 
# 1. Redistributions of source code must retain the above copyright notice, 
# this list of conditions and the following disclaimer. 
# 2. Redistributions in binary form must reproduce the above copyright notice, 
# this list of conditions and the following disclaimer in the documentation 
# and/or other materials provided with the distribution. 
# 3. The name of the authors may not be used to endorse or promote products 
# derived from  this software without specific prior written permission. 
#
# DISCLAIMER:
# THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR 
# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES 
# OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
# IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT, 
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS 
# OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
# ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF 
# THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#



# This module implements a compiler stub that parses the command line
# arguments of gcc and Microsoft Visual C (along with some arguments for the
# script itself) and gives hooks into preprocessing, compil;ation and linking.

package CompilerStub;
@ISA = ();

use strict;
use File::Basename;
use File::Copy;
use Data::Dumper;


# Pass to new a list of command arguments
sub new {
    my ($proto, @args) = @_;


    my $class = ref($proto) || $proto;

    my $ref =
    { CFILES => [],    # C input files
      SFILES => [],    # Assembly language files
      OFILES => [],    # Other input files
      IFILES => [],    # Already preprocessed files
      PPARGS => [],    # Preprocessor args
      CCARGS => [],    # Compiler args
      LINKARGS => [],  # Linker args
      NATIVECAML => 1, # this causes the native code boxer to be used
      RELEASELIB => 0, # if true, use the release runtime library (if any)
      IDASHI => 1,     # if true, pass "-I-" to gcc's preprocessor
      IDASHDOT => 1,   # if true, pass "-I." to gcc's preprocessor
      VERBOSE => 0,    # when true, print extra detail
      OPERATION => 'TOEXE', # This is the default for all compilers
    };
    my $self = bless $ref, $class;

    # Look for the --mode argument first. If not found it is GCC
    my $mode;
    {
        my @args1 = ();
        foreach my $arg (@args) {
            if($arg =~ m|--mode=(.+)$|) {
                $mode = $1;
            } else {
                push @args1, $arg;
            }
        }
        @args = @args1; # These are the argument after we extracted the --mode
    }
    if(! defined($mode)) {
        $mode = 'GNUCC'; # Default is GCC
    }
    if(defined $self->{MODENAME} && $self->{MODENAME} ne $mode) {
        die "Cannot re-specify the compiler";
    }
    {
        my $compiler;
        if($mode eq "MSVC") {
            unshift @CompilerStub::ISA, qw(MSVC);
            $compiler = MSVC->new($self);
        } elsif($mode eq "GNUCC") {
            unshift @CompilerStub::ISA, qw(GNUCC);
            $compiler = GNUCC->new($self);
        } elsif($mode eq "MSLINK") {
            unshift @CompilerStub::ISA, qw(MSLINK);
            $compiler = MSLINK->new($self);
        } elsif($mode eq "AR") {
            unshift @CompilerStub::ISA, qw(AR);
            $compiler = AR->new($self);
        } else {
            die "Don't know about compiler $mode\n";
        }
        # Now grab the fields from the compiler and put them inside self
        my $key;
        foreach $key (keys %{$compiler}) {
            $self->{$key} = $compiler->{$key};
        }
    }
    # Scan and process the arguments
    while($#args >= 0) {
        my $arg = $self->fetchEscapedArg(\@args);
        if(! defined($arg)) {
            last;
        }
#
#        my $arg = shift @args; # Grab the next one
        if(! $self->collectOneArgument($arg, \@args)) {
            print "Warning: Unknown argument $arg\n";
            push @{$self->{CCARGS}}, $arg;
        }
    }
#    print Dumper($self);
    return $self;
}

# Grab the next argument and escape it if necessary
sub fetchEscapedArg {
    my ($self, $pargs) = @_;
    my $arg = shift @{$pargs};
        # Drop the empty arguments
    if($arg =~ m|^\s*$|) { 
        if($#{$pargs} > 0) {
            return $self->fetchEscapedArg($pargs); 
        } else {
            return undef;
        }
    }
        # See if it contains spaces
    $arg =~ s|(\s)|\\$1|g;
    $arg =~ s|(\")|\\\"|g;
    return $arg;
}

# Collecting arguments. Take a look at one argument. If we understand it then
# we return 1. Otherwise we return 0. Might pop soem more arguments from pargs.
sub collectOneArgument {
    my($self, $arg, $pargs) = @_;
    my $res;
    # Maybe it is a compiler option or a source file
    if($self->compilerArgument($self->{OPTIONS}, $arg, $pargs)) { return 1; }

    if($arg eq "--help" || $arg eq "-help") {
        $self->printHelp(); exit 1;
    }
    if($arg eq "--verbose") {
        $self->{VERBOSE} = 1; return 1;
    }
    if($arg eq "--flatten_linker_scripts") {
        $self->{FLATTEN_LINKER_SCRIPTS} = 1; return 1;
    }
    if($arg =~ m|--keep=(.+)$|) {
        $self->{KEEPDIR} = $1;
        if(! -d $self->{KEEPDIR}) {
            die "Cannot find directory $self->{KEEPDIR}";
        }
        return 1;
    }
    return 0;
}



sub printHelp {
    my($self) = @_;
    $self->usage();
    print <<EOF;
Options:
  --mode=xxx   What tool to emulate:
                GNUCC   - GNU gcc
                MSVC    - MS VC cl compiler
                MSLINK  - MS VC link linker
                AR      - GNU ar
               This option must be the first one! If it is not found there
               then GNUCC mode is assumed.
  --help (or -help) Prints this help message
  --verbose    Prints a lot of information about what is being done
  --keep=xxx   Keep temporary files in the given directory
EOF
    $self->helpMessage();
}

# For printing the first line of the help message
sub usage {
    my ($self) = @_;
    print "<No usage is defined>";
}

# The rest of the help message
sub helpMessage {
    my ($self) = @_;
    print <<EOF;
Send bugs to necula\@cs.berkeley.edu.
EOF
}


# PREPROCESSING. Return the actual destination
sub preprocess {
    my ($self, $src, $dest, $ppargs) = @_;
    my $res;
    if($self->{VERBOSE}) { print "Preprocessing $src\n"; }
    if($self->{MODENAME} eq "MSVC") {
        $self->MSVC::msvc_preprocess($src, $dest, $ppargs);
    } else {
        my $cmd = $self->{CPP} . " " . 
            join(' ', @{$ppargs}) . " $src " . $self->{OUTCPP} . $dest;
        $res = $self->runShell($cmd);
        
    }
    return $dest;
}


# COMPILATION
sub compile {
    my ($self, $src, $dest, $ppargs, $ccargs) = @_;
    if($self->{VERBOSE}) { print "Compiling $src\n"; }
    $dest = $dest eq "" ? "" : $self->{OUTOBJ} . $dest;
    my $forcec = $self->{FORCECSOURCE};
    my $cmd = $self->{CC} . " " . join(' ', @{$ppargs}, @{$ccargs}) .  
        " $dest $forcec$src";
    return $self->runShell($cmd);
}

# Assemble the file
sub assemble {
    my ($self, $src, $dest, $ppargs, $ccargs) = @_;
    if($self->{VERBOSE}) { print "Assembling $src\n"; }
    $dest = $dest eq "" ? "" : $self->{OUTOBJ} . $dest;
    my $cmd = $self->{CC} . " " . join(' ', @{$ppargs}, @{$ccargs}) .  
        " $dest $src";
    return $self->runShell($cmd);
}

# Find the name of the preprocessed file
sub preprocessOutputFile {
    my($self, $src) = @_;
    my ($base, $dir, $ext) = fileparse($src, "\\.[^.]+");
    my $idir = $dir;
    if(defined $self->{KEEPDIR}) { $idir = $self->{KEEPDIR} . "/"; }
    return "$idir$base.i";
}

# Invoke the cpp and then the compile method.
sub preprocess_compile {
    my ($self, $src, $dest, $ppargs, $ccargs) = @_;
    my ($base, $dir, $ext) = fileparse($src, "\\.[^.]+");
    if($ext eq ".c" || $ext eq ".cpp") {
        my $out    = $self->preprocessOutputFile($src);
        $out = $self->preprocess($src, $out, $ppargs);
        $src = $out;
        $ext = ".i";
    }
    if($ext eq ".i") {
        $self->compile($src, $dest, $ppargs, $ccargs);
    }
}


# LINKING (with COMPILATION and PREPROCESSING)
sub link {
    my ($self, $psrcs, $dest, $ppargs, $ccargs, $ldargs) = @_;
    my @sources = ref($psrcs) ? @{$psrcs} : ($psrcs);
    $dest = $dest eq "" ? "" : $self->{OUTEXE} . $dest;
    # Pass the linkargs last because some libraries must be passed after
    # the sources
    my $cmd = $self->{LD} . " " . 
        join(' ', @{$ppargs}, @{$ccargs}, @sources, @{$ldargs}) .  
            " $dest";
    return $self->runShell($cmd);
}

# LINKING into a library (with COMPILATION and PREPROCESSING)
sub linktolib {
    my ($self, $psrcs, $dest, $ppargs, $ccargs, $ldargs) = @_;
    my @sources = ref($psrcs) ? @{$psrcs} : ($psrcs);
    $dest = $dest eq "" ? "" : $self->{OUTLIB} . $dest;
    # Pass the linkargs last because some libraries must be passed after
    # the sources
    my $cmd = $self->{LDLIB} . " $dest " . 
        join(' ', @{$ppargs}, @{$ccargs}, @sources, @{$ldargs});
    return $self->runShell($cmd);
}


# DO EVERYTHING
sub doit {
    my ($self) = @_;
    my $file;
    my $out;

    # Maybe we must preprocess only
    if($self->{OPERATION} eq "TOI") {
        # Then we do not do anything
        my $cmd = $self->{CPP} . " " . 
            join(' ', @{$self->{PPARGS}}, @{$self->{CCARGS}}, 
                      @{$self->{CFILES}}, @{$self->{SFILES}},
                      $self->{OUTARG});
        return $self->runShell($cmd);
    }
    if($self->{OPERATION} eq "UNKNOWN") {
        print "Warning: CompilerStub does not understand the operation\n";
        my @allfiles = (@{$self->{CFILES}}, @{$self->{SFILES}}, 
                        @{$self->{OFILES}});
        $self->link(\@allfiles, "", $self->{PPARGS}, 
                    $self->{CCARGS}, 
                    $self->{LINKARGS});
        return;
    }
    # Turn everything into OBJ files
    my @tolink = (@{$self->{OFILES}});

    foreach $file (@{$self->{IFILES}}, @{$self->{CFILES}}) {
        $out = $self->compileOutputFile($file);
        $self->preprocess_compile($file, $out, 
                                  $self->{PPARGS}, $self->{CCARGS});
        push @tolink, $out;
    }
    # Now do the assembly language file
    foreach $file (@{$self->{SFILES}}) {
        $out = $self->assembleOutputFile($file);
        $self->assemble($file, $out, $self->{PPARGS}, $self->{CCARGS});
        push @tolink, $out;
    }

    # See if we must stop after compilation
    if($self->{OPERATION} eq "TOOBJ") {
        return;
    }

    # See if we must create a library only
    if($self->{OPERATION} eq "TOLIB") {
        $out = $self->linkOutputFile();
        $self->linktolib(\@tolink,  $out, 
                         $self->{PPARGS}, $self->{CCARGS}, 
                         $self->{LINKARGS});
        return;
    }

    # Now link all of the files into an executable
    if($self->{OPERATION} eq "TOEXE") {
        $out = $self->linkOutputFile();
        $self->link(\@tolink,  $out, 
                    $self->{PPARGS}, $self->{CCARGS}, $self->{LINKARGS});
        return;
    }
    die "I don't understand OPERATION:$self->{OPERATION}\n";
}

sub classDebug {
    if(0) { print @_; }
}

sub compilerArgument {
    my($self, $options, $arg, $pargs) = @_;
    &classDebug("Classifying arg: $arg\n");
    my $idx = 0;
    for($idx=0; $idx < $#$options; $idx += 2) {
        my $key = ${$options}[$idx];
        my $action = ${$options}[$idx + 1];
        &classDebug("Try match with $key\n");
        if($arg =~ m|^$key|) {
          &classDebug(" match with $key\n");
          my $fullarg = $arg;
          my $onemore;
          if(defined $action->{'ONEMORE'}) {
              &classDebug("  expecting one more\n");
              # Maybe the next arg is attached
              my $realarg;
              ($realarg, $onemore) = ($arg =~ m|^($key)(.+)$|);
              if(! defined $onemore) {
                  # Grab the next argument
                  $onemore = $self->fetchEscapedArg($pargs);
                  $onemore = &quoteIfNecessary($onemore);
                  $fullarg .= " $onemore";
              } else {
                  $onemore = &quoteIfNecessary($onemore);
              }
              &classDebug(" onemore=$onemore\n");
          }
          # Now see what action we must perform
          my $argument_done = 1;
          if(defined $action->{'RUN'}) {
              &{$action->{'RUN'}}($self, $fullarg, $onemore, $pargs);
              $argument_done = 1;
          }
          if(defined $action->{'TYPE'}) {
              &classDebug("  type=$action->{TYPE}\n");
              if($action->{TYPE} eq "PREPROC") {
                  push @{$self->{PPARGS}}, $fullarg; return 1;
              }
              if($action->{TYPE} eq "CC") {
                  push @{$self->{CCARGS}}, $fullarg; return 1;
              }
              if($action->{TYPE} eq "LINKCC") {
                  push @{$self->{CCARGS}}, $fullarg; 
                  push @{$self->{LINKARGS}}, $fullarg; return 1;
              }
              if($action->{TYPE} eq "LINK") {
                  push @{$self->{LINKARGS}}, $fullarg; return 1;
              }
              if($action->{TYPE} eq "CSOURCE") {
                  push @{$self->{CFILES}}, $fullarg; return 1;
              }
              if($action->{TYPE} eq "ASMSOURCE") {
                  push @{$self->{SFILES}}, $fullarg; return 1;
              }
              if($action->{TYPE} eq "OSOURCE") {
                  push @{$self->{OFILES}}, $fullarg; return 1;
              }
              if($action->{TYPE} eq "ISOURCE") {
                  push @{$self->{IFILES}}, $fullarg; return 1;
              }
              if($action->{TYPE} eq 'OUT') {
                  if(defined($self->{OUTARG})) {
                      print "Warning: output file is multiply defined: $self->{OUTARG} and $fullarg\n";
                  }
                  $self->{OUTARG} = $fullarg; return 1;
              }
              print "  Do not understand TYPE\n"; return 1;
          }
          if($argument_done) { return 1; }
          print "Don't know what to do with option $arg\n"; 
          return 0;
      }
   }
   return 0;
}


sub runShell {
    my ($self, $cmd) = @_;

    # sm: I want this printed to stderr instead of stdout
    # because the rest of 'make' output goes there and this
    # way I can capture to a coherent file
    # sm: removed conditional on verbose since there's already
    # so much noise in the output, and this is the *one* piece
    # of information I *always* end up digging around for..
    if(1 || $self->{VERBOSE}) { print STDERR "$cmd\n"; }

    # weimer: let's have a sanity check
    my $code = system($cmd);
    if ($code != 0) {
        # sm: now that we always print, don't echo the command again,
        # since that makes the output more confusing
	#die "Possible error with $cmd!\n";
	$code >>= 8;    # extract exit code portion

        exit $code;
    } 
    return $code;
}

sub quoteIfNecessary {
    my($arg) = @_;
    # If it contains spaces or "" then it must be quoted
    if($arg =~ m|\s| || $arg =~ m|\"|) {
        return "\'$arg\'";
    } else {
        return $arg;
    }
}



###########################################################################
####
#### MS CL specific code
####
package MSVC;

use strict;
use File::Basename;

sub new {
    my ($proto, $stub) = @_;
    my $class = ref($proto) || $proto;
    # Create $self

    my $self = 
    { NAME => 'Microsoft cl compiler',
      MODENAME => 'MSVC',
      CC => 'cl /nologo /D_MSVC /c',
      CPP => 'cl /nologo /D_MSVC /P',
      LD => 'cl /nologo /D_MSVC',
      DEFARG  => "/D",
      INCARG  => "/I",
      DEBUGARG => "/Zi /MLd /DEBUG",
      OPTIMARG => "/Ox /G6 ",
      OBJEXT => "obj",
      LIBEXT => "lib",   # Library extension (without the .)
      EXEEXT => ".exe",  # Executable extension (with the .)
      OUTOBJ => "/Fo",
      OUTEXE => "/Fe",
      FORCECSOURCE => "/Tc",
      LINEPATTERN => "^#line\\s+(\\d+)\\s+\"(.+)\"",

      OPTIONS => 
# Describe the compiler options as a list of patterns and associated actions. 
# The patterns are matched in order against the _begining_ of the argument.
#
# If the action contains ONEMORE => 1 then the argument is expected to be
# parameterized by a following word. The word can be attached immediately to
# the end of the argument or in a separate word. 
#
# If the action contains TYPE => "..." then the argument is put into one of
# several lists, as follows: "PREPROC" in ppargs, "CC" in ccargs, "LINK" in
# linkargs, "LINKCC" both in ccargs and linkargs, "CSOURCE" in cfiles, 
# "ASMSOURCE" in sfiles, 
# "OSOURCE" in ofiles, "ISOURCE" in ifiles, "OUT" in outarg. 
#
# If the TYPE is not defined but the RUN => sub { ... } is defined then the
# given subroutine is invoked with the self, the argument and the (possibly
# empty) additional word and a pointer to the list of remaining arguments
#
          ["[^/].*\\.(c|cpp|cc)\$" => { TYPE => 'CSOURCE' },
           "[^/].*\\.(asm)\$" => { TYPE => 'ASMSOURCE' },
           "[^/].*\\.i\$" => { TYPE => 'ISOURCE' },
           "[^/-]" => { TYPE => "OSOURCE" },
           "/O" => { TYPE => "CC" },
           "/G" => { TYPE => "CC" },
           "/[DI]" => { TYPE => "PREPROC"},
           "/EH" => { TYPE => "CC" },
           "/G"  => { TYPE => "CC" },
           "/F[aA]"  => { TYPE => 'CC' },
           "/Fo"     => { TYPE => 'OUT' },
           "/Fe"   => { TYPE => 'OUT',
                        RUN => sub { $stub->{OPERATION} = "TOEXE" }},
           "/F[dprR]" => { TYPE => "CC" },
           "/[CXu]" => { TYPE => "PREPROC" },
           "/U" => { ONEMORE => 1, TYPE => "PREPROC" },
           "/(E|EP|P)" => { RUN => sub { push @{$stub->{PPARGS}}, $_[1]; 
                                         $stub->{OPERATION} = "PREPROC"; }},
           "/c" => { RUN => sub { $stub->{OPERATION} = "TOOBJ"; }},
           "/(Q|Z|J|nologo|TC|TP|w|W|Yd|Zm)" => { TYPE => "CC" },
           "/v(d|m)" => { TYPE => "CC" },
           "/F" => { TYPE => "CC" },
           "/M"   => { TYPE => 'LINKCC' },
           "/link" => { RUN => sub { push @{$stub->{LINKARGS}}, "/link", 
                                          @{$_[3]};
                                     @{$_[3]} = (); } },
           "/"  => { RUN => 
                         sub { print "Unimplemented MSVC argument $_[1]\n";}},
           ],
      };
    bless $self, $class;
    return $self;
}


sub msvc_preprocess {
    my($self, $src, $dest, $ppargs) = @_;
    my $res;
    my ($sbase, $sdir, $sext) = 
        fileparse($src, 
                  "(\\.c)|(\\.cc)|(\\.cpp)|(\\.i)");
    my $cmd = "cl /nologo /P /D_MSVC " . join(' ', @{$ppargs});
    $res = $self->runShell("$cmd $src");
    # MSVC cannot be told where to put the output. But we know that it
    # puts it in the current directory
    my $msvcout = "./$sbase.i";
    my @st1 = stat $msvcout;
    my @st2 = stat $dest;
    while($#st1 >= 0) {
        if(shift @st1 != shift @st2) {
#                print "$msvcout is NOT the same as $afterpp\n";
            if($self->{VERBOSE}) {
                print "Copying $msvcout to $dest\n";
            }
            unlink $dest;
            &File::Copy::copy($msvcout, $dest);
            unlink $msvcout;
            return $res;
        }
    }
    return $res;
}

sub forceIncludeArg { 
    my($self, $what) = @_;
    return "/FI$what";
}


    # MSVC does not understand the extension .i, so we tell it it is a C file
sub fixupCsources {
    my (@csources) = @_;
    my @mod_csources = ();
    my $src;
    foreach $src (@csources) {
        my ($sbase, $sdir, $sext) = fileparse($src, 
                                              "\\.[^.]+");
        if($sext eq ".i") {
            push @mod_csources, "/Tc";
        }
        push @mod_csources, $src;
    }
    return @mod_csources;
}


# Emit a line # directive
sub lineDirective {
    my ($self, $fileName, $lineno) = @_;
    return "#line $lineno \"$fileName\"\n";
}

# The name of the output file
sub compileOutputFile {
    my($self, $src) = @_;
    if($self->{OUTARG} =~ m|/Fo(.+)|) {
        return $1;
    }
    my ($base, $dir, $ext) = 
        fileparse($src, 
                  "(\\.c)|(\\.cc)|(\\.cpp)|(\\.i)|(\\.asm)");
    if(! defined($ext) || $ext eq "") { # Not a C source
        die "objectOutputFile: not a C source file\n";
    }
    return "$base.obj"; # In the current directory
}

sub assembleOutputFile {
    my($self, $src) = @_;
    return $self->compileOutputFile($src);
}

sub linkOutputFile {
    my($self, $src) = @_;
    if($self->{OUTARG} =~ m|/Fe(.+)|) {
        return $1;
    }
    return "a.exe";
}

sub setVersion {
    my($self) = @_;
    my $cversion = "";
    open(VER, "cl 2>&1|") || die "Cannot start Microsoft CL\n";
    while(<VER>) {
        if($_ =~ m|Compiler Version (\S+) |) {
            $cversion = "cl_$1";
            close(VER);
            $self->{VERSION} = $cversion;
            return;
        }
    }
    die "Cannot find Microsoft CL version\n";
}

########################################################################
##
##  MS LINK specific code
##
###
package MSLINK;

use strict;

use File::Basename;

sub new {
    my ($proto, $stub) = @_;
    my $class = ref($proto) || $proto;
    # Create $self

    my $self = 
    { NAME => 'Microsoft linker',
      MODENAME => 'mslink',
      CC => 'no_compiler_in_mslink_mode',
      CPP => 'no_compiler_in_mslink_mode',
      LD => 'cl /nologo',
      DEFARG  => " ??DEFARG",
      INCARG  => " ??INCARG",
      DEBUGARG => "/DEBUG",
      OPTIMARG => "",
      OBJEXT => "obj",
      LIBEXT => "lib",   # Library extension (without the .)
      EXEEXT => ".exe",  # Executable extension (with the .)
      OUTOBJ => " ??OUTOBJ",
      OUTEXE => "/OUT:",
      LINEPATTERN => "", 

      OPTIONS => 
          ["[^/-]" => { TYPE => 'OSOURCE' },
           "/OUT:" => { TYPE => 'OUT' },
           "/"  => { TYPE => 'LINK' },
           ],
      };
    bless $self, $class;
    return $self;
}


sub forceIncludeArg {  # Same as for CL
    my($self, $what) = @_;
    return "/FI$what";
}



sub linkOutputFile {
    my($self, $src) = @_;
    if($self->{OUTARG} =~ m|/OUT:(.+)|) {
        return $1;
    }
    die "I do not know what is the link output file\n";
}

########################################################################
##
##  GNU ar specific code
##
###
package AR;

use strict;

use File::Basename;

sub new {
    my ($proto, $stub) = @_;
    my $class = ref($proto) || $proto;
    # Create $self

    my $self = 
    { NAME => 'Archiver',
      MODENAME => 'ar',
      CC => 'no_compiler_in_ar_mode',
      CPP => 'no_compiler_in_ar_mode',
      LDLIB => 'ar crv',
      DEFARG  => " ??DEFARG",
      INCARG  => " ??INCARG",
      DEBUGARG => "??DEBUGARG",
      OPTIMARG => "",
      OBJEXT => "o",
      LIBEXT => "a",   # Library extension (without the .)
      EXEEXT => "",  # Executable extension (with the .)
      OUTOBJ => " ??OUTOBJ",
      OUTLIB => "",  # But better be first
      LINEPATTERN => "", 

      OPTIONS => 
          ["." => { RUN => \&arArguments } ]

      };
    bless $self, $class;
    return $self;
}

# We handle arguments in a special way for AR
sub arArguments {
    my ($self, $arg, $onemore, $pargs) = @_;
    # If the first argument starts with -- pass it on
    if($arg =~ m|^--|) {
        return 0;
    }
    # We got here for the first non -- argument. 
    # Will handle all arguments at once
#    print "AR called with $arg ", join(' ', @{$pargs}), "\n";
    if($arg !~ m|c| || $arg !~ m|r| || $#{$pargs} < 0) {
        die "AR implements only the cr operation";
    }
    # Get the name of the library
    $self->{OUTARG} = shift @{$pargs};
    unlink $self->{OUTARG};
    # The rest must be object files
    push @{$self->{OFILES}}, @{$pargs};
    $self->{OPERATION} = 'TOLIB';
    @{$pargs} = ();
    return 1;
}

sub linkOutputFile {
    my($self, $src) = @_;
    if(defined $self->{OUTARG}) {
        return $self->{OUTARG};
    }
    die "I do not know what is the link output file\n";
}



#########################################################################
##
## GNUCC specific code
##
package GNUCC;

use strict;

use File::Basename;

my $gcc = "@CC@";

sub new {
    my ($proto, $stub) = @_;
    my $class = ref($proto) || $proto;
    # Create $self

    my $self = 
    { NAME => 'GNU CC',
      MODENAME => 'GNUCC',  # do not change this since it is used in code
      # sm: added -O since it's needed for inlines to be merged instead of causing link errors
      # sm: removed -O to ease debugging; will address "inline extern" elsewhere
      CC => "$gcc -D_GNUCC -c",
      LD => "$gcc -D_GNUCC ",
      CPP => "$gcc -D_GNUCC -E ",
      DEFARG  => "-D",
      INCARG => "-I",
      DEBUGARG => "-g",
      OPTIMARG => "-O4",
      CPROFILEARG => "-pg ",
      LPROFILEARG => "-pg ",
      OBJEXT => "o",
      LIBEXT => "a",
      EXEEXT => "",
      OUTOBJ => "-o ",
      OUTEXE => "-o ",
      OUTCPP => "-o ",
      LINEPATTERN => "^#\\s+(\\d+)\\s+\"(.+)\"",
      
      OPTIONS => 
          [ "[^-].*\\.(c|cpp|cc)\$" => { TYPE => 'CSOURCE' },
            "[^-].*\\.(s|S)\$" => { TYPE => 'ASMSOURCE' },
            "[^-].*\\.i\$" => { TYPE => 'ISOURCE' },
            # .o files can be linker scripts
            "[^-]" => { RUN => sub { &GNUCC::parseLinkerScript(@_); }},
            "-E"   => { RUN => sub { $stub->{OPERATION} = "TOI"; }},
            "-[DI]" => { ONEMORE => 1, TYPE => "PREPROC" },
            "-include" => { ONEMORE => 1, TYPE => "PREPROC" },  # sm
            "-ansi" => { TYPE => "PREPROC" },
            "-c" => { RUN => sub { $stub->{OPERATION} = "TOOBJ"; }},
            "-x" => { ONEMORE => 1, TYPE => "CC" },
             # GCC defines some more macros if the optimization is On so pass
             # the -O2 to the preprocessor and the compiler
            "-O" => { TYPE => "PREPROC" },
            "-S" => { RUN => sub { $stub->{OPERATION} = "TOOBJ";
                                   push @{$stub->{CCARGS}}, $_[1]; }},
            "-o" => { ONEMORE => 1, TYPE => 'OUT' },
            "-p" => { TYPE => 'LINKCC' },
            "-W" => { TYPE => 'CC' },
            "-g" => { RUN => sub { push @{$stub->{CCARGS}}, $_[1];
                                   push @{$stub->{LINKARGS}}, $_[1]; }},
            "-l" => { TYPE => 'LINK' },
            "-L" => { TYPE => 'LINK' },
            "-f" => { TYPE => 'LINKCC' },
            "-r" => { TYPE => 'LINK' },
            "-m" => { TYPE => 'LINKCC' },
            "-Xlinker" => { ONEMORE => 1, TYPE => 'LINK' },
            "-nostdlib" => { TYPE => 'LINK' },
            "-traditional" => { TYPE => 'PREPROC' },
            "-std" => { TYPE => 'CC' },
            ],
                                  
      };
    bless $self, $class;
    return $self;
}

my $linker_script_debug = 0;

sub parseLinkerScript {
  my ($filename) = @_;
  my @return_list = ();
  if ($filename=~/\.o$/) {
    warn "parsing OBJECT FILE:$filename ****************\n" if $linker_script_debug;
    open OBJFILE, $filename or die $!;
    my $line = <OBJFILE>;
    if ($line=~/^INPUT/) {
      warn "\tYES an INPUT file.\n" if $linker_script_debug;
      # Stick each line from the file onto our list.
      while(defined ($line = <OBJFILE>)) {
        chomp $line;
        my ($listed_filename) = ($line=~/^(\S+)/);
        if (defined $listed_filename && (length $listed_filename > 0)) {
          warn "FILE LINE:$line:\n" if $linker_script_debug;
          push @return_list, $listed_filename;
        } else {
          warn "EMPTY LINE:$line:\n" if $linker_script_debug;
        }
      }
      warn "Contained the following files:", join (":", @return_list), ":\n" if $linker_script_debug;
    } else {
      warn "\tNOT an INPUT file.\n" if $linker_script_debug;
    }
    close OBJFILE or die $!;
  }
  return @return_list;
}

$linker_script_debug = 0;
sub parseLinkerScript {
    my($self, $filename, $onemore, $pargs) = @_;
    
    if(! defined($self->{FLATTEN_LINKER_SCRIPTS}) ||
       $filename !~ /\.o$/) {
      NotAScript:
        warn "$filename is not a linker script\n" if $linker_script_debug;
        push @{$self->{OFILES}}, $filename; 
        return 1;
    }
    warn "parsing OBJECT FILE:$filename ****************\n" if
        $linker_script_debug;
    my $objfile; # Must be local because it is recursive
    open $objfile, $filename or die $!;
    my $line = <$objfile>;
    if ($line !~ /^INPUT/) {
        close $objfile or die $!;
        goto NotAScript;
    }
    warn "\tYES an INPUT file.\n" if $linker_script_debug;
    # Process recursively each line from the file
    while(defined ($line = <$objfile>)) {
        chomp $line;
        my @filenames = split(/\s+/, $line);
        foreach my $listed_filename (@filenames) {
            warn "LISTED FILE:$listed_filename:\n" if $linker_script_debug;
            # Process it recursively because it could be a script itself
            if($listed_filename eq ")") { last ; }
            $self->parseLinkerScript($listed_filename, $onemore, $pargs);
        } 
        warn "EMPTY LINE:$line:\n" if $linker_script_debug;
    }
    close $objfile or die $!;
}

sub forceIncludeArg { 
    my($self, $what) = @_;
    return "-include $what";
}


# Emit a line # directive
sub lineDirective {
    my ($self, $fileName, $lineno) = @_;
    return "# $lineno \"$fileName\"\n";
}

# The name of the output file
sub compileOutputFile {
    my($self, $src) = @_;
    if($self->{OUTARG} =~ m|^-o\s*(\S.+)$| && $self->{OPERATION} eq 'TOOBJ') {
        return $1;
    }
    my ($base, $dir, $ext) = 
        fileparse($src, 
                  "(\\.c)|(\\.cc)|(\\.cpp)|(\\.i)|(\\.[s|S])");
    if(! defined($ext) || $ext eq "") { # Not a C source
        die "objectOutputFile: not a C source file: $src\n";
    }
    return "$base.o"; # In the current directory
}

sub assembleOutputFile {
    my($self, $src) = @_;
    return $self->compileOutputFile($src);
}

sub linkOutputFile {
    my($self, $src) = @_;
    if($self->{OUTARG} =~ m|-o\s*(\S.+)|) {
        return $1;
    }
    return "a.out";
}

sub setVersion {
    my($self) = @_;
    my $cversion = "";
    open(VER, "$gcc -dumpversion " 
         . join(' ', @{$self->{PPARGS}}) ." |") 
        || die "Cannot start GNUCC";
    while(<VER>) {
        if($_ =~ m|^(\d+\S+)| || $_ =~ m|^(egcs-\d+\S+)|) {
            $cversion = "gcc_$1";
            close(VER) || die "Cannot start GNUCC\n";
            $self->{VERSION} = $cversion;
            return;
        }
    }
    die "Cannot find GNUCC version\n";
}

1;


__END__



