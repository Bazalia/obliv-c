/* Generated by Frontc */


#pragma combiner("./libpbm1.i", "-g -O -I/home/scott/wrk/safec/cil/lib ")

#pragma boxalloc("malloc", nozero, sizein(0))

#pragma boxalloc("alloca", nozero, sizein(0))

#pragma boxalloc("calloc", zero, sizemul(0, 1))

#pragma boxprintf("printf", 0)

#pragma boxprintf("fprintf", 1)

#pragma boxprintf("sprintf", 1)

#pragma boxprintf("snprintf", 2)

#pragma boxpoly("memcpy")

#pragma boxexported("main")
typedef unsigned int size_t ; /*typedef*/

typedef long int wchar_t ; /*typedef*/

typedef struct  {
  int quot ;
  int rem ;
} div_t ; /*typedef*/

typedef struct  {
  long int quot ;
  long int rem ;
} ldiv_t ; /*typedef*/

extern size_t __ctype_get_mb_cur_max(void  ) ; /*decdef*/
extern double atof(const char *  __nptr ) ; /*decdef*/
extern int atoi(const char *  __nptr ) ; /*decdef*/
extern long int atol(const char *  __nptr ) ; /*decdef*/
extern long long int atoll(const char *  __nptr ) ; /*decdef*/
extern double strtod(const char *  __nptr , char *  *  __endptr ) ; /*decdef*/
extern long int strtol(const char *  __nptr , char *  *  __endptr , int __base )
  ; /*decdef*/
extern unsigned long int strtoul(const char *  __nptr , char *  *  __endptr ,
  int __base ) ; /*decdef*/
extern long long int strtoq(const char *  __nptr , char *  *  __endptr ,
  int __base ) ; /*decdef*/
extern unsigned long long int strtouq(const char *  __nptr , char *  *  __endptr
  , int __base ) ; /*decdef*/
extern long long int strtoll(const char *  __nptr , char *  *  __endptr ,
  int __base ) ; /*decdef*/
extern unsigned long long int strtoull(const char *  __nptr , char *  * 
  __endptr , int __base ) ; /*decdef*/
extern double __strtod_internal(const char *  __nptr , char *  *  __endptr ,
  int __group ) ; /*decdef*/
extern float __strtof_internal(const char *  __nptr , char *  *  __endptr ,
  int __group ) ; /*decdef*/
extern long double __strtold_internal(const char *  __nptr , char *  *  __endptr
  , int __group ) ; /*decdef*/
extern long int __strtol_internal(const char *  __nptr , char *  *  __endptr ,
  int __base , int __group ) ; /*decdef*/
extern unsigned long int __strtoul_internal(const char *  __nptr , char *  * 
  __endptr , int __base , int __group ) ; /*decdef*/
extern long long int __strtoll_internal(const char *  __nptr , char *  * 
  __endptr , int __base , int __group ) ; /*decdef*/
extern unsigned long long int __strtoull_internal(const char *  __nptr , char * 
  *  __endptr , int __base , int __group ) ; /*decdef*/
extern char *  l64a(long int __n ) ; /*decdef*/
extern long int a64l(const char *  __s ) ; /*decdef*/

typedef unsigned char __u_char ; /*typedef*/

typedef unsigned short __u_short ; /*typedef*/

typedef unsigned int __u_int ; /*typedef*/

typedef unsigned long __u_long ; /*typedef*/

typedef unsigned long long int __u_quad_t ; /*typedef*/

typedef long long int __quad_t ; /*typedef*/

typedef signed char __int8_t ; /*typedef*/

typedef unsigned char __uint8_t ; /*typedef*/

typedef signed short int __int16_t ; /*typedef*/

typedef unsigned short int __uint16_t ; /*typedef*/

typedef signed int __int32_t ; /*typedef*/

typedef unsigned int __uint32_t ; /*typedef*/

typedef signed long long int __int64_t ; /*typedef*/

typedef unsigned long long int __uint64_t ; /*typedef*/

typedef __quad_t *  __qaddr_t ; /*typedef*/

typedef __u_quad_t __dev_t ; /*typedef*/

typedef __u_int __uid_t ; /*typedef*/

typedef __u_int __gid_t ; /*typedef*/

typedef __u_long __ino_t ; /*typedef*/

typedef __u_int __mode_t ; /*typedef*/

typedef __u_int __nlink_t ; /*typedef*/

typedef long int __off_t ; /*typedef*/

typedef __quad_t __loff_t ; /*typedef*/

typedef int __pid_t ; /*typedef*/

typedef int __ssize_t ; /*typedef*/

typedef long int __rlim_t ; /*typedef*/

typedef __quad_t __rlim64_t ; /*typedef*/

typedef __u_int __id_t ; /*typedef*/

typedef struct  {
  int __val[2] ;
} __fsid_t ; /*typedef*/

typedef int __daddr_t ; /*typedef*/

typedef char *  __caddr_t ; /*typedef*/

typedef long int __time_t ; /*typedef*/

typedef long int __swblk_t ; /*typedef*/

typedef long int __clock_t ; /*typedef*/

typedef unsigned long int __fd_mask ; /*typedef*/

typedef struct  {
  __fd_mask __fds_bits[1024 / (8 * sizeof(__fd_mask ))] ;
} __fd_set ; /*typedef*/

typedef int __key_t ; /*typedef*/

typedef unsigned short int __ipc_pid_t ; /*typedef*/

typedef long int __blkcnt_t ; /*typedef*/

typedef __quad_t __blkcnt64_t ; /*typedef*/

typedef __u_long __fsblkcnt_t ; /*typedef*/

typedef __u_quad_t __fsblkcnt64_t ; /*typedef*/

typedef __u_long __fsfilcnt_t ; /*typedef*/

typedef __u_quad_t __fsfilcnt64_t ; /*typedef*/

typedef __u_long __ino64_t ; /*typedef*/

typedef __loff_t __off64_t ; /*typedef*/

typedef int __t_scalar_t ; /*typedef*/

typedef unsigned int __t_uscalar_t ; /*typedef*/

typedef int __intptr_t ; /*typedef*/

typedef __u_char u_char ; /*typedef*/

typedef __u_short u_short ; /*typedef*/

typedef __u_int u_int ; /*typedef*/

typedef __u_long u_long ; /*typedef*/

typedef __quad_t quad_t ; /*typedef*/

typedef __u_quad_t u_quad_t ; /*typedef*/

typedef __fsid_t fsid_t ; /*typedef*/

typedef __loff_t loff_t ; /*typedef*/

typedef __ino_t ino_t ; /*typedef*/

typedef __dev_t dev_t ; /*typedef*/

typedef __gid_t gid_t ; /*typedef*/

typedef __mode_t mode_t ; /*typedef*/

typedef __nlink_t nlink_t ; /*typedef*/

typedef __uid_t uid_t ; /*typedef*/

typedef __off_t off_t ; /*typedef*/

typedef __pid_t pid_t ; /*typedef*/

typedef __id_t id_t ; /*typedef*/

typedef __ssize_t ssize_t ; /*typedef*/

typedef __daddr_t daddr_t ; /*typedef*/

typedef __caddr_t caddr_t ; /*typedef*/

typedef __key_t key_t ; /*typedef*/

typedef __time_t time_t ; /*typedef*/

typedef unsigned long int ulong ; /*typedef*/

typedef unsigned short int ushort ; /*typedef*/

typedef unsigned int uint ; /*typedef*/

typedef int int8_t __attribute__((__mode__(__QI__))) ; /*typedef*/

typedef int int16_t __attribute__((__mode__(__HI__))) ; /*typedef*/

typedef int int32_t __attribute__((__mode__(__SI__))) ; /*typedef*/

typedef int int64_t __attribute__((__mode__(__DI__))) ; /*typedef*/

typedef unsigned int u_int8_t __attribute__((__mode__(__QI__))) ; /*typedef*/

typedef unsigned int u_int16_t __attribute__((__mode__(__HI__))) ; /*typedef*/

typedef unsigned int u_int32_t __attribute__((__mode__(__SI__))) ; /*typedef*/

typedef unsigned int u_int64_t __attribute__((__mode__(__DI__))) ; /*typedef*/

typedef int register_t __attribute__((__mode__(__word__))) ; /*typedef*/

typedef int __sig_atomic_t ; /*typedef*/

typedef struct  {
  unsigned long int __val[1024 / (8 * sizeof(unsigned long int ))] ;
} __sigset_t ; /*typedef*/

struct timespec {
  long int tv_sec ;
  long int tv_nsec ;
} ; /*onlytypedef*/

struct timeval ; /*onlytypedef*/

typedef __fd_mask fd_mask ; /*typedef*/

typedef __fd_set fd_set ; /*typedef*/

extern int __select(int __nfds , __fd_set *  __readfds , __fd_set *  __writefds
  , __fd_set *  __exceptfds , struct timeval *  __timeout ) ; /*decdef*/
extern int select(int __nfds , __fd_set *  __readfds , __fd_set *  __writefds ,
  __fd_set *  __exceptfds , struct timeval *  __timeout ) ; /*decdef*/

typedef __blkcnt_t blkcnt_t ; /*typedef*/

typedef __fsblkcnt_t fsblkcnt_t ; /*typedef*/

typedef __fsfilcnt_t fsfilcnt_t ; /*typedef*/

extern int32_t random(void  ) ; /*decdef*/
extern void srandom(unsigned int __seed ) ; /*decdef*/
extern void *  initstate(unsigned int __seed , void *  __statebuf , size_t
  __statelen ) ; /*decdef*/
extern void *  setstate(void *  __statebuf ) ; /*decdef*/

struct random_data {
  int32_t *  fptr ;
  int32_t *  rptr ;
  int32_t *  state ;
  int rand_type ;
  int rand_deg ;
  int rand_sep ;
  int32_t *  end_ptr ;
} ; /*onlytypedef*/

extern int random_r(struct random_data *  __buf , int32_t *  __result )
  ; /*decdef*/
extern int srandom_r(unsigned int __seed , struct random_data *  __buf )
  ; /*decdef*/
extern int initstate_r(unsigned int __seed , void *  __statebuf , size_t
  __statelen , struct random_data *  __buf ) ; /*decdef*/
extern int setstate_r(void *  __statebuf , struct random_data *  __buf )
  ; /*decdef*/
extern int rand(void  ) ; /*decdef*/
extern void srand(unsigned int __seed ) ; /*decdef*/
extern int rand_r(unsigned int *  __seed ) ; /*decdef*/
extern double drand48(void  ) ; /*decdef*/
extern double erand48(unsigned short int __xsubi[3] ) ; /*decdef*/
extern long int lrand48(void  ) ; /*decdef*/
extern long int nrand48(unsigned short int __xsubi[3] ) ; /*decdef*/
extern long int mrand48(void  ) ; /*decdef*/
extern long int jrand48(unsigned short int __xsubi[3] ) ; /*decdef*/
extern void srand48(long int __seedval ) ; /*decdef*/
extern unsigned short int *  seed48(unsigned short int __seed16v[3] )
  ; /*decdef*/
extern void lcong48(unsigned short int __param[7] ) ; /*decdef*/

struct drand48_data {
  unsigned short int x[3] ;
  unsigned short int a[3] ;
  unsigned short int c ;
  unsigned short int old_x[3] ;
  int init ;
} ; /*onlytypedef*/

extern int drand48_r(struct drand48_data *  __buffer , double *  __result )
  ; /*decdef*/
extern int erand48_r(unsigned short int __xsubi[3] , struct drand48_data * 
  __buffer , double *  __result ) ; /*decdef*/
extern int lrand48_r(struct drand48_data *  __buffer , long int *  __result )
  ; /*decdef*/
extern int nrand48_r(unsigned short int __xsubi[3] , struct drand48_data * 
  __buffer , long int *  __result ) ; /*decdef*/
extern int mrand48_r(struct drand48_data *  __buffer , long int *  __result )
  ; /*decdef*/
extern int jrand48_r(unsigned short int __xsubi[3] , struct drand48_data * 
  __buffer , long int *  __result ) ; /*decdef*/
extern int srand48_r(long int __seedval , struct drand48_data *  __buffer )
  ; /*decdef*/
extern int seed48_r(unsigned short int __seed16v[3] , struct drand48_data * 
  __buffer ) ; /*decdef*/
extern int lcong48_r(unsigned short int __param[7] , struct drand48_data * 
  __buffer ) ; /*decdef*/
extern void *  malloc(size_t __size ) ; /*decdef*/
extern void *  calloc(size_t __nmemb , size_t __size ) ; /*decdef*/
extern void *  realloc(void *  __ptr , size_t __size ) ; /*decdef*/
extern void free(void *  __ptr ) ; /*decdef*/
extern void cfree(void *  __ptr ) ; /*decdef*/
extern void *  alloca(size_t __size ) ; /*decdef*/
extern void *  valloc(size_t __size ) ; /*decdef*/
extern void abort(void  ) __attribute__((__noreturn__)) ; /*decdef*/
extern int atexit(void ( *  __func )(void  ) ) ; /*decdef*/
extern int __on_exit(void ( *  __func )(int __status , void *  __arg ) , void * 
  __arg ) ; /*decdef*/
extern int on_exit(void ( *  __func )(int __status , void *  __arg ) , void * 
  __arg ) ; /*decdef*/
extern void exit(int __status ) __attribute__((__noreturn__)) ; /*decdef*/
extern char *  getenv(const char *  __name ) ; /*decdef*/
extern char *  __secure_getenv(const char *  __name ) ; /*decdef*/
extern int putenv(const char *  __string ) ; /*decdef*/
extern int setenv(const char *  __name , const char *  __value , int __replace )
  ; /*decdef*/
extern void unsetenv(const char *  __name ) ; /*decdef*/
extern int clearenv(void  ) ; /*decdef*/
extern char *  mktemp(char *  __template ) ; /*decdef*/
extern int mkstemp(char *  __template ) ; /*decdef*/
extern int system(const char *  __command ) ; /*decdef*/
extern char *  realpath(const char *  __name , char *  __resolved ) ; /*decdef*/

typedef int ( *  __compar_fn_t )(const void *  , const void *  ) ; /*typedef*/

extern void *  bsearch(const void *  __key , const void *  __base , size_t
  __nmemb , size_t __size , __compar_fn_t __compar ) ; /*decdef*/
extern void qsort(void *  __base , size_t __nmemb , size_t __size ,
  __compar_fn_t __compar ) ; /*decdef*/
extern int abs(int __x ) __attribute__((const)) ; /*decdef*/
extern long int labs(long int __x ) __attribute__((const)) ; /*decdef*/
extern div_t div(int __numer , int __denom ) __attribute__((const)) ; /*decdef*/
extern ldiv_t ldiv(long int __numer , long int __denom ) __attribute__((const))
  ; /*decdef*/
extern char *  ecvt(double __value , int __ndigit , int *  __decpt , int * 
  __sign ) ; /*decdef*/
extern char *  fcvt(double __value , int __ndigit , int *  __decpt , int * 
  __sign ) ; /*decdef*/
extern char *  gcvt(double __value , int __ndigit , char *  __buf ) ; /*decdef*/
extern char *  qecvt(long double __value , int __ndigit , int *  __decpt ,
  int *  __sign ) ; /*decdef*/
extern char *  qfcvt(long double __value , int __ndigit , int *  __decpt ,
  int *  __sign ) ; /*decdef*/
extern char *  qgcvt(long double __value , int __ndigit , char *  __buf )
  ; /*decdef*/
extern int ecvt_r(double __value , int __ndigit , int *  __decpt , int *  __sign
  , char *  __buf , size_t __len ) ; /*decdef*/
extern int fcvt_r(double __value , int __ndigit , int *  __decpt , int *  __sign
  , char *  __buf , size_t __len ) ; /*decdef*/
extern int qecvt_r(long double __value , int __ndigit , int *  __decpt , int * 
  __sign , char *  __buf , size_t __len ) ; /*decdef*/
extern int qfcvt_r(long double __value , int __ndigit , int *  __decpt , int * 
  __sign , char *  __buf , size_t __len ) ; /*decdef*/
extern int mblen(const char *  __s , size_t __n ) ; /*decdef*/
extern int mbtowc(wchar_t *  __pwc , const char *  __s , size_t __n )
  ; /*decdef*/
extern int wctomb(char *  __s , wchar_t __wchar ) ; /*decdef*/
extern size_t mbstowcs(wchar_t *  __pwcs , const char *  __s , size_t __n )
  ; /*decdef*/
extern size_t wcstombs(char *  __s , const wchar_t *  __pwcs , size_t __n )
  ; /*decdef*/
extern int rpmatch(const char *  __response ) ; /*decdef*/
extern void *  memcpy(void *  __dest , const void *  __src , size_t __n )
  ; /*decdef*/
extern void *  memmove(void *  __dest , const void *  __src , size_t __n )
  ; /*decdef*/
extern void *  memccpy(void *  __dest , const void *  __src , int __c , size_t
  __n ) ; /*decdef*/
extern void *  memset(void *  __s , int __c , size_t __n ) ; /*decdef*/
extern int memcmp(const void *  __s1 , const void *  __s2 , size_t __n )
  ; /*decdef*/
extern void *  memchr(const void *  __s , int __c , size_t __n ) ; /*decdef*/
extern char *  strcpy(char *  __dest , const char *  __src ) ; /*decdef*/
extern char *  strncpy(char *  __dest , const char *  __src , size_t __n )
  ; /*decdef*/
extern char *  strcat(char *  __dest , const char *  __src ) ; /*decdef*/
extern char *  strncat(char *  __dest , const char *  __src , size_t __n )
  ; /*decdef*/
extern int strcmp(const char *  __s1 , const char *  __s2 ) ; /*decdef*/
extern int strncmp(const char *  __s1 , const char *  __s2 , size_t __n )
  ; /*decdef*/
extern int strcoll(const char *  __s1 , const char *  __s2 ) ; /*decdef*/
extern size_t strxfrm(char *  __dest , const char *  __src , size_t __n )
  ; /*decdef*/
extern char *  __strdup(const char *  __s ) ; /*decdef*/
extern char *  strdup(const char *  __s ) ; /*decdef*/
extern char *  strchr(const char *  __s , int __c ) ; /*decdef*/
extern char *  strrchr(const char *  __s , int __c ) ; /*decdef*/
extern size_t strcspn(const char *  __s , const char *  __reject ) ; /*decdef*/
extern size_t strspn(const char *  __s , const char *  __accept ) ; /*decdef*/
extern char *  strpbrk(const char *  __s , const char *  __accept ) ; /*decdef*/
extern char *  strstr(const char *  __haystack , const char *  __needle )
  ; /*decdef*/
extern char *  strtok(char *  __s , const char *  __delim ) ; /*decdef*/
extern char *  __strtok_r(char *  __s , const char *  __delim , char *  * 
  __save_ptr ) ; /*decdef*/
extern char *  strtok_r(char *  __s , const char *  __delim , char *  * 
  __save_ptr ) ; /*decdef*/
extern size_t strlen(const char *  __s ) ; /*decdef*/
extern char *  strerror(int __errnum ) ; /*decdef*/
extern char *  __strerror_r(int __errnum , char *  __buf , size_t __buflen )
  ; /*decdef*/
extern char *  strerror_r(int __errnum , char *  __buf , size_t __buflen )
  ; /*decdef*/
extern void __bzero(void *  __s , size_t __n ) ; /*decdef*/
extern void bcopy(const void *  __src , void *  __dest , size_t __n )
  ; /*decdef*/
extern void bzero(void *  __s , size_t __n ) ; /*decdef*/
extern int bcmp(const void *  __s1 , const void *  __s2 , size_t __n )
  ; /*decdef*/
extern char *  index(const char *  __s , int __c ) ; /*decdef*/
extern char *  rindex(const char *  __s , int __c ) ; /*decdef*/
extern int __ffs(int __i ) __attribute__((const)) ; /*decdef*/
extern int ffs(int __i ) __attribute__((const)) ; /*decdef*/
extern int __strcasecmp(const char *  __s1 , const char *  __s2 ) ; /*decdef*/
extern int strcasecmp(const char *  __s1 , const char *  __s2 ) ; /*decdef*/
extern int strncasecmp(const char *  __s1 , const char *  __s2 , size_t __n )
  ; /*decdef*/
extern char *  strsep(char *  *  __stringp , const char *  __delim )
  ; /*decdef*/

enum  {
  _ISupper = 0 < 8 ? 1 << 0 << 8 : 1 << 0 >> 8,
  _ISlower = 1 < 8 ? 1 << 1 << 8 : 1 << 1 >> 8,
  _ISalpha = 2 < 8 ? 1 << 2 << 8 : 1 << 2 >> 8,
  _ISdigit = 3 < 8 ? 1 << 3 << 8 : 1 << 3 >> 8,
  _ISxdigit = 4 < 8 ? 1 << 4 << 8 : 1 << 4 >> 8,
  _ISspace = 5 < 8 ? 1 << 5 << 8 : 1 << 5 >> 8,
  _ISprint = 6 < 8 ? 1 << 6 << 8 : 1 << 6 >> 8,
  _ISgraph = 7 < 8 ? 1 << 7 << 8 : 1 << 7 >> 8,
  _ISblank = 8 < 8 ? 1 << 8 << 8 : 1 << 8 >> 8,
  _IScntrl = 9 < 8 ? 1 << 9 << 8 : 1 << 9 >> 8,
  _ISpunct = 10 < 8 ? 1 << 10 << 8 : 1 << 10 >> 8,
  _ISalnum = 11 < 8 ? 1 << 11 << 8 : 1 << 11 >> 8
} ; /*onlytypedef*/

extern const unsigned short int *  __ctype_b ; /*decdef*/
extern const __int32_t *  __ctype_tolower ; /*decdef*/
extern const __int32_t *  __ctype_toupper ; /*decdef*/
extern int _get__ctype_b(int  ) ; /*decdef*/
extern int isalnum(int  ) ; /*decdef*/
extern int isalpha(int  ) ; /*decdef*/
extern int iscntrl(int  ) ; /*decdef*/
extern int isdigit(int  ) ; /*decdef*/
extern int islower(int  ) ; /*decdef*/
extern int isgraph(int  ) ; /*decdef*/
extern int isprint(int  ) ; /*decdef*/
extern int ispunct(int  ) ; /*decdef*/
extern int isspace(int  ) ; /*decdef*/
extern int isupper(int  ) ; /*decdef*/
extern int isxdigit(int  ) ; /*decdef*/
extern int tolower(int __c ) ; /*decdef*/
extern int toupper(int __c ) ; /*decdef*/
extern int isascii(int __c ) ; /*decdef*/
extern int toascii(int __c ) ; /*decdef*/
extern int _toupper(int  ) ; /*decdef*/
extern int _tolower(int  ) ; /*decdef*/

typedef void *  __gnuc_va_list ; /*typedef*/

typedef struct _IO_FILE FILE ; /*typedef*/

typedef unsigned int wint_t ; /*typedef*/

typedef int _G_int16_t __attribute__((__mode__(__HI__))) ; /*typedef*/

typedef int _G_int32_t __attribute__((__mode__(__SI__))) ; /*typedef*/

typedef unsigned int _G_uint16_t __attribute__((__mode__(__HI__))) ; /*typedef*/

typedef unsigned int _G_uint32_t __attribute__((__mode__(__SI__))) ; /*typedef*/

struct _IO_jump_t ; /*onlytypedef*/

struct _IO_FILE ; /*onlytypedef*/

typedef void _IO_lock_t ; /*typedef*/

struct _IO_marker {
  struct _IO_marker *  _next ;
  struct _IO_FILE *  _sbuf ;
  int _pos ;
} ; /*onlytypedef*/

struct _IO_FILE {
  int _flags ;
  char *  _IO_read_ptr ;
  char *  _IO_read_end ;
  char *  _IO_read_base ;
  char *  _IO_write_base ;
  char *  _IO_write_ptr ;
  char *  _IO_write_end ;
  char *  _IO_buf_base ;
  char *  _IO_buf_end ;
  char *  _IO_save_base ;
  char *  _IO_backup_base ;
  char *  _IO_save_end ;
  struct _IO_marker *  _markers ;
  struct _IO_FILE *  _chain ;
  int _fileno ;
  int _blksize ;
  __off_t _old_offset ;
  unsigned short _cur_column ;
  signed char _vtable_offset ;
  char _shortbuf[1] ;
  _IO_lock_t *  _lock ;
  __off64_t _offset ;
  int _unused2[16] ;
} ; /*onlytypedef*/

typedef struct _IO_FILE _IO_FILE ; /*typedef*/

struct { } ; /*onlytypedef*/

extern struct _IO_FILE_plus _IO_2_1_stdin_ ; /*decdef*/
extern struct _IO_FILE_plus _IO_2_1_stdout_ ; /*decdef*/
extern struct _IO_FILE_plus _IO_2_1_stderr_ ; /*decdef*/

typedef __ssize_t __io_read_fn(void *  __cookie , char *  __buf , size_t
  __nbytes ) ; /*typedef*/

typedef __ssize_t __io_write_fn(void *  __cookie , const char *  __buf , size_t
  __n ) ; /*typedef*/

typedef int __io_seek_fn(void *  __cookie , __off_t __pos , int __w )
  ; /*typedef*/

typedef int __io_close_fn(void *  __cookie ) ; /*typedef*/

extern int __underflow(_IO_FILE *  ) ; /*decdef*/
extern int __uflow(_IO_FILE *  ) ; /*decdef*/
extern int __overflow(_IO_FILE *  , int  ) ; /*decdef*/
extern int _IO_getc(_IO_FILE *  __fp ) ; /*decdef*/
extern int _IO_putc(int __c , _IO_FILE *  __fp ) ; /*decdef*/
extern int _IO_feof(_IO_FILE *  __fp ) ; /*decdef*/
extern int _IO_ferror(_IO_FILE *  __fp ) ; /*decdef*/
extern int _IO_peekc_locked(_IO_FILE *  __fp ) ; /*decdef*/
extern void _IO_flockfile(_IO_FILE *  ) ; /*decdef*/
extern void _IO_funlockfile(_IO_FILE *  ) ; /*decdef*/
extern int _IO_ftrylockfile(_IO_FILE *  ) ; /*decdef*/
extern int _IO_vfscanf(_IO_FILE *  , const char *  , __gnuc_va_list , int *  )
  ; /*decdef*/
extern int _IO_vfprintf(_IO_FILE *  , const char *  , __gnuc_va_list )
  ; /*decdef*/
extern __ssize_t _IO_padn(_IO_FILE *  , int  , __ssize_t ) ; /*decdef*/
extern size_t _IO_sgetn(_IO_FILE *  , void *  , size_t ) ; /*decdef*/
extern __off64_t _IO_seekoff(_IO_FILE *  , __off64_t , int  , int  )
  ; /*decdef*/
extern __off64_t _IO_seekpos(_IO_FILE *  , __off64_t , int  ) ; /*decdef*/
extern void _IO_free_backup_area(_IO_FILE *  ) ; /*decdef*/

typedef __off_t fpos_t ; /*typedef*/

FILE *  get_stdin(void  ) ; /*decdef*/
FILE *  get_stdout(void  ) ; /*decdef*/
FILE *  get_stderr(void  ) ; /*decdef*/
extern int remove(const char *  __filename ) ; /*decdef*/
extern int rename(const char *  __old , const char *  __new ) ; /*decdef*/
extern FILE *  tmpfile(void  ) ; /*decdef*/
extern char *  tmpnam(char *  __s ) ; /*decdef*/
extern char *  tmpnam_r(char *  __s ) ; /*decdef*/
extern char *  tempnam(const char *  __dir , const char *  __pfx ) ; /*decdef*/
extern int fclose(FILE *  __stream ) ; /*decdef*/
extern int fflush(FILE *  __stream ) ; /*decdef*/
extern int fflush_unlocked(FILE *  __stream ) ; /*decdef*/
extern FILE *  fopen(const char *  __filename , const char *  __modes )
  ; /*decdef*/
extern FILE *  freopen(const char *  __filename , const char *  __modes , FILE
  *  __stream ) ; /*decdef*/
extern FILE *  fdopen(int __fd , const char *  __modes ) ; /*decdef*/
extern void setbuf(FILE *  __stream , char *  __buf ) ; /*decdef*/
extern int setvbuf(FILE *  __stream , char *  __buf , int __modes , size_t __n )
  ; /*decdef*/
extern void setbuffer(FILE *  __stream , char *  __buf , size_t __size )
  ; /*decdef*/
extern void setlinebuf(FILE *  __stream ) ; /*decdef*/
extern int fprintf(FILE *  __stream , const char *  __format , ...) ; /*decdef*/
extern int printf(const char *  __format , ...) ; /*decdef*/
extern int sprintf(char *  __s , const char *  __format , ...) ; /*decdef*/
extern int vfprintf(FILE *  __s , const char *  __format , __gnuc_va_list __arg
  ) ; /*decdef*/
extern int vprintf(const char *  __format , __gnuc_va_list __arg ) ; /*decdef*/
extern int vsprintf(char *  __s , const char *  __format , __gnuc_va_list __arg
  ) ; /*decdef*/
extern int snprintf(char *  __s , size_t __maxlen , const char *  __format
  , ...) __attribute__((__format__(__printf__, 3, 4))) ; /*decdef*/
extern int __vsnprintf(char *  __s , size_t __maxlen , const char *  __format ,
  __gnuc_va_list __arg ) __attribute__((__format__(__printf__, 3, 0)))
  ; /*decdef*/
extern int vsnprintf(char *  __s , size_t __maxlen , const char *  __format ,
  __gnuc_va_list __arg ) __attribute__((__format__(__printf__, 3, 0)))
  ; /*decdef*/
extern int fscanf(FILE *  __stream , const char *  __format , ...) ; /*decdef*/
extern int scanf(const char *  __format , ...) ; /*decdef*/
extern int sscanf(const char *  __s , const char *  __format , ...) ; /*decdef*/
extern int fgetc(FILE *  __stream ) ; /*decdef*/
extern int getc(FILE *  __stream ) ; /*decdef*/
extern int getchar(void  ) ; /*decdef*/
extern int getc_unlocked(FILE *  __stream ) ; /*decdef*/
extern int getchar_unlocked(void  ) ; /*decdef*/
extern int fgetc_unlocked(FILE *  __stream ) ; /*decdef*/
extern int fputc(int __c , FILE *  __stream ) ; /*decdef*/
extern int putc(int __c , FILE *  __stream ) ; /*decdef*/
extern int putchar(int __c ) ; /*decdef*/
extern int fputc_unlocked(int __c , FILE *  __stream ) ; /*decdef*/
extern int putc_unlocked(int __c , FILE *  __stream ) ; /*decdef*/
extern int putchar_unlocked(int __c ) ; /*decdef*/
extern int getw(FILE *  __stream ) ; /*decdef*/
extern int putw(int __w , FILE *  __stream ) ; /*decdef*/
extern char *  fgets(char *  __s , int __n , FILE *  __stream ) ; /*decdef*/
extern char *  gets(char *  __s ) ; /*decdef*/
extern int fputs(const char *  __s , FILE *  __stream ) ; /*decdef*/
extern int puts(const char *  __s ) ; /*decdef*/
extern int ungetc(int __c , FILE *  __stream ) ; /*decdef*/
extern size_t fread(void *  __ptr , size_t __size , size_t __n , FILE * 
  __stream ) ; /*decdef*/
extern size_t fwrite(const void *  __ptr , size_t __size , size_t __n , FILE * 
  __s ) ; /*decdef*/
extern size_t fread_unlocked(void *  __ptr , size_t __size , size_t __n , FILE
  *  __stream ) ; /*decdef*/
extern size_t fwrite_unlocked(const void *  __ptr , size_t __size , size_t __n ,
  FILE *  __stream ) ; /*decdef*/
extern int fseek(FILE *  __stream , long int __off , int __whence ) ; /*decdef*/
extern long int ftell(FILE *  __stream ) ; /*decdef*/
extern void rewind(FILE *  __stream ) ; /*decdef*/
extern int fgetpos(FILE *  __stream , fpos_t *  __pos ) ; /*decdef*/
extern int fsetpos(FILE *  __stream , const fpos_t *  __pos ) ; /*decdef*/
extern void clearerr(FILE *  __stream ) ; /*decdef*/
extern int feof(FILE *  __stream ) ; /*decdef*/
extern int ferror(FILE *  __stream ) ; /*decdef*/
extern void clearerr_unlocked(FILE *  __stream ) ; /*decdef*/
extern int feof_unlocked(FILE *  __stream ) ; /*decdef*/
extern int ferror_unlocked(FILE *  __stream ) ; /*decdef*/
extern void perror(const char *  __s ) ; /*decdef*/
extern int sys_nerr ; /*decdef*/
extern const char * const sys_errlist[] ; /*decdef*/
extern int fileno(FILE *  __stream ) ; /*decdef*/
extern int fileno_unlocked(FILE *  __stream ) ; /*decdef*/
extern FILE *  popen(const char *  __command , const char *  __modes )
  ; /*decdef*/
extern int pclose(FILE *  __stream ) ; /*decdef*/
extern char *  ctermid(char *  __s ) ; /*decdef*/
extern void flockfile(FILE *  __stream ) ; /*decdef*/
extern int ftrylockfile(FILE *  __stream ) ; /*decdef*/
extern void funlockfile(FILE *  __stream ) ; /*decdef*/
void pm_init(int *  argcP , char *  argv[] ) ; /*decdef*/
char *  *  pm_allocarray(int cols , int rows , int size ) ; /*decdef*/
char *  pm_allocrow(int cols , int size ) ; /*decdef*/
void pm_freearray(char *  *  its , int rows ) ; /*decdef*/
void pm_freerow(char *  itrow ) ; /*decdef*/
int pm_keymatch(char *  str , char *  keyword , int minchars ) ; /*decdef*/
int pm_maxvaltobits(int maxval ) ; /*decdef*/
int pm_bitstomaxval(int bits ) ; /*decdef*/


#pragma boxprintf("pm_message", 0)
void pm_message(char *  , ...) ; /*decdef*/


#pragma boxprintf("pm_error", 0)
void pm_error(char *  , ...) ; /*decdef*/
void pm_perror(char *  reason ) ; /*decdef*/
void pm_usage(char *  usage ) ; /*decdef*/
FILE *  pm_openr(char *  name ) ; /*decdef*/
FILE *  pm_openw(char *  name ) ; /*decdef*/
void pm_close(FILE *  f ) ; /*decdef*/
int pm_readbigshort(FILE *  in , short *  sP ) ; /*decdef*/
int pm_writebigshort(FILE *  out , short s ) ; /*decdef*/
int pm_readbiglong(FILE *  in , long *  lP ) ; /*decdef*/
int pm_writebiglong(FILE *  out , long l ) ; /*decdef*/
int pm_readlittleshort(FILE *  in , short *  sP ) ; /*decdef*/
int pm_writelittleshort(FILE *  out , short s ) ; /*decdef*/
int pm_readlittlelong(FILE *  in , long *  lP ) ; /*decdef*/
int pm_writelittlelong(FILE *  out , long l ) ; /*decdef*/

typedef unsigned char bit ; /*typedef*/

void pbm_init(int *  argcP , char *  argv[] ) ; /*decdef*/
bit *  *  pbm_readpbm(FILE *  file , int *  colsP , int *  rowsP ) ; /*decdef*/
void pbm_readpbminit(FILE *  file , int *  colsP , int *  rowsP , int *  formatP
  ) ; /*decdef*/
void pbm_readpbmrow(FILE *  file , bit *  bitrow , int cols , int format )
  ; /*decdef*/
void pbm_writepbm(FILE *  file , bit *  *  bits , int cols , int rows ,
  int forceplain ) ; /*decdef*/
void pbm_writepbminit(FILE *  file , int cols , int rows , int forceplain )
  ; /*decdef*/
void pbm_writepbmrow(FILE *  file , bit *  bitrow , int cols , int forceplain )
  ; /*decdef*/
char pbm_getc(FILE *  file ) ; /*decdef*/
unsigned char pbm_getrawbyte(FILE *  file ) ; /*decdef*/
int pbm_getint(FILE *  file ) ; /*decdef*/
int pbm_readmagicnumber(FILE *  file ) ; /*decdef*/
void pbm_readpbminitrest(FILE *  file , int *  colsP , int *  rowsP )
  ; /*decdef*/
void va_end(__gnuc_va_list ) ; /*decdef*/

typedef __gnuc_va_list va_list ; /*typedef*/

extern int errno ; /*decdef*/
extern int *  __errno_location(void  ) __attribute__((const)) ; /*decdef*/

char *  pm_allocrow(int cols , int size )
{
  register char *  itrow ; /*decdef*/
  itrow = (char *  )malloc(cols * size);
  if(itrow == (char *  )0)
    pm_error("out of memory allocating a row");
  return itrow;
}

void pm_freerow(char *  itrow )
{
  free(itrow);
}

char *  *  pm_allocarray(int cols , int rows , int size )
{
  char *  *  its ; /*decdef*/
  int i ; /*decdef*/
  its = (char *  *  )malloc(rows * sizeof(* its));
  if(its == (char *  *  )0)
    pm_error("out of memory allocating an array");
  its[0] = (char *  )malloc(rows * cols * size);
  if(its[0] == (char *  )0)
    pm_error("out of memory allocating an array");
  for(i = 1; i < rows; ++ i)
    its[i] = & (its[0])[i * cols * size];
  return its;
}

void pm_freearray(char *  *  its , int rows )
{
  free(its[0]);
  free(its);
}

int pm_keymatch(char *  str , char *  keyword , int minchars )
{
  register int len ; /*decdef*/
  len = strlen(str);
  if(len < minchars)
    return 0;
  while(-- len >= 0)
  {
    register char c1 , c2 ; /*decdef*/
    c1 = * str++;
    c2 = * keyword++;
    if(c2 == '\0')
      return 0;
    if(_get__ctype_b((int )c1) & (unsigned short int )_ISupper)
      c1 = tolower(c1);
    if(_get__ctype_b((int )c2) & (unsigned short int )_ISupper)
      c1 = tolower(c2);
    if(c1 != c2)
      return 0;
  }
  return 1;
}

int pm_maxvaltobits(int maxval )
{
  if(maxval <= 1)
    return 1;
  else
  {
    if(maxval <= 3)
      return 2;
    else
    {
      if(maxval <= 7)
	return 3;
      else
      {
	if(maxval <= 15)
	  return 4;
	else
	{
	  if(maxval <= 31)
	    return 5;
	  else
	  {
	    if(maxval <= 63)
	      return 6;
	    else
	    {
	      if(maxval <= 127)
		return 7;
	      else
	      {
		if(maxval <= 255)
		  return 8;
		else
		{
		  if(maxval <= 511)
		    return 9;
		  else
		  {
		    if(maxval <= 1023)
		      return 10;
		    else
		    {
		      if(maxval <= 2047)
			return 11;
		      else
		      {
			if(maxval <= 4095)
			  return 12;
			else
			{
			  if(maxval <= 8191)
			    return 13;
			  else
			  {
			    if(maxval <= 16383)
			      return 14;
			    else
			    {
			      if(maxval <= 32767)
				return 15;
			      else
			      {
				if((long )maxval <= 65535L)
				  return 16;
				else
				  pm_error("maxval of %d is too large!",
				    maxval);
			      }
			    }
			  }
			}
		      }
		    }
		  }
		}
	      }
	    }
	  }
	}
      }
    }
  }
}

int pm_bitstomaxval(int bits )
{
  return (1 << bits) - 1;
}

char *  progname ; /*decdef*/
int showmessages ; /*decdef*/

void pm_init(int *  argcP , char *  argv[] )
{
  int argn , i ; /*decdef*/
  progname = strrchr(argv[0], '/');
  if(progname == (void *  )0)
    progname = argv[0];
  else
    ++ progname;
  showmessages = 1;
  for(argn = 1; argn < * argcP; ++ argn)
  {
    if(pm_keymatch(argv[argn], "-quiet", 6))
    {
      showmessages = 0;
    }
    else
    {
      if(pm_keymatch(argv[argn], "-version", 7))
      {
	pm_message("Version of %s", "10dec91");
	pm_message("PBMPLUS_RAWBITS defined");
	exit(0);
      }
      else
	continue;
    }
    for(i = argn + 1; i <= * argcP; ++ i)
      argv[i - 1] = argv[i];
    -- * argcP;
  }
}

void pbm_init(int *  argcP , char *  argv[] )
{
  pm_init(argcP, argv);
}

void pm_usage(char *  usage )
{
  fprintf(get_stderr(), "usage:  %s %s\n", progname, usage);
  exit(1);
}

FILE *  pm_openr(char *  name )
{
  FILE *  f ; /*decdef*/
  if(strcmp(name, "-") == 0)
    f = get_stdin();
  else
  {
    f = fopen(name, "r");
    if(f == (void *  )0)
    {
      pm_perror(name);
      exit(1);
    }
  }
  return f;
}

FILE *  pm_openw(char *  name )
{
  FILE *  f ; /*decdef*/
  f = fopen(name, "w");
  if(f == (void *  )0)
  {
    pm_perror(name);
    exit(1);
  }
  return f;
}

void pm_close(FILE *  f )
{
  fflush(f);
  if(ferror(f))
    pm_message("a file read or write error occurred at some point");
  if(f != get_stdin())
  {
    if(fclose(f) != 0)
      pm_perror("fclose");
  }
}

int pm_readbigshort(FILE *  in , short *  sP )
{
  int c ; /*decdef*/
  if((c = _IO_getc(in)) == - 1)
    return - 1;
  * sP = (c & 0xff) << 8;
  if((c = _IO_getc(in)) == - 1)
    return - 1;
  * sP |= c & 0xff;
  return 0;
}

int pm_writebigshort(FILE *  out , short s )
{
  (void )_IO_putc(s >> 8 & 0xff, out);
  (void )_IO_putc(s & 0xff, out);
  return 0;
}

int pm_readbiglong(FILE *  in , long *  lP )
{
  int c ; /*decdef*/
  if((c = _IO_getc(in)) == - 1)
    return - 1;
  * lP = (c & 0xff) << 24;
  if((c = _IO_getc(in)) == - 1)
    return - 1;
  * lP |= (c & 0xff) << 16;
  if((c = _IO_getc(in)) == - 1)
    return - 1;
  * lP |= (c & 0xff) << 8;
  if((c = _IO_getc(in)) == - 1)
    return - 1;
  * lP |= c & 0xff;
  return 0;
}

int pm_writebiglong(FILE *  out , long l )
{
  (void )_IO_putc(l >> 24 & 0xff, out);
  (void )_IO_putc(l >> 16 & 0xff, out);
  (void )_IO_putc(l >> 8 & 0xff, out);
  (void )_IO_putc(l & 0xff, out);
  return 0;
}

int pm_readlittleshort(FILE *  in , short *  sP )
{
  int c ; /*decdef*/
  if((c = _IO_getc(in)) == - 1)
    return - 1;
  * sP = c & 0xff;
  if((c = _IO_getc(in)) == - 1)
    return - 1;
  * sP |= (c & 0xff) << 8;
  return 0;
}

int pm_writelittleshort(FILE *  out , short s )
{
  (void )_IO_putc(s & 0xff, out);
  (void )_IO_putc(s >> 8 & 0xff, out);
  return 0;
}

int pm_readlittlelong(FILE *  in , long *  lP )
{
  int c ; /*decdef*/
  if((c = _IO_getc(in)) == - 1)
    return - 1;
  * lP = c & 0xff;
  if((c = _IO_getc(in)) == - 1)
    return - 1;
  * lP |= (c & 0xff) << 8;
  if((c = _IO_getc(in)) == - 1)
    return - 1;
  * lP |= (c & 0xff) << 16;
  if((c = _IO_getc(in)) == - 1)
    return - 1;
  * lP |= (c & 0xff) << 24;
  return 0;
}

int pm_writelittlelong(FILE *  out , long l )
{
  (void )_IO_putc(l & 0xff, out);
  (void )_IO_putc(l >> 8 & 0xff, out);
  (void )_IO_putc(l >> 16 & 0xff, out);
  (void )_IO_putc(l >> 24 & 0xff, out);
  return 0;
}


#pragma combiner("./libpbm2.i", "-g -O -I/home/scott/wrk/safec/cil/lib ")

#pragma boxalloc("malloc", nozero, sizein(0))

#pragma boxalloc("alloca", nozero, sizein(0))

#pragma boxalloc("calloc", zero, sizemul(0, 1))

#pragma boxprintf("printf", 0)

#pragma boxprintf("fprintf", 1)

#pragma boxprintf("sprintf", 1)

#pragma boxprintf("snprintf", 2)

#pragma boxpoly("memcpy")

#pragma boxexported("main")

#pragma boxprintf("pm_message", 0)

#pragma boxprintf("pm_error", 0)
static bit pbm_getbit(FILE *  file )
{
  register char ch ; /*decdef*/
  do
  {
    ch = pbm_getc(file);
  }
  while(ch == ' ' || ch == '\t' || ch == '\n' || ch == '\r');
  if(ch != '0' && ch != '1')
    pm_error("junk in file where bits should be");
  return ch == '1' ? 1 : 0;
}

int pbm_readmagicnumber(FILE *  file )
{
  int ich1 , ich2 ; /*decdef*/
  ich1 = _IO_getc(file);
  if(ich1 == - 1)
    pm_error("EOF / read error reading magic number");
  ich2 = _IO_getc(file);
  if(ich2 == - 1)
    pm_error("EOF / read error reading magic number");
  return ich1 * 256 + ich2;
}

void pbm_readpbminitrest(FILE *  file , int *  colsP , int *  rowsP )
{
  * colsP = pbm_getint(file);
  * rowsP = pbm_getint(file);
}

void pbm_readpbminit(FILE *  file , int *  colsP , int *  rowsP , int *  formatP
  )
{
  * formatP = pbm_readmagicnumber(file);
  switch(* formatP == 'P' * 256 + '1' || * formatP == 'P' * 256 + '4' ? 'P' *
    256 + '1' : - 1)
  {
  case 'P' * 256 + '1':
      ;
    pbm_readpbminitrest(file, colsP, rowsP);
    break;
  default :
      ;
    pm_error("bad magic number - not a pbm file");
  }
}

void pbm_readpbmrow(FILE *  file , bit *  bitrow , int cols , int format )
{
  register int col , bitshift ; /*decdef*/
  register unsigned char item ; /*decdef*/
  register bit *  bP ; /*decdef*/
  switch(format)
  {
  case 'P' * 256 + '1':
      ;
    for(col = 0, bP = bitrow; col < cols; ++ col, ++ bP)
      * bP = pbm_getbit(file);
    break;
  case 'P' * 256 + '4':
      ;
    bitshift = - 1;
    for(col = 0, bP = bitrow; col < cols; ++ col, ++ bP)
    {
      if(bitshift == - 1)
      {
	item = pbm_getrawbyte(file);
	bitshift = 7;
      }
      * bP = item >> bitshift & 1;
      -- bitshift;
    }
    break;
  default :
      ;
    pm_error("can\'t happen");
  }
}

bit *  *  pbm_readpbm(FILE *  file , int *  colsP , int *  rowsP )
{
  register bit *  *  bits ; /*decdef*/
  int format , row ; /*decdef*/
  pbm_readpbminit(file, colsP, rowsP, & format);
  bits = (bit *  *  )pm_allocarray(* colsP, * rowsP, sizeof(bit ));
  for(row = 0; row < * rowsP; ++ row)
    pbm_readpbmrow(file, bits[row], * colsP, format);
  return bits;
}


#pragma combiner("./libpbm3.i", "-g -O -I/home/scott/wrk/safec/cil/lib ")

#pragma boxalloc("malloc", nozero, sizein(0))

#pragma boxalloc("alloca", nozero, sizein(0))

#pragma boxalloc("calloc", zero, sizemul(0, 1))

#pragma boxprintf("printf", 0)

#pragma boxprintf("fprintf", 1)

#pragma boxprintf("sprintf", 1)

#pragma boxprintf("snprintf", 2)

#pragma boxpoly("memcpy")

#pragma boxexported("main")

#pragma boxprintf("pm_message", 0)

#pragma boxprintf("pm_error", 0)
void pbm_writepbminit(FILE *  file , int cols , int rows , int forceplain )
{
  if(! forceplain)
    fprintf(file, "%c%c\n%d %d\n", 'P', '4', cols, rows);
  else
    fprintf(file, "%c%c\n%d %d\n", 'P', '1', cols, rows);
}

static void pbm_writepbmrowraw(FILE *  file , bit *  bitrow , int cols )
{
  register int col , bitshift ; /*decdef*/
  register unsigned char item ; /*decdef*/
  register bit *  bP ; /*decdef*/
  bitshift = 7;
  item = 0;
  for(col = 0, bP = bitrow; col < cols; ++ col, ++ bP)
  {
    if(* bP)
      item += 1 << bitshift;
    -- bitshift;
    if(bitshift == - 1)
    {
      (void )_IO_putc(item, file);
      bitshift = 7;
      item = 0;
    }
  }
  if(bitshift != 7)
    (void )_IO_putc(item, file);
}

static void pbm_writepbmrowplain(FILE *  file , bit *  bitrow , int cols )
{
  register int col , charcount ; /*decdef*/
  register bit *  bP ; /*decdef*/
  charcount = 0;
  for(col = 0, bP = bitrow; col < cols; ++ col, ++ bP)
  {
    if(charcount >= 70)
    {
      (void )_IO_putc('\n', file);
      charcount = 0;
    }
    (void )_IO_putc(* bP ? '1' : '0', file);
    ++ charcount;
  }
  (void )_IO_putc('\n', file);
}

void pbm_writepbmrow(FILE *  file , bit *  bitrow , int cols , int forceplain )
{
  if(! forceplain)
    pbm_writepbmrowraw(file, bitrow, cols);
  else
    pbm_writepbmrowplain(file, bitrow, cols);
}

void pbm_writepbm(FILE *  file , bit *  *  bits , int cols , int rows ,
  int forceplain )
{
  int row ; /*decdef*/
  pbm_writepbminit(file, cols, rows, forceplain);
  for(row = 0; row < rows; ++ row)
    pbm_writepbmrow(file, bits[row], cols, forceplain);
}


#pragma combiner("./libpbm4.i", "-g -O -I/home/scott/wrk/safec/cil/lib ")

#pragma boxalloc("malloc", nozero, sizein(0))

#pragma boxalloc("alloca", nozero, sizein(0))

#pragma boxalloc("calloc", zero, sizemul(0, 1))

#pragma boxprintf("printf", 0)

#pragma boxprintf("fprintf", 1)

#pragma boxprintf("sprintf", 1)

#pragma boxprintf("snprintf", 2)

#pragma boxpoly("memcpy")

#pragma boxexported("main")

#pragma boxprintf("pm_message", 0)

#pragma boxprintf("pm_error", 0)
char pbm_getc(FILE *  file )
{
  register int ich ; /*decdef*/
  register char ch ; /*decdef*/
  ich = _IO_getc(file);
  if(ich == - 1)
    pm_error("EOF / read error");
  ch = (char )ich;
  if(ch == '#')
  {
    do
    {
      ich = _IO_getc(file);
      if(ich == - 1)
	pm_error("EOF / read error");
      ch = (char )ich;
    }
    while(ch != '\n' && ch != '\r');
  }
  return ch;
}

unsigned char pbm_getrawbyte(FILE *  file )
{
  register int iby ; /*decdef*/
  iby = _IO_getc(file);
  if(iby == - 1)
    pm_error("EOF / read error");
  return (unsigned char )iby;
}

int pbm_getint(FILE *  file )
{
  register char ch ; /*decdef*/
  register int i ; /*decdef*/
  do
  {
    ch = pbm_getc(file);
  }
  while(ch == ' ' || ch == '\t' || ch == '\n' || ch == '\r');
  if(ch < '0' || ch > '9')
    pm_error("junk in file where an integer should be");
  i = 0;
  do
  {
    i = i * 10 + ch - '0';
    ch = pbm_getc(file);
  }
  while(ch >= '0' && ch <= '9');
  return i;
}


#pragma combiner("./libpbm5.i", "-g -O -I/home/scott/wrk/safec/cil/lib ")

#pragma boxalloc("malloc", nozero, sizein(0))

#pragma boxalloc("alloca", nozero, sizein(0))

#pragma boxalloc("calloc", zero, sizemul(0, 1))

#pragma boxprintf("printf", 0)

#pragma boxprintf("fprintf", 1)

#pragma boxprintf("sprintf", 1)

#pragma boxprintf("snprintf", 2)

#pragma boxpoly("memcpy")

#pragma boxexported("main")

#pragma boxprintf("pm_message", 0)

#pragma boxprintf("pm_error", 0)
bit *  *  pbm_defaultfont(int *  fcolsP , int *  frowsP ) ; /*decdef*/
void pbm_dissectfont(bit *  *  font , int frows , int fcols , int * 
  char_heightP , int *  char_widthP , int *  char_aheightP , int *  char_awidthP
  , int char_row0[] , int char_col0[] ) ; /*decdef*/
void pbm_dumpfont(bit *  *  font , int fcols , int frows ) ; /*decdef*/
static unsigned long defaultfont_bits[155][(112 + 31) / 32] = {{0x00000000L,
  0x20000c00L, 0x10000000L, 0x00000000L}, {0xc600a000L, 0x42000810L,
  0x00000002L, 0x00000063L}, {0x6c00a000L, 0x45000810L, 0x00000002L,
  0x00000036L}, {0x6c00a000L, 0x88800808L, 0xf2e1dee2L, 0x00000036L},
  {0x54000000L, 0x80000800L, 0x11122442L, 0x0000002aL}, {0x54000001L,
  0x00000800L, 0x11122442L, 0x0000002aL}, {0x54000001L, 0x00000800L,
  0x11122282L, 0x0000002aL}, {0x44000102L, 0x00000800L, 0x11122382L,
  0x00000022L}, {0xee000102L, 0x00000800L, 0x11e1e102L, 0x00000077L},
  {0x00000204L, 0x00000800L, 0x11002102L, 0x00000000L}, {0x00000000L,
  0x00000c00L, 0x11002102L, 0x00000000L}, {0x00000000L, 0x003f8000L,
  0xe3807600L, 0x00000000L}, {0x00000000L, 0x00000000L, 0x00000000L,
  0x00000000L}, {0x00000000L, 0x00000000L, 0x00000000L, 0x00000000L},
  {0x00000000L, 0x00000000L, 0x00000000L, 0x00000000L}, {0x00000000L,
  0x00000000L, 0x00000000L, 0x00000000L}, {0x00000000L, 0x00000000L,
  0x00000000L, 0x00000000L}, {0x00000000L, 0x00000000L, 0x00000000L,
  0x00000000L}, {0x00000000L, 0x00000000L, 0x00000000L, 0x00000000L},
  {0x00000000L, 0x00000000L, 0x00000000L, 0x00000000L}, {0x00000000L,
  0x00000000L, 0x00000000L, 0x00000000L}, {0x00000000L, 0x00000000L,
  0x00000000L, 0x00000000L}, {0x00000000L, 0x00000000L, 0x00000000L,
  0x00000000L}, {0x00000000L, 0x00000000L, 0x00000000L, 0x00000000L},
  {0x00000000L, 0x00000000L, 0x00000000L, 0x00000000L}, {0x00000000L,
  0x00000000L, 0x00000000L, 0x00000000L}, {0x02000080L, 0x00040000L,
  0x00120000L, 0x00000001L}, {0x04000082L, 0x828e1838L, 0x20210100L,
  0x00000002L}, {0x04000082L, 0x82912448L, 0x20210100L, 0x00000002L},
  {0x08000082L, 0x8fd01940L, 0x404087c2L, 0x00000004L}, {0x08000080L,
  0x050c0622L, 0x00408102L, 0x00000004L}, {0x10000080L, 0x05061874L,
  0x0040828fL, 0x00008008L}, {0x10000080L, 0x1f912688L, 0x00408002L,
  0x00000008L}, {0x20000000L, 0x0a11098cL, 0x00408002L, 0x00000010L},
  {0x20000080L, 0x0a0e0672L, 0x00210000L, 0x00000010L}, {0x40000000L,
  0x00040000L, 0x00210000L, 0x00000020L}, {0x00000000L, 0x00000000L,
  0x00120000L, 0x00000000L}, {0x00000000L, 0x00000000L, 0x00000000L,
  0x00000000L}, {0x00000000L, 0x00000000L, 0x00000000L, 0x00000000L},
  {0x00000000L, 0x004e0838L, 0x7023e1cfL, 0x00008000L}, {0x00000000L,
  0x00913844L, 0x88620208L, 0x00008000L}, {0x08000000L, 0x00910844L,
  0x08a20401L, 0x00000004L}, {0x10000000L, 0x01110844L, 0x08a20401L,
  0x00000008L}, {0x20000000L, 0x01110808L, 0x3123c781L, 0x00000010L},
  {0x400003e0L, 0x02110810L, 0x0a202441L, 0x00000020L}, {0x20000000L,
  0x02110820L, 0x0bf02442L, 0x00000010L}, {0x10008000L, 0x04110844L,
  0x88242442L, 0x00000008L}, {0x08008002L, 0x040e3e7cL, 0x7073c382L,
  0x00000004L}, {0x00010000L, 0x08000000L, 0x00000000L, 0x00000000L},
  {0x00000000L, 0x00000000L, 0x00000000L, 0x00000000L}, {0x00000000L,
  0x00000000L, 0x00000000L, 0x00000000L}, {0x00000000L, 0x00000000L,
  0x00000000L, 0x00000000L}, {0x0000e1c0L, 0x00000000L, 0x00000000L,
  0x00000000L}, {0x00011220L, 0x00000000L, 0x70e38f87L, 0x00000000L},
  {0x20011220L, 0x00020020L, 0x89108448L, 0x00008010L}, {0x10011220L,
  0x00040010L, 0x09314448L, 0x00008008L}, {0x0800e221L, 0x02083e08L,
  0x11514788L, 0x00000004L}, {0x040111e0L, 0x00100004L, 0x2153e448L,
  0x00000002L}, {0x08011020L, 0x00083e08L, 0x213a2448L, 0x00008004L},
  {0x10011040L, 0x02040010L, 0x01022448L, 0x00008008L}, {0x2000e381L,
  0x02020020L, 0x20e77f87L, 0x00000010L}, {0x00000000L, 0x04000000L,
  0x00000000L, 0x00000000L}, {0x00000000L, 0x00000000L, 0x00000000L,
  0x00000000L}, {0x00000000L, 0x00000000L, 0x00000000L, 0x00000000L},
  {0x00000000L, 0x00000000L, 0x00000000L, 0x00000000L}, {0x00000000L,
  0x00000000L, 0x00000000L, 0x00000000L}, {0x3803e7efL, 0xc73bbe3dL,
  0xdb863ce7L, 0x0000001cL}, {0x44011224L, 0x48910808L, 0x91036648L,
  0x00008022L}, {0x4c011285L, 0x48910808L, 0xa1036648L, 0x00008026L},
  {0x54011387L, 0x081f0808L, 0xc102a548L, 0x0000802aL}, {0x54011285L,
  0x09910808L, 0xe102a548L, 0x0000802aL}, {0x4e011204L, 0x08910848L,
  0x9112a4c8L, 0x00008027L}, {0x40011224L, 0x08910848L, 0x891224c8L,
  0x00008020L}, {0x3803e7efL, 0x073bbe31L, 0xcff77e47L, 0x0000001cL},
  {0x00000000L, 0x00000000L, 0x00000000L, 0x00000000L}, {0x00000000L,
  0x00000000L, 0x00000000L, 0x00000000L}, {0x00000000L, 0x00000000L,
  0x00000000L, 0x00000000L}, {0x00000000L, 0x00000000L, 0x00000000L,
  0x00000000L}, {0x00000000L, 0x00000000L, 0x00000003L, 0x00000000L},
  {0x0003e1cfL, 0x87bff7efL, 0xdfbf77c2L, 0x00000000L}, {0x00013224L,
  0x48a4a244L, 0x89122442L, 0x00000000L}, {0x00011224L, 0x4824a244L,
  0xa8a14482L, 0x00000000L}, {0x00013227L, 0x8e04226cL, 0xa8414102L,
  0x00000000L}, {0x0001e224L, 0x83842228L, 0xa8a08102L, 0x00000000L},
  {0x00010224L, 0x40842228L, 0xd8a08242L, 0x00000000L}, {0x00010224L,
  0x48843638L, 0x51108442L, 0x00000000L}, {0x0003c1ceL, 0x6f1f1c10L,
  0x53b9c7c2L, 0x00000000L}, {0x00000060L, 0x00000000L, 0x00000002L,
  0x00000000L}, {0x00000000L, 0x00000000L, 0x00000003L, 0x00000000L},
  {0xfe000000L, 0x00000000L, 0x00000000L, 0x0000007fL}, {0x00000000L,
  0x00000000L, 0x00000000L, 0x00000000L}, {0x00010180L, 0x000000c0L,
  0x003001c0L, 0x00000000L}, {0x08008081L, 0x00040040L, 0x00100200L,
  0x00000004L}, {0x10008082L, 0x80040040L, 0x00100200L, 0x00000008L},
  {0x10004084L, 0x40023c78L, 0x70f1c7c7L, 0x00004008L}, {0x10004080L,
  0x00000244L, 0x89122208L, 0x00008008L}, {0x20002080L, 0x00001e44L,
  0x8113e208L, 0x00008010L}, {0x10002080L, 0x00002244L, 0x81120208L,
  0x00008008L}, {0x10001080L, 0x00002244L, 0x89122208L, 0x00008008L},
  {0x10001080L, 0x00001db8L, 0x70e9c787L, 0x00008008L}, {0x10000880L,
  0x00000000L, 0x00000000L, 0x00008008L}, {0x08000180L, 0x00000000L,
  0x00000000L, 0x00008004L}, {0x00000000L, 0x1fc00000L, 0x00000007L,
  0x00000000L}, {0x00000000L, 0x00000000L, 0x00000000L, 0x00000000L},
  {0x00030080L, 0x981c0000L, 0x00000000L, 0x00000000L}, {0x20010000L,
  0x08040000L, 0x00000000L, 0x00000010L}, {0x10010000L, 0x08040000L,
  0x00000000L, 0x00000008L}, {0x10016387L, 0x898474b8L, 0x72e1d5c7L,
  0x00000008L}, {0x10019080L, 0x8a042a64L, 0x89122208L, 0x00008008L},
  {0x08011080L, 0x8c042a44L, 0x89122207L, 0x00000004L}, {0x10011080L,
  0x8a042a44L, 0x89122200L, 0x00008008L}, {0x10011080L, 0x89042a44L,
  0x89122208L, 0x00008008L}, {0x1003bbe0L, 0x98dfebe6L, 0x71e1e787L,
  0x00000008L}, {0x10000000L, 0x80000000L, 0x01002000L, 0x00000008L},
  {0x20000000L, 0x80000000L, 0x01002000L, 0x00000010L}, {0x00000007L,
  0x00000000L, 0x03807000L, 0x00000000L}, {0x00000000L, 0x00000000L,
  0x00000000L, 0x00000000L}, {0x00000000L, 0x00000000L, 0x00000000L,
  0x00000000L}, {0x00008000L, 0x00000000L, 0x10410000L, 0x00000000L},
  {0x00008000L, 0x00000000L, 0x20408000L, 0x00000000L}, {0x0001f66eL,
  0xfdfbf77cL, 0x20408000L, 0x00000000L}, {0x24008224L, 0x488a2248L,
  0x20408240L, 0x00000012L}, {0x54008224L, 0x4a842210L, 0x40404540L,
  0x0000002aL}, {0x48008222L, 0x8a8a1420L, 0x20408480L, 0x00000024L},
  {0x00008a23L, 0x85111c44L, 0x20408000L, 0x00000000L}, {0x000071d1L,
  0x0531887cL, 0x20408000L, 0x00000000L}, {0x00000000L, 0x00000800L,
  0x20408000L, 0x00000000L}, {0x00000000L, 0x00000800L, 0x10410000L,
  0x00000000L}, {0x00000000L, 0x00003000L, 0x00000000L, 0x00000000L},
  {0x00000000L, 0x00000000L, 0x00000000L, 0x00000000L}, {0x00000000L,
  0x00000000L, 0x00000000L, 0x00000000L}, {0x00000000L, 0x00000000L,
  0x00000000L, 0x00000000L}, {0x00000000L, 0x00000000L, 0x00000000L,
  0x00000000L}, {0x00000000L, 0x00000000L, 0x00000000L, 0x00000000L},
  {0x00000000L, 0x00000000L, 0x00000000L, 0x00000000L}, {0x00000000L,
  0x00000000L, 0x00000000L, 0x00000000L}, {0x00000000L, 0x00000000L,
  0x00000000L, 0x00000000L}, {0x00000000L, 0x00000000L, 0x00000000L,
  0x00000000L}, {0x00000000L, 0x00000000L, 0x00000000L, 0x00000000L},
  {0x00000000L, 0x00000000L, 0x00000000L, 0x00000000L}, {0x00000000L,
  0x00000000L, 0x00000000L, 0x00000000L}, {0x00000000L, 0x00000000L,
  0x00000000L, 0x00000000L}, {0x00000000L, 0x00000000L, 0x00000000L,
  0x00000000L}, {0x00000000L, 0x20000c00L, 0x10000000L, 0x00000000L},
  {0xc600a000L, 0x42000810L, 0x00000002L, 0x00000063L}, {0x6c00a000L,
  0x45000810L, 0x00000002L, 0x00000036L}, {0x6c00a000L, 0x88800808L,
  0xf2e1dee2L, 0x00000036L}, {0x54000000L, 0x80000800L, 0x11122442L,
  0x0000002aL}, {0x54000001L, 0x00000800L, 0x11122442L, 0x0000002aL},
  {0x54000001L, 0x00000800L, 0x11122282L, 0x0000002aL}, {0x44000102L,
  0x00000800L, 0x11122382L, 0x00000022L}, {0xee000102L, 0x00000800L,
  0x11e1e102L, 0x00000077L}, {0x00000204L, 0x00000800L, 0x11002102L,
  0x00000000L}, {0x00000000L, 0x00000c00L, 0x11002102L, 0x00000000L},
  {0x00000000L, 0x003f8000L, 0xe3807600L, 0x00000000L}}; /*decdef*/

bit *  *  pbm_defaultfont(int *  fcolsP , int *  frowsP )
{
  bit *  *  defaultfont ; /*decdef*/
  int row , col , scol ; /*decdef*/
  unsigned long l ; /*decdef*/
  defaultfont = (bit *  *  )pm_allocarray(112, 155, sizeof(bit ));
  for(row = 0; row < 155; ++ row)
  {
    for(col = 0; col < 112; col += 32)
    {
      l = (defaultfont_bits[row])[col / 32];
      for(scol = (col + 32 < 112 ? col + 32 : 112) - 1; scol >= col; -- scol)
      {
	if(l & 1)
	  (defaultfont[row])[scol] = 1;
	else
	  (defaultfont[row])[scol] = 0;
	l >>= 1;
      }
    }
  }
  * fcolsP = 112;
  * frowsP = 155;
  return defaultfont;
}

void pbm_dissectfont(bit *  *  font , int frows , int fcols , int * 
  char_heightP , int *  char_widthP , int *  char_aheightP , int *  char_awidthP
  , int char_row0[95] , int char_col0[95] )
{
  int brow , bcol , row , col , d , ch ; /*decdef*/
  bit b ; /*decdef*/
  for(brow = 0; brow < frows / 6; ++ brow)
  {
    b = (font[brow])[0];
    for(col = 1; col < fcols; ++ col)
    {
      if((font[brow])[col] != b)
	goto nextrow;
    }
    goto gotblankrow;
    nextrow:
      ;
  }
  pm_error("couldn\'t find blank row in font");
  gotblankrow:
    for(bcol = 0; bcol < fcols / 8; ++ bcol)
    {
      b = (font[0])[bcol];
      for(row = 1; row < frows; ++ row)
      {
	if((font[row])[bcol] != b)
	  goto nextcol;
      }
      goto gotblankcol;
      nextcol:
	;
    }
  pm_error("couldn\'t find blank col in font");
  gotblankcol:
    d = frows - brow;
  * char_heightP = d / 11;
  if(* char_heightP * 11 != d)
    pm_error("problem computing character cell height");
  d = fcols - bcol;
  * char_widthP = d / 15;
  if(* char_widthP * 15 != d)
    pm_error("problem computing character cell width");
  * char_aheightP = brow;
  * char_awidthP = bcol;
  row = * char_heightP * 2;
  col = * char_widthP * 2;
  for(ch = 0; ch < 95; ++ ch)
  {
    char_row0[ch] = row;
    char_col0[ch] = col;
    col += * char_widthP;
    if(col >= * char_widthP * 14)
    {
      col = * char_widthP * 2;
      row += * char_heightP;
    }
  }
}

void pbm_dumpfont(bit *  *  font , int fcols , int frows )
{
  int row , col , scol , lperrow ; /*decdef*/
  unsigned long l ; /*decdef*/
  printf("#define DEFAULTFONT_ROWS %d\n", frows);
  printf("#define DEFAULTFONT_COLS %d\n", fcols);
  printf("static unsigned long defaultfont_bits[DEFAULTFONT_ROWS][(DEFAULTFONT_COLS+31)/32] = {\n"
    );
  for(row = 0; row < frows; ++ row)
  {
    lperrow = 0;
    for(col = 0; col < fcols; col += 32)
    {
      if(lperrow == 0)
	printf("    {");
      else
      {
	if(lperrow % 6 == 0)
	{
	  printf(",\n     ");
	  lperrow = 0;
	}
	else
	  printf(",");
      }
      l = 0;
      for(scol = col; scol < (col + 32 < fcols ? col + 32 : fcols); ++ scol)
      {
	l <<= 1;
	if((font[row])[scol])
	  l |= 1;
      }
      printf("0x%08lxL", l);
      ++ lperrow;
    }
    printf("}%s\n", row == frows - 1 ? "" : ",");
  }
  printf("    };\n");
}


#pragma combiner("./libpgm1.i", "-g -O -I/home/scott/wrk/safec/cil/lib ")

#pragma boxalloc("malloc", nozero, sizein(0))

#pragma boxalloc("alloca", nozero, sizein(0))

#pragma boxalloc("calloc", zero, sizemul(0, 1))

#pragma boxprintf("printf", 0)

#pragma boxprintf("fprintf", 1)

#pragma boxprintf("sprintf", 1)

#pragma boxprintf("snprintf", 2)

#pragma boxpoly("memcpy")

#pragma boxexported("main")

#pragma boxprintf("pm_message", 0)

#pragma boxprintf("pm_error", 0)
typedef unsigned char gray ; /*typedef*/

void pgm_init(int *  argcP , char *  argv[] ) ; /*decdef*/
gray *  *  pgm_readpgm(FILE *  file , int *  colsP , int *  rowsP , gray * 
  maxvalP ) ; /*decdef*/
void pgm_readpgminit(FILE *  file , int *  colsP , int *  rowsP , gray * 
  maxvalP , int *  formatP ) ; /*decdef*/
void pgm_readpgmrow(FILE *  file , gray *  grayrow , int cols , gray maxval ,
  int format ) ; /*decdef*/
void pgm_writepgm(FILE *  file , gray *  *  grays , int cols , int rows , gray
  maxval , int forceplain ) ; /*decdef*/
void pgm_writepgminit(FILE *  file , int cols , int rows , gray maxval ,
  int forceplain ) ; /*decdef*/
void pgm_writepgmrow(FILE *  file , gray *  grayrow , int cols , gray maxval ,
  int forceplain ) ; /*decdef*/
extern gray pgm_pbmmaxval ; /*decdef*/
void pgm_readpgminitrest(FILE *  file , int *  colsP , int *  rowsP , gray * 
  maxvalP ) ; /*decdef*/

void pgm_init(int *  argcP , char *  argv[] )
{
  pbm_init(argcP, argv);
}

void pgm_readpgminitrest(FILE *  file , int *  colsP , int *  rowsP , gray * 
  maxvalP )
{
  int maxval ; /*decdef*/
  * colsP = pbm_getint(file);
  * rowsP = pbm_getint(file);
  maxval = pbm_getint(file);
  if(maxval > 255)
    pm_error("maxval is too large - try reconfiguring with PGM_BIGGRAYS");
  * maxvalP = maxval;
}

gray pgm_pbmmaxval = 1; /*decdef*/

void pgm_readpgminit(FILE *  file , int *  colsP , int *  rowsP , gray * 
  maxvalP , int *  formatP )
{
  * formatP = pbm_readmagicnumber(file);
  switch(* formatP == 'P' * 256 + '2' || * formatP == 'P' * 256 + '5' ? 'P' *
    256 + '2' : * formatP == 'P' * 256 + '1' || * formatP == 'P' * 256 + '4'
    ? 'P' * 256 + '1' : - 1)
  {
  case 'P' * 256 + '2':
      ;
    pgm_readpgminitrest(file, colsP, rowsP, maxvalP);
    break;
  case 'P' * 256 + '1':
      ;
    pbm_readpbminitrest(file, colsP, rowsP);
    * maxvalP = pgm_pbmmaxval;
    break;
  default :
      ;
    pm_error("bad magic number - not a pgm or pbm file");
  }
}

void pgm_readpgmrow(FILE *  file , gray *  grayrow , int cols , gray maxval ,
  int format )
{
  register int col ; /*decdef*/
  register gray *  gP ; /*decdef*/
  bit *  bitrow ; /*decdef*/
  register bit *  bP ; /*decdef*/
  switch(format)
  {
  case 'P' * 256 + '2':
      ;
    for(col = 0, gP = grayrow; col < cols; ++ col, ++ gP)
    {
      * gP = pbm_getint(file);
    }
    break;
  case 'P' * 256 + '5':
      ;
    for(col = 0, gP = grayrow; col < cols; ++ col, ++ gP)
    {
      * gP = pbm_getrawbyte(file);
    }
    break;
  case 'P' * 256 + '1':
      ;
  case 'P' * 256 + '4':
      ;
    bitrow = (bit *  )pm_allocrow(cols, sizeof(bit ));
    pbm_readpbmrow(file, bitrow, cols, format);
    for(col = 0, gP = grayrow, bP = bitrow; col < cols; ++ col, ++ gP, ++ bP)
      * gP = * bP == 0 ? maxval : 0;
    pm_freerow((char *  )bitrow);
    break;
  default :
      ;
    pm_error("can\'t happen");
  }
}

gray *  *  pgm_readpgm(FILE *  file , int *  colsP , int *  rowsP , gray * 
  maxvalP )
{
  gray *  *  grays ; /*decdef*/
  int row ; /*decdef*/
  int format ; /*decdef*/
  pgm_readpgminit(file, colsP, rowsP, maxvalP, & format);
  grays = (gray *  *  )pm_allocarray(* colsP, * rowsP, sizeof(gray ));
  for(row = 0; row < * rowsP; ++ row)
    pgm_readpgmrow(file, grays[row], * colsP, * maxvalP, format);
  return grays;
}


#pragma combiner("./libpgm2.i", "-g -O -I/home/scott/wrk/safec/cil/lib ")

#pragma boxalloc("malloc", nozero, sizein(0))

#pragma boxalloc("alloca", nozero, sizein(0))

#pragma boxalloc("calloc", zero, sizemul(0, 1))

#pragma boxprintf("printf", 0)

#pragma boxprintf("fprintf", 1)

#pragma boxprintf("sprintf", 1)

#pragma boxprintf("snprintf", 2)

#pragma boxpoly("memcpy")

#pragma boxexported("main")

#pragma boxprintf("pm_message", 0)

#pragma boxprintf("pm_error", 0)
void pgm_writepgminit(FILE *  file , int cols , int rows , gray maxval ,
  int forceplain )
{
  if(maxval <= 255 && ! forceplain)
    fprintf(file, "%c%c\n%d %d\n%d\n", 'P', '5', cols, rows, maxval);
  else
    fprintf(file, "%c%c\n%d %d\n%d\n", 'P', '2', cols, rows, maxval);
}

static void putus(unsigned short n , FILE *  file )
{
  if(n >= 10)
    putus(n / 10, file);
  (void )_IO_putc(n % 10 + '0', file);
}

static void pgm_writepgmrowraw(FILE *  file , gray *  grayrow , int cols , gray
  maxval )
{
  register int col ; /*decdef*/
  register gray *  gP ; /*decdef*/
  for(col = 0, gP = grayrow; col < cols; ++ col, ++ gP)
  {
    (void )_IO_putc(* gP, file);
  }
}

static void pgm_writepgmrowplain(FILE *  file , gray *  grayrow , int cols ,
  gray maxval )
{
  register int col , charcount ; /*decdef*/
  register gray *  gP ; /*decdef*/
  charcount = 0;
  for(col = 0, gP = grayrow; col < cols; ++ col, ++ gP)
  {
    if(charcount >= 65)
    {
      (void )_IO_putc('\n', file);
      charcount = 0;
    }
    else
    {
      if(charcount > 0)
      {
	(void )_IO_putc(' ', file);
	++ charcount;
      }
    }
    putus((unsigned long )(* gP), file);
    charcount += 3;
  }
  if(charcount > 0)
    (void )_IO_putc('\n', file);
}

void pgm_writepgmrow(FILE *  file , gray *  grayrow , int cols , gray maxval ,
  int forceplain )
{
  if(maxval <= 255 && ! forceplain)
    pgm_writepgmrowraw(file, grayrow, cols, maxval);
  else
    pgm_writepgmrowplain(file, grayrow, cols, maxval);
}

void pgm_writepgm(FILE *  file , gray *  *  grays , int cols , int rows , gray
  maxval , int forceplain )
{
  int row ; /*decdef*/
  pgm_writepgminit(file, cols, rows, maxval, forceplain);
  for(row = 0; row < rows; ++ row)
    pgm_writepgmrow(file, grays[row], cols, maxval, forceplain);
}


#pragma combiner("./libppm1.i", "-g -O -I/home/scott/wrk/safec/cil/lib ")

#pragma boxalloc("malloc", nozero, sizein(0))

#pragma boxalloc("alloca", nozero, sizein(0))

#pragma boxalloc("calloc", zero, sizemul(0, 1))

#pragma boxprintf("printf", 0)

#pragma boxprintf("fprintf", 1)

#pragma boxprintf("sprintf", 1)

#pragma boxprintf("snprintf", 2)

#pragma boxpoly("memcpy")

#pragma boxexported("main")

#pragma boxprintf("pm_message", 0)

#pragma boxprintf("pm_error", 0)
typedef gray pixval ; /*typedef*/

typedef struct  {
  pixval r , g , b ;
} pixel ; /*typedef*/

void ppm_init(int *  argcP , char *  argv[] ) ; /*decdef*/
pixel *  *  ppm_readppm(FILE *  file , int *  colsP , int *  rowsP , pixval * 
  maxvalP ) ; /*decdef*/
void ppm_readppminit(FILE *  file , int *  colsP , int *  rowsP , pixval * 
  maxvalP , int *  formatP ) ; /*decdef*/
void ppm_readppmrow(FILE *  file , pixel *  pixelrow , int cols , pixval maxval
  , int format ) ; /*decdef*/
void ppm_writeppm(FILE *  file , pixel *  *  pixels , int cols , int rows ,
  pixval maxval , int forceplain ) ; /*decdef*/
void ppm_writeppminit(FILE *  file , int cols , int rows , pixval maxval ,
  int forceplain ) ; /*decdef*/
void ppm_writeppmrow(FILE *  file , pixel *  pixelrow , int cols , pixval maxval
  , int forceplain ) ; /*decdef*/
pixel ppm_parsecolor(char *  colorname , pixval maxval ) ; /*decdef*/
char *  ppm_colorname(pixel *  colorP , pixval maxval , int hexok ) ; /*decdef*/
extern pixval ppm_pbmmaxval ; /*decdef*/
void ppm_readppminitrest(FILE *  file , int *  colsP , int *  rowsP , pixval * 
  maxvalP ) ; /*decdef*/

void ppm_init(int *  argcP , char *  argv[] )
{
  pgm_init(argcP, argv);
}

void ppm_readppminitrest(FILE *  file , int *  colsP , int *  rowsP , pixval * 
  maxvalP )
{
  int maxval ; /*decdef*/
  * colsP = pbm_getint(file);
  * rowsP = pbm_getint(file);
  maxval = pbm_getint(file);
  if(maxval > 255)
    pm_error("maxval is too large - try reconfiguring with PGM_BIGGRAYS\n    or without PPM_PACKCOLORS"
      );
  * maxvalP = maxval;
}

pixval ppm_pbmmaxval = 1; /*decdef*/

void ppm_readppminit(FILE *  file , int *  colsP , int *  rowsP , pixval * 
  maxvalP , int *  formatP )
{
  * formatP = pbm_readmagicnumber(file);
  switch(* formatP == 'P' * 256 + '3' || * formatP == 'P' * 256 + '6' ? 'P' *
    256 + '3' : * formatP == 'P' * 256 + '2' || * formatP == 'P' * 256 + '5'
    ? 'P' * 256 + '2' : * formatP == 'P' * 256 + '1' || * formatP == 'P' * 256 +
    '4' ? 'P' * 256 + '1' : - 1)
  {
  case 'P' * 256 + '3':
      ;
    ppm_readppminitrest(file, colsP, rowsP, maxvalP);
    break;
  case 'P' * 256 + '2':
      ;
    pgm_readpgminitrest(file, colsP, rowsP, maxvalP);
    break;
  case 'P' * 256 + '1':
      ;
    pbm_readpbminitrest(file, colsP, rowsP);
    * maxvalP = ppm_pbmmaxval;
    break;
  default :
      ;
    pm_error("bad magic number - not a ppm, pgm, or pbm file");
  }
}

void ppm_readppmrow(FILE *  file , pixel *  pixelrow , int cols , pixval maxval
  , int format )
{
  register int col ; /*decdef*/
  register pixel *  pP ; /*decdef*/
  register pixval r , g , b ; /*decdef*/
  gray *  grayrow ; /*decdef*/
  register gray *  gP ; /*decdef*/
  bit *  bitrow ; /*decdef*/
  register bit *  bP ; /*decdef*/
  switch(format)
  {
  case 'P' * 256 + '3':
      ;
    for(col = 0, pP = pixelrow; col < cols; ++ col, ++ pP)
    {
      r = pbm_getint(file);
      g = pbm_getint(file);
      b = pbm_getint(file);
      do
      {
	(* pP).r = r;
	(* pP).g = g;
	(* pP).b = b;
      }
      while(0);
    }
    break;
  case 'P' * 256 + '6':
      ;
    for(col = 0, pP = pixelrow; col < cols; ++ col, ++ pP)
    {
      r = pbm_getrawbyte(file);
      g = pbm_getrawbyte(file);
      b = pbm_getrawbyte(file);
      do
      {
	(* pP).r = r;
	(* pP).g = g;
	(* pP).b = b;
      }
      while(0);
    }
    break;
  case 'P' * 256 + '2':
      ;
  case 'P' * 256 + '5':
      ;
    grayrow = (gray *  )pm_allocrow(cols, sizeof(gray ));
    pgm_readpgmrow(file, grayrow, cols, maxval, format);
    for(col = 0, gP = grayrow, pP = pixelrow; col < cols; ++ col, ++ gP, ++ pP)
    {
      r = * gP;
      do
      {
	(* pP).r = r;
	(* pP).g = r;
	(* pP).b = r;
      }
      while(0);
    }
    pm_freerow((char *  )grayrow);
    break;
  case 'P' * 256 + '1':
      ;
  case 'P' * 256 + '4':
      ;
    bitrow = (bit *  )pm_allocrow(cols, sizeof(bit ));
    pbm_readpbmrow(file, bitrow, cols, format);
    for(col = 0, bP = bitrow, pP = pixelrow; col < cols; ++ col, ++ bP, ++ pP)
    {
      r = * bP == 0 ? maxval : 0;
      do
      {
	(* pP).r = r;
	(* pP).g = r;
	(* pP).b = r;
      }
      while(0);
    }
    pm_freerow((char *  )bitrow);
    break;
  default :
      ;
    pm_error("can\'t happen");
  }
}

pixel *  *  ppm_readppm(FILE *  file , int *  colsP , int *  rowsP , pixval * 
  maxvalP )
{
  pixel *  *  pixels ; /*decdef*/
  int row ; /*decdef*/
  int format ; /*decdef*/
  ppm_readppminit(file, colsP, rowsP, maxvalP, & format);
  pixels = (pixel *  *  )pm_allocarray(* colsP, * rowsP, sizeof(pixel ));
  for(row = 0; row < * rowsP; ++ row)
    ppm_readppmrow(file, pixels[row], * colsP, * maxvalP, format);
  return pixels;
}


#pragma combiner("./libppm2.i", "-g -O -I/home/scott/wrk/safec/cil/lib ")

#pragma boxalloc("malloc", nozero, sizein(0))

#pragma boxalloc("alloca", nozero, sizein(0))

#pragma boxalloc("calloc", zero, sizemul(0, 1))

#pragma boxprintf("printf", 0)

#pragma boxprintf("fprintf", 1)

#pragma boxprintf("sprintf", 1)

#pragma boxprintf("snprintf", 2)

#pragma boxpoly("memcpy")

#pragma boxexported("main")

#pragma boxprintf("pm_message", 0)

#pragma boxprintf("pm_error", 0)
void ppm_writeppminit(FILE *  file , int cols , int rows , pixval maxval ,
  int forceplain )
{
  if(maxval <= 255 && ! forceplain)
    fprintf(file, "%c%c\n%d %d\n%d\n", 'P', '6', cols, rows, maxval);
  else
    fprintf(file, "%c%c\n%d %d\n%d\n", 'P', '3', cols, rows, maxval);
}

static void putus__0(unsigned short n , FILE *  file )
{
  if(n >= 10)
    putus__0(n / 10, file);
  (void )_IO_putc(n % 10 + '0', file);
}

static void ppm_writeppmrowraw(FILE *  file , pixel *  pixelrow , int cols ,
  pixval maxval )
{
  register int col ; /*decdef*/
  register pixel *  pP ; /*decdef*/
  register pixval val ; /*decdef*/
  for(col = 0, pP = pixelrow; col < cols; ++ col, ++ pP)
  {
    val = (* pP).r;
    (void )_IO_putc(val, file);
    val = (* pP).g;
    (void )_IO_putc(val, file);
    val = (* pP).b;
    (void )_IO_putc(val, file);
  }
}

static void ppm_writeppmrowplain(FILE *  file , pixel *  pixelrow , int cols ,
  pixval maxval )
{
  register int col , charcount ; /*decdef*/
  register pixel *  pP ; /*decdef*/
  register pixval val ; /*decdef*/
  charcount = 0;
  for(col = 0, pP = pixelrow; col < cols; ++ col, ++ pP)
  {
    if(charcount >= 65)
    {
      (void )_IO_putc('\n', file);
      charcount = 0;
    }
    else
    {
      if(charcount > 0)
      {
	(void )_IO_putc(' ', file);
	(void )_IO_putc(' ', file);
	charcount += 2;
      }
    }
    val = (* pP).r;
    putus__0(val, file);
    (void )_IO_putc(' ', file);
    val = (* pP).g;
    putus__0(val, file);
    (void )_IO_putc(' ', file);
    val = (* pP).b;
    putus__0(val, file);
    charcount += 11;
  }
  if(charcount > 0)
    (void )_IO_putc('\n', file);
}

void ppm_writeppmrow(FILE *  file , pixel *  pixelrow , int cols , pixval maxval
  , int forceplain )
{
  if(maxval <= 255 && ! forceplain)
    ppm_writeppmrowraw(file, pixelrow, cols, maxval);
  else
    ppm_writeppmrowplain(file, pixelrow, cols, maxval);
}

void ppm_writeppm(FILE *  file , pixel *  *  pixels , int cols , int rows ,
  pixval maxval , int forceplain )
{
  int row ; /*decdef*/
  ppm_writeppminit(file, cols, rows, maxval, forceplain);
  for(row = 0; row < rows; ++ row)
    ppm_writeppmrow(file, pixels[row], cols, maxval, forceplain);
}


#pragma combiner("./libppm3.i", "-g -O -I/home/scott/wrk/safec/cil/lib ")

#pragma boxalloc("malloc", nozero, sizein(0))

#pragma boxalloc("alloca", nozero, sizein(0))

#pragma boxalloc("calloc", zero, sizemul(0, 1))

#pragma boxprintf("printf", 0)

#pragma boxprintf("fprintf", 1)

#pragma boxprintf("sprintf", 1)

#pragma boxprintf("snprintf", 2)

#pragma boxpoly("memcpy")

#pragma boxexported("main")

#pragma boxprintf("pm_message", 0)

#pragma boxprintf("pm_error", 0)
typedef struct colorhist_item *  colorhist_vector ; /*typedef*/

struct colorhist_item {
  pixel color ;
  int value ;
} ; /*onlytypedef*/

typedef struct colorhist_list_item *  colorhist_list ; /*typedef*/

struct colorhist_list_item {
  struct colorhist_item ch ;
  colorhist_list next ;
} ; /*onlytypedef*/

colorhist_vector ppm_computecolorhist(pixel *  *  pixels , int cols , int rows ,
  int maxcolors , int *  colorsP ) ; /*decdef*/
void ppm_addtocolorhist(colorhist_vector chv , int *  colorsP , int maxcolors ,
  pixel *  colorP , int value , int position ) ; /*decdef*/
void ppm_freecolorhist(colorhist_vector chv ) ; /*decdef*/

typedef colorhist_list *  colorhash_table ; /*typedef*/

colorhash_table ppm_computecolorhash(pixel *  *  pixels , int cols , int rows ,
  int maxcolors , int *  colorsP ) ; /*decdef*/
int ppm_lookupcolor(colorhash_table cht , pixel *  colorP ) ; /*decdef*/
colorhist_vector ppm_colorhashtocolorhist(colorhash_table cht , int maxcolors )
  ; /*decdef*/
colorhash_table ppm_colorhisttocolorhash(colorhist_vector chv , int colors )
  ; /*decdef*/
int ppm_addtocolorhash(colorhash_table cht , pixel *  colorP , int value )
  ; /*decdef*/
colorhash_table ppm_alloccolorhash(void  ) ; /*decdef*/
void ppm_freecolorhash(colorhash_table cht ) ; /*decdef*/

colorhist_vector ppm_computecolorhist(pixel *  *  pixels , int cols , int rows ,
  int maxcolors , int *  colorsP )
{
  colorhash_table cht ; /*decdef*/
  colorhist_vector chv ; /*decdef*/
  cht = ppm_computecolorhash(pixels, cols, rows, maxcolors, colorsP);
  if(cht == (colorhash_table )0)
    return (colorhist_vector )0;
  chv = ppm_colorhashtocolorhist(cht, maxcolors);
  ppm_freecolorhash(cht);
  return chv;
}

void ppm_addtocolorhist(colorhist_vector chv , int *  colorsP , int maxcolors ,
  pixel *  colorP , int value , int position )
{
  int i , j ; /*decdef*/
  for(i = 0; i < * colorsP; ++ i)
  {
    if(((chv[i]).color).r == (* colorP).r && ((chv[i]).color).g == (* colorP).g
      && ((chv[i]).color).b == (* colorP).b)
    {
      if(position > i)
      {
	for(j = i; j < position; ++ j)
	  chv[j] = chv[j + 1];
      }
      else
      {
	if(position < i)
	{
	  for(j = i; j > position; -- j)
	    chv[j] = chv[j - 1];
	}
      }
      (chv[position]).color = * colorP;
      (chv[position]).value = value;
      return;
    }
  }
  if(* colorsP < maxcolors)
  {
    for(i = * colorsP; i > position; -- i)
      chv[i] = chv[i - 1];
    (chv[position]).color = * colorP;
    (chv[position]).value = value;
    ++ * colorsP;
  }
}

colorhash_table ppm_computecolorhash(pixel *  *  pixels , int cols , int rows ,
  int maxcolors , int *  colorsP )
{
  colorhash_table cht ; /*decdef*/
  register pixel *  pP ; /*decdef*/
  colorhist_list chl ; /*decdef*/
  int col , row , hash ; /*decdef*/
  cht = ppm_alloccolorhash();
  * colorsP = 0;
  for(row = 0; row < rows; ++ row)
    for(col = 0, pP = pixels[row]; col < cols; ++ col, ++ pP)
    {
      hash = ((long )(* pP).r * 33023 + (long )(* pP).g * 30013 + (long )(*
	pP).b * 27011 & 0x7fffffff) % 20023;
      for(chl = cht[hash]; chl != (colorhist_list )0; chl = chl->next)
      {
	if(((chl->ch).color).r == (* pP).r && ((chl->ch).color).g == (* pP).g &&
	  ((chl->ch).color).b == (* pP).b)
	  break;
      }
      if(chl != (colorhist_list )0)
	++ (chl->ch).value;
      else
      {
	if(++ * colorsP > maxcolors)
	{
	  ppm_freecolorhash(cht);
	  return (colorhash_table )0;
	}
	chl = (colorhist_list )malloc(sizeof(* chl));
	if(chl == 0)
	  pm_error("out of memory computing hash table");
	(chl->ch).color = * pP;
	(chl->ch).value = 1;
	chl->next = cht[hash];
	cht[hash] = chl;
      }
    }
  return cht;
}

colorhash_table ppm_alloccolorhash()
{
  colorhash_table cht ; /*decdef*/
  int i ; /*decdef*/
  cht = (colorhash_table )malloc(20023 * sizeof(* cht));
  if(cht == 0)
    pm_error("out of memory allocating hash table");
  for(i = 0; i < 20023; ++ i)
    cht[i] = (colorhist_list )0;
  return cht;
}

int ppm_addtocolorhash(colorhash_table cht , pixel *  colorP , int value )
{
  register int hash ; /*decdef*/
  register colorhist_list chl ; /*decdef*/
  chl = (colorhist_list )malloc(sizeof(* chl));
  if(chl == 0)
    return - 1;
  hash = ((long )(* colorP).r * 33023 + (long )(* colorP).g * 30013 + (long )(*
    colorP).b * 27011 & 0x7fffffff) % 20023;
  (chl->ch).color = * colorP;
  (chl->ch).value = value;
  chl->next = cht[hash];
  cht[hash] = chl;
  return 0;
}

colorhist_vector ppm_colorhashtocolorhist(colorhash_table cht , int maxcolors )
{
  colorhist_vector chv ; /*decdef*/
  colorhist_list chl ; /*decdef*/
  int i , j ; /*decdef*/
  chv = (colorhist_vector )malloc(maxcolors * sizeof(* chv));
  if(chv == (colorhist_vector )0)
    pm_error("out of memory generating histogram");
  j = 0;
  for(i = 0; i < 20023; ++ i)
    for(chl = cht[i]; chl != (colorhist_list )0; chl = chl->next)
    {
      chv[j] = chl->ch;
      ++ j;
    }
  return chv;
}

colorhash_table ppm_colorhisttocolorhash(colorhist_vector chv , int colors )
{
  colorhash_table cht ; /*decdef*/
  int i , hash ; /*decdef*/
  pixel color ; /*decdef*/
  colorhist_list chl ; /*decdef*/
  cht = ppm_alloccolorhash();
  for(i = 0; i < colors; ++ i)
  {
    color = (chv[i]).color;
    hash = ((long )color.r * 33023 + (long )color.g * 30013 + (long )color.b *
      27011 & 0x7fffffff) % 20023;
    for(chl = cht[hash]; chl != (colorhist_list )0; chl = chl->next)
    {
      if(((chl->ch).color).r == color.r && ((chl->ch).color).g == color.g &&
	((chl->ch).color).b == color.b)
	pm_error("same color found twice - %d %d %d", color.r, color.g,
	  color.b);
    }
    chl = (colorhist_list )malloc(sizeof(* chl));
    if(chl == (colorhist_list )0)
      pm_error("out of memory");
    (chl->ch).color = color;
    (chl->ch).value = i;
    chl->next = cht[hash];
    cht[hash] = chl;
  }
  return cht;
}

int ppm_lookupcolor(colorhash_table cht , pixel *  colorP )
{
  int hash ; /*decdef*/
  colorhist_list chl ; /*decdef*/
  hash = ((long )(* colorP).r * 33023 + (long )(* colorP).g * 30013 + (long )(*
    colorP).b * 27011 & 0x7fffffff) % 20023;
  for(chl = cht[hash]; chl != (colorhist_list )0; chl = chl->next)
  {
    if(((chl->ch).color).r == (* colorP).r && ((chl->ch).color).g == (*
      colorP).g && ((chl->ch).color).b == (* colorP).b)
      return (chl->ch).value;
  }
  return - 1;
}

void ppm_freecolorhist(colorhist_vector chv )
{
  free((char *  )chv);
}

void ppm_freecolorhash(colorhash_table cht )
{
  int i ; /*decdef*/
  colorhist_list chl , chlnext ; /*decdef*/
  for(i = 0; i < 20023; ++ i)
    for(chl = cht[i]; chl != (colorhist_list )0; chl = chlnext)
    {
      chlnext = chl->next;
      free((char *  )chl);
    }
  free((char *  )cht);
}


#pragma combiner("./libppm4.i", "-g -O -I/home/scott/wrk/safec/cil/lib ")

#pragma boxalloc("malloc", nozero, sizein(0))

#pragma boxalloc("alloca", nozero, sizein(0))

#pragma boxalloc("calloc", zero, sizemul(0, 1))

#pragma boxprintf("printf", 0)

#pragma boxprintf("fprintf", 1)

#pragma boxprintf("sprintf", 1)

#pragma boxprintf("snprintf", 2)

#pragma boxpoly("memcpy")

#pragma boxexported("main")

#pragma boxprintf("pm_message", 0)

#pragma boxprintf("pm_error", 0)
static void canonstr(char *  str )
{
  while(* str != '\0')
  {
    if(* str == ' ')
    {
      (void )strcpy(str, & str[1]);
      continue;
    }
    if(_get__ctype_b((int )(* str)) & (unsigned short int )_ISupper)
      * str = tolower(* str);
    ++ str;
  }
}

static long rgbnorm(long rgb , long lmaxval , int n , char *  colorname )
{
  switch(n)
  {
  case 1:
      ;
    if(lmaxval != 15)
      rgb = rgb * lmaxval / 15;
    break;
  case 2:
      ;
    if(lmaxval != 255)
      rgb = rgb * lmaxval / 255;
    break;
  case 3:
      ;
    if(lmaxval != 4095)
      rgb = rgb * lmaxval / 4095;
    break;
  case 4:
      ;
    if(lmaxval != 65535L)
      rgb = rgb * lmaxval / 65535L;
    break;
  default :
      ;
    pm_error("invalid color specifier - \"%s\"", colorname);
  }
  return rgb;
}

pixel ppm_parsecolor(char *  colorname , pixval maxval )
{
  int hexit[256] , i ; /*decdef*/
  pixel p ; /*decdef*/
  long lmaxval , r , g , b ; /*decdef*/
  char *  inval = "invalid color specifier - \"%s\""; /*decdef*/
  for(i = 0; i < 256; ++ i)
    hexit[i] = 1234567890;
  hexit['0'] = 0;
  hexit['1'] = 1;
  hexit['2'] = 2;
  hexit['3'] = 3;
  hexit['4'] = 4;
  hexit['5'] = 5;
  hexit['6'] = 6;
  hexit['7'] = 7;
  hexit['8'] = 8;
  hexit['9'] = 9;
  hexit['a'] = (hexit['A'] = 10);
  hexit['b'] = (hexit['B'] = 11);
  hexit['c'] = (hexit['C'] = 12);
  hexit['d'] = (hexit['D'] = 13);
  hexit['e'] = (hexit['E'] = 14);
  hexit['f'] = (hexit['F'] = 15);
  lmaxval = maxval;
  if(strncmp(colorname, "rgb:", 4) == 0)
  {
    char *  cp ; /*decdef*/
    cp = colorname + 4;
    r = (g = (b = 0));
    for(i = 0; * cp != '/'; ++ i, ++ cp)
      r = r * 16 + hexit[* cp];
    r = rgbnorm(r, lmaxval, i, colorname);
    for(i = 0, ++ cp; * cp != '/'; ++ i, ++ cp)
      g = g * 16 + hexit[* cp];
    g = rgbnorm(g, lmaxval, i, colorname);
    for(i = 0, ++ cp; * cp != '\0'; ++ i, ++ cp)
      b = b * 16 + hexit[* cp];
    b = rgbnorm(b, lmaxval, i, colorname);
    if(r < 0 || r > lmaxval || g < 0 || g > lmaxval || b < 0 || b > lmaxval)
      pm_error(inval, colorname);
  }
  else
  {
    if(strncmp(colorname, "rgbi:", 5) == 0)
    {
      float fr , fg , fb ; /*decdef*/
      if(sscanf(colorname, "rgbi:%f/%f/%f", & fr, & fg, & fb) != 3)
	pm_error(inval, colorname);
      if(fr < 0.0 || fr > 1.0 || fg < 0.0 || fg > 1.0 || fb < 0.0 || fb > 1.0)
	pm_error("invalid color specifier - \"%s\" - values must be between 0.0 and 1.0"
	  , colorname);
      r = fr * lmaxval;
      g = fg * lmaxval;
      b = fb * lmaxval;
    }
    else
    {
      if(colorname[0] == '#')
      {
	switch(strlen(colorname))
	{
	case 4:
	    ;
	  r = hexit[colorname[1]];
	  g = hexit[colorname[2]];
	  b = hexit[colorname[3]];
	  r = rgbnorm(r, lmaxval, 1, colorname);
	  g = rgbnorm(g, lmaxval, 1, colorname);
	  b = rgbnorm(b, lmaxval, 1, colorname);
	  break;
	case 7:
	    ;
	  r = (hexit[colorname[1]] << 4) + hexit[colorname[2]];
	  g = (hexit[colorname[3]] << 4) + hexit[colorname[4]];
	  b = (hexit[colorname[5]] << 4) + hexit[colorname[6]];
	  r = rgbnorm(r, lmaxval, 2, colorname);
	  g = rgbnorm(g, lmaxval, 2, colorname);
	  b = rgbnorm(b, lmaxval, 2, colorname);
	  break;
	case 10:
	    ;
	  r = (hexit[colorname[1]] << 8) + (hexit[colorname[2]] << 4) +
	    hexit[colorname[3]];
	  g = (hexit[colorname[4]] << 8) + (hexit[colorname[5]] << 4) +
	    hexit[colorname[6]];
	  b = (hexit[colorname[7]] << 8) + (hexit[colorname[8]] << 4) +
	    hexit[colorname[9]];
	  r = rgbnorm(r, lmaxval, 3, colorname);
	  g = rgbnorm(g, lmaxval, 3, colorname);
	  b = rgbnorm(b, lmaxval, 3, colorname);
	  break;
	case 13:
	    ;
	  r = (hexit[colorname[1]] << 12) + (hexit[colorname[2]] << 8) +
	    (hexit[colorname[3]] << 4) + hexit[colorname[4]];
	  g = (hexit[colorname[5]] << 12) + (hexit[colorname[6]] << 8) +
	    (hexit[colorname[7]] << 4) + hexit[colorname[8]];
	  b = (hexit[colorname[9]] << 12) + (hexit[colorname[10]] << 8) +
	    (hexit[colorname[11]] << 4) + hexit[colorname[12]];
	  r = rgbnorm(r, lmaxval, 4, colorname);
	  g = rgbnorm(g, lmaxval, 4, colorname);
	  b = rgbnorm(b, lmaxval, 4, colorname);
	  break;
	default :
	    ;
	  pm_error(inval, colorname);
	}
	if(r < 0 || r > lmaxval || g < 0 || g > lmaxval || b < 0 || b > lmaxval)
	  pm_error(inval, colorname);
      }
      else
      {
	if(colorname[0] >= '0' && colorname[0] <= '9' || colorname[0] == '.')
	{
	  float fr , fg , fb ; /*decdef*/
	  if(sscanf(colorname, "%f,%f,%f", & fr, & fg, & fb) != 3)
	    pm_error(inval, colorname);
	  if(fr < 0.0 || fr > 1.0 || fg < 0.0 || fg > 1.0 || fb < 0.0 || fb >
	    1.0)
	    pm_error("invalid color specifier - \"%s\" - values must be between 0.0 and 1.0"
	      , colorname);
	  r = fr * lmaxval;
	  g = fg * lmaxval;
	  b = fb * lmaxval;
	}
	else
	{
	  pm_error("color names database required - please reconfigure with RGBDEF"
	    );
	}
      }
    }
  }
  do
  {
    p.r = r;
    p.g = g;
    p.b = b;
  }
  while(0);
  return p;
}

static char colorname[200] ; /*decdef*/

char *  ppm_colorname(pixel *  colorP , pixval maxval , int hexok )
{
  int r , g , b ; /*decdef*/
  if(maxval == 255)
  {
    r = (* colorP).r;
    g = (* colorP).g;
    b = (* colorP).b;
  }
  else
  {
    r = (int )(* colorP).r * 255 / (int )maxval;
    g = (int )(* colorP).g * 255 / (int )maxval;
    b = (int )(* colorP).b * 255 / (int )maxval;
  }
  if(! hexok)
    pm_error("color names database required - please reconfigure with RGBDEF");
  sprintf(colorname, "#%02x%02x%02x", r, g, b);
  return colorname;
}


#pragma combiner("./libppm5.i", "-g -O -I/home/scott/wrk/safec/cil/lib ")

#pragma boxalloc("malloc", nozero, sizein(0))

#pragma boxalloc("alloca", nozero, sizein(0))

#pragma boxalloc("calloc", zero, sizemul(0, 1))

#pragma boxprintf("printf", 0)

#pragma boxprintf("fprintf", 1)

#pragma boxprintf("sprintf", 1)

#pragma boxprintf("snprintf", 2)

#pragma boxpoly("memcpy")

#pragma boxexported("main")

#pragma boxprintf("pm_message", 0)

#pragma boxprintf("pm_error", 0)
void ppmd_point_drawproc(pixel *  *  pixels , int cols , int rows , pixval
  maxval , int x , int y , char *  clientdata ) ; /*decdef*/
int ppmd_setlinetype(int type ) ; /*decdef*/
int ppmd_setlineclipping(int clip ) ; /*decdef*/
void ppmd_line(pixel *  *  pixels , int cols , int rows , pixval maxval , int x0
  , int y0 , int x1 , int y1 , void ( *  drawprocP )(pixel *  *  , int  , int  ,
  pixval , int  , int  , char *  ) , char *  clientdata ) ; /*decdef*/
void ppmd_spline3(pixel *  *  pixels , int cols , int rows , pixval maxval ,
  int x0 , int y0 , int x1 , int y1 , int x2 , int y2 , void ( *  drawprocP
  )(pixel *  *  , int  , int  , pixval , int  , int  , char *  ) , char * 
  clientdata ) ; /*decdef*/
void ppmd_polyspline(pixel *  *  pixels , int cols , int rows , pixval maxval ,
  int x0 , int y0 , int nc , int *  xc , int *  yc , int x1 , int y1 , void ( * 
  drawprocP )(pixel *  *  , int  , int  , pixval , int  , int  , char *  ) ,
  char *  clientdata ) ; /*decdef*/
void ppmd_circle(pixel *  *  pixels , int cols , int rows , pixval maxval ,
  int cx , int cy , int radius , void ( *  drawprocP )(pixel *  *  , int  , int 
  , pixval , int  , int  , char *  ) , char *  clientdata ) ; /*decdef*/
void ppmd_filledrectangle(pixel *  *  pixels , int cols , int rows , pixval
  maxval , int x , int y , int width , int height , void ( *  drawprocP )(pixel
  *  *  , int  , int  , pixval , int  , int  , char *  ) , char *  clientdata )
  ; /*decdef*/
char *  ppmd_fill_init() ; /*decdef*/
void ppmd_fill_drawproc(pixel *  *  pixels , int cols , int rows , pixval maxval
  , int x , int y , char *  clientdata ) ; /*decdef*/
void ppmd_fill(pixel *  *  pixels , int cols , int rows , pixval maxval ,
  char *  fillhandle , void ( *  drawprocP )(pixel *  *  , int  , int  , pixval
  , int  , int  , char *  ) , char *  clientdata ) ; /*decdef*/

void ppmd_point_drawproc(pixel *  *  pixels , int cols , int rows , pixval
  maxval , int x , int y , char *  clientdata )
{
  if(x >= 0 && x < cols && y >= 0 && y < rows)
    (pixels[y])[x] = * (pixel *  )clientdata;
}

void ppmd_filledrectangle(pixel *  *  pixels , int cols , int rows , pixval
  maxval , int x , int y , int width , int height , void ( *  drawprocP )(pixel
  *  *  , int  , int  , pixval , int  , int  , char *  ) , char *  clientdata )
{
  register int cx , cy , cwidth , cheight , col , row ; /*decdef*/
  cx = x;
  cy = y;
  cwidth = width;
  cheight = height;
  if(cx < 0)
  {
    cx = 0;
    cwidth += x;
  }
  if(cy < 0)
  {
    cy = 0;
    cheight += y;
  }
  if(cx + cwidth > cols)
    cwidth = cols - cx;
  if(cy + cheight > rows)
    cheight = rows - cy;
  for(row = cy; row < cy + cheight; ++ row)
    for(col = cx; col < cx + cwidth; ++ col)
    {
      if(drawprocP == (void ( *  )(pixel *  *  , int  , int  , pixval , int  ,
	int  , char *  ))0)
	(pixels[row])[col] = * (pixel *  )clientdata;
      else
	(* drawprocP)(pixels, cols, rows, maxval, col, row, clientdata);
    }
}

static int ppmd_linetype = 0; /*decdef*/

int ppmd_setlinetype(int type )
{
  int old ; /*decdef*/
  old = ppmd_linetype;
  ppmd_linetype = type;
  return old;
}

static int ppmd_lineclip = 1; /*decdef*/

int ppmd_setlineclip(int clip )
{
  int old ; /*decdef*/
  old = ppmd_lineclip;
  ppmd_lineclip = clip;
  return old;
}

void ppmd_line(pixel *  *  pixels , int cols , int rows , pixval maxval , int x0
  , int y0 , int x1 , int y1 , void ( *  drawprocP )(pixel *  *  , int  , int  ,
  pixval , int  , int  , char *  ) , char *  clientdata )
{
  register int cx0 , cy0 , cx1 , cy1 ; /*decdef*/
  if(x0 == x1 && y0 == y1)
  {
    if(! ppmd_lineclip || x0 >= 0 && x0 < cols && y0 >= 0 && y0 < rows)
    {
      if(drawprocP == (void ( *  )(pixel *  *  , int  , int  , pixval , int  ,
	int  , char *  ))0)
	ppmd_point_drawproc(pixels, cols, rows, maxval, x0, y0, clientdata);
      else
	(* drawprocP)(pixels, cols, rows, maxval, x0, y0, clientdata);
    }
    return;
  }
  cx0 = x0;
  cy0 = y0;
  cx1 = x1;
  cy1 = y1;
  if(ppmd_lineclip)
  {
    if(cx0 < 0)
    {
      if(cx1 < 0)
	return;
      cy0 = cy0 + (cy1 - cy0) * - cx0 / (cx1 - cx0);
      cx0 = 0;
    }
    else
    {
      if(cx0 >= cols)
      {
	if(cx1 >= cols)
	  return;
	cy0 = cy0 + (cy1 - cy0) * (cols - 1 - cx0) / (cx1 - cx0);
	cx0 = cols - 1;
      }
    }
    if(cy0 < 0)
    {
      if(cy1 < 0)
	return;
      cx0 = cx0 + (cx1 - cx0) * - cy0 / (cy1 - cy0);
      cy0 = 0;
    }
    else
    {
      if(cy0 >= rows)
      {
	if(cy1 >= rows)
	  return;
	cx0 = cx0 + (cx1 - cx0) * (rows - 1 - cy0) / (cy1 - cy0);
	cy0 = rows - 1;
      }
    }
    if(cx1 < 0)
    {
      cy1 = cy1 + (cy0 - cy1) * - cx1 / (cx0 - cx1);
      cx1 = 0;
    }
    else
    {
      if(cx1 >= cols)
      {
	cy1 = cy1 + (cy0 - cy1) * (cols - 1 - cx1) / (cx0 - cx1);
	cx1 = cols - 1;
      }
    }
    if(cy1 < 0)
    {
      cx1 = cx1 + (cx0 - cx1) * - cy1 / (cy0 - cy1);
      cy1 = 0;
    }
    else
    {
      if(cy1 >= rows)
      {
	cx1 = cx1 + (cx0 - cx1) * (rows - 1 - cy1) / (cy0 - cy1);
	cy1 = rows - 1;
      }
    }
    if(cx0 == cx1 && cy0 == cy1)
    {
      if(drawprocP == (void ( *  )(pixel *  *  , int  , int  , pixval , int  ,
	int  , char *  ))0)
	ppmd_point_drawproc(pixels, cols, rows, maxval, cx0, cy0, clientdata);
      else
	(* drawprocP)(pixels, cols, rows, maxval, cx0, cy0, clientdata);
      return;
    }
  }
  if((cx1 - cx0 >= 0 ? cx1 - cx0 : - (cx1 - cx0)) > (cy1 - cy0 >= 0 ? cy1 - cy0
    : - (cy1 - cy0)))
  {
    register long dy , srow ; /*decdef*/
    register int dx , col , row , prevrow ; /*decdef*/
    if(cx1 > cx0)
      dx = 1;
    else
      dx = - 1;
    dy = (cy1 - cy0) * 8192 / (cx1 - cx0 >= 0 ? cx1 - cx0 : - (cx1 - cx0));
    prevrow = (row = cy0);
    srow = row * 8192 + 8192 / 2;
    col = cx0;
    for(; ; )
    {
      if(ppmd_linetype == 1 && row != prevrow)
      {
	if(drawprocP == (void ( *  )(pixel *  *  , int  , int  , pixval , int  ,
	  int  , char *  ))0)
	  (pixels[prevrow])[col] = * (pixel *  )clientdata;
	else
	  (* drawprocP)(pixels, cols, rows, maxval, col, prevrow, clientdata);
	prevrow = row;
      }
      if(drawprocP == (void ( *  )(pixel *  *  , int  , int  , pixval , int  ,
	int  , char *  ))0)
	(pixels[row])[col] = * (pixel *  )clientdata;
      else
	(* drawprocP)(pixels, cols, rows, maxval, col, row, clientdata);
      if(col == cx1)
	break;
      srow += dy;
      row = srow / 8192;
      col += dx;
    }
  }
  else
  {
    register long dx , scol ; /*decdef*/
    register int dy , col , row , prevcol ; /*decdef*/
    if(cy1 > cy0)
      dy = 1;
    else
      dy = - 1;
    dx = (cx1 - cx0) * 8192 / (cy1 - cy0 >= 0 ? cy1 - cy0 : - (cy1 - cy0));
    row = cy0;
    prevcol = (col = cx0);
    scol = col * 8192 + 8192 / 2;
    for(; ; )
    {
      if(ppmd_linetype == 1 && col != prevcol)
      {
	if(drawprocP == (void ( *  )(pixel *  *  , int  , int  , pixval , int  ,
	  int  , char *  ))0)
	  (pixels[row])[prevcol] = * (pixel *  )clientdata;
	else
	  (* drawprocP)(pixels, cols, rows, maxval, prevcol, row, clientdata);
	prevcol = col;
      }
      if(drawprocP == (void ( *  )(pixel *  *  , int  , int  , pixval , int  ,
	int  , char *  ))0)
	(pixels[row])[col] = * (pixel *  )clientdata;
      else
	(* drawprocP)(pixels, cols, rows, maxval, col, row, clientdata);
      if(row == cy1)
	break;
      row += dy;
      scol += dx;
      col = scol / 8192;
    }
  }
}

void ppmd_spline3(pixel *  *  pixels , int cols , int rows , pixval maxval ,
  int x0 , int y0 , int x1 , int y1 , int x2 , int y2 , void ( *  drawprocP
  )(pixel *  *  , int  , int  , pixval , int  , int  , char *  ) , char * 
  clientdata )
{
  register int xa , ya , xb , yb , xc , yc , xp , yp ; /*decdef*/
  xa = (x0 + x1) / 2;
  ya = (y0 + y1) / 2;
  xc = (x1 + x2) / 2;
  yc = (y1 + y2) / 2;
  xb = (xa + xc) / 2;
  yb = (ya + yc) / 2;
  xp = (x0 + xb) / 2;
  yp = (y0 + yb) / 2;
  if((xa - xp >= 0 ? xa - xp : - (xa - xp)) + (ya - yp >= 0 ? ya - yp : - (ya -
    yp)) > 3)
    ppmd_spline3(pixels, cols, rows, maxval, x0, y0, xa, ya, xb, yb, drawprocP,
      clientdata);
  else
    ppmd_line(pixels, cols, rows, maxval, x0, y0, xb, yb, drawprocP,
      clientdata);
  xp = (x2 + xb) / 2;
  yp = (y2 + yb) / 2;
  if((xc - xp >= 0 ? xc - xp : - (xc - xp)) + (yc - yp >= 0 ? yc - yp : - (yc -
    yp)) > 3)
    ppmd_spline3(pixels, cols, rows, maxval, xb, yb, xc, yc, x2, y2, drawprocP,
      clientdata);
  else
    ppmd_line(pixels, cols, rows, maxval, xb, yb, x2, y2, drawprocP,
      clientdata);
}

void ppmd_polyspline(pixel *  *  pixels , int cols , int rows , pixval maxval ,
  int x0 , int y0 , int nc , int *  xc , int *  yc , int x1 , int y1 , void ( * 
  drawprocP )(pixel *  *  , int  , int  , pixval , int  , int  , char *  ) ,
  char *  clientdata )
{
  register int i , x , y , xn , yn ; /*decdef*/
  x = x0;
  y = y0;
  for(i = 0; i < nc - 1; ++ i)
  {
    xn = (xc[i] + xc[i + 1]) / 2;
    yn = (yc[i] + yc[i + 1]) / 2;
    ppmd_spline3(pixels, cols, rows, maxval, x, y, xc[i], yc[i], xn, yn,
      drawprocP, clientdata);
    x = xn;
    y = yn;
  }
  ppmd_spline3(pixels, cols, rows, maxval, x, y, xc[nc - 1], yc[nc - 1], x1, y1,
    drawprocP, clientdata);
}

void ppmd_circle(pixel *  *  pixels , int cols , int rows , pixval maxval ,
  int cx , int cy , int radius , void ( *  drawprocP )(pixel *  *  , int  , int 
  , pixval , int  , int  , char *  ) , char *  clientdata )
{
  register int x0 , y0 , x , y , prevx , prevy , nopointsyet ; /*decdef*/
  register long sx , sy , e ; /*decdef*/
  x0 = (x = radius);
  y0 = (y = 0);
  sx = x * 8192 + 8192 / 2;
  sy = y * 8192 + 8192 / 2;
  e = 8192 / radius;
  if(drawprocP == (void ( *  )(pixel *  *  , int  , int  , pixval , int  , int 
    , char *  ))0)
    (pixels[y + cy])[x + cx] = * (pixel *  )clientdata;
  else
    (* drawprocP)(pixels, cols, rows, maxval, x + cx, y + cy, clientdata);
  nopointsyet = 1;
  do
  {
    prevx = x;
    prevy = y;
    sx += e * sy / 8192;
    sy -= e * sx / 8192;
    x = sx / 8192;
    y = sy / 8192;
    if(x != prevx || y != prevy)
    {
      nopointsyet = 0;
      if(drawprocP == (void ( *  )(pixel *  *  , int  , int  , pixval , int  ,
	int  , char *  ))0)
	(pixels[y + cy])[x + cx] = * (pixel *  )clientdata;
      else
	(* drawprocP)(pixels, cols, rows, maxval, x + cx, y + cy, clientdata);
    }
  }
  while(nopointsyet || x != x0 || y != y0);
}

typedef struct  {
  short x ;
  short y ;
  short edge ;
} coord ; /*typedef*/

typedef struct  {
  int n ;
  int size ;
  int curedge ;
  int segstart ;
  int ydir ;
  int startydir ;
  coord *  coords ;
} fillobj ; /*typedef*/

static int oldclip ; /*decdef*/

char *  ppmd_fill_init()
{
  fillobj *  fh ; /*decdef*/
  fh = (fillobj *  )malloc(sizeof(* fh));
  if(fh == 0)
    pm_error("out of memory allocating a fillhandle");
  fh->n = 0;
  fh->coords = (coord *  )malloc(1000 * sizeof(* fh->coords));
  if(fh->coords == 0)
    pm_error("out of memory allocating a fillhandle");
  fh->size = 1000;
  fh->curedge = 0;
  oldclip = ppmd_setlineclip(0);
  return (char *  )fh;
}

void ppmd_fill_drawproc(pixel *  *  pixels , int cols , int rows , pixval maxval
  , int x , int y , char *  clientdata )
{
  register fillobj *  fh ; /*decdef*/
  register coord *  cp ; /*decdef*/
  register coord *  ocp ; /*decdef*/
  fh = (fillobj *  )clientdata;
  if(fh->n > 0)
  {
    ocp = & (fh->coords)[fh->n - 1];
    if(x == ocp->x && y == ocp->y)
      return;
  }
  if(fh->n + 1 >= fh->size)
  {
    fh->size += 1000;
    fh->coords = (coord *  )realloc((char *  )fh->coords, fh->size * sizeof(*
      fh->coords));
    if(fh->coords == 0)
      pm_error("out of memory enlarging a fillhandle");
  }
  if(fh->n == 0)
  {
    fh->segstart = fh->n;
    fh->ydir = 0;
    fh->startydir = 0;
  }
  else
  {
    register int dx , dy ; /*decdef*/
    dx = x - ocp->x;
    dy = y - ocp->y;
    if(dx < - 1 || dx > 1 || dy < - 1 || dy > 1)
    {
      if(fh->startydir != 0 && fh->ydir != 0)
      {
	if(fh->startydir == fh->ydir)
	{
	  register coord *  fcp ; /*decdef*/
	  int oldedge ; /*decdef*/
	  fcp = & (fh->coords)[fh->segstart];
	  oldedge = fcp->edge;
	  for(; fcp->edge == oldedge; ++ fcp)
	    fcp->edge = ocp->edge;
	}
      }
      ++ fh->curedge;
      fh->segstart = fh->n;
      fh->ydir = 0;
      fh->startydir = 0;
    }
    else
    {
      if(dy != 0)
      {
	if(fh->ydir != 0 && fh->ydir != dy)
	{
	  ++ fh->curedge;
	  cp = & (fh->coords)[fh->n];
	  cp->x = ocp->x;
	  cp->y = ocp->y;
	  cp->edge = fh->curedge;
	  ++ fh->n;
	}
	fh->ydir = dy;
	if(fh->startydir == 0)
	  fh->startydir = dy;
      }
    }
  }
  cp = & (fh->coords)[fh->n];
  cp->x = x;
  cp->y = y;
  cp->edge = fh->curedge;
  ++ fh->n;
}

static int yx_compare(coord *  c1 , coord *  c2 )
{
  if(c1->y > c2->y)
    return 1;
  if(c1->y < c2->y)
    return - 1;
  if(c1->x > c2->x)
    return 1;
  if(c1->x < c2->x)
    return - 1;
  return 0;
}

void ppmd_fill(pixel *  *  pixels , int cols , int rows , pixval maxval ,
  char *  fillhandle , void ( *  drawprocP )(pixel *  *  , int  , int  , pixval
  , int  , int  , char *  ) , char *  clientdata )
{
  register fillobj *  fh ; /*decdef*/
  int pedge , eq ; /*decdef*/
  register int i , leftside , edge , lx , rx , py ; /*decdef*/
  register coord *  cp ; /*decdef*/
  fh = (fillobj *  )fillhandle;
  if(fh->n > 0 && fh->startydir != 0 && fh->ydir != 0)
  {
    if(fh->startydir == fh->ydir)
    {
      register coord *  fcp ; /*decdef*/
      int lastedge , oldedge ; /*decdef*/
      lastedge = ((fh->coords)[fh->n - 1]).edge;
      fcp = & (fh->coords)[fh->segstart];
      oldedge = fcp->edge;
      for(; fcp->edge == oldedge; ++ fcp)
	fcp->edge = lastedge;
    }
  }
  (void )ppmd_setlineclip(oldclip);
  qsort((char *  )fh->coords, fh->n, sizeof(* fh->coords), yx_compare);
  edge = - 1;
  for(i = 0; i < fh->n; ++ i)
  {
    cp = & (fh->coords)[i];
    if(i > 1 && eq && cp->edge != edge && cp->edge == pedge)
    {
      coord t ; /*decdef*/
      t = (fh->coords)[i - 1];
      (fh->coords)[i - 1] = (fh->coords)[i - 2];
      (fh->coords)[i - 2] = t;
    }
    if(i > 0)
    {
      if(cp->x == lx && cp->y == py)
      {
	eq = 1;
	if(cp->edge != edge && cp->edge == pedge)
	{
	  coord t ; /*decdef*/
	  t = * cp;
	  * cp = (fh->coords)[i - 1];
	  (fh->coords)[i - 1] = t;
	}
      }
      else
	eq = 0;
    }
    lx = cp->x;
    py = cp->y;
    pedge = edge;
    edge = cp->edge;
  }
  for(i = 0; i < fh->n; ++ i)
  {
    cp = & (fh->coords)[i];
    if(i == 0)
    {
      lx = (rx = cp->x);
      py = cp->y;
      edge = cp->edge;
      leftside = 1;
    }
    else
    {
      if(cp->y != py)
      {
	ppmd_filledrectangle(pixels, cols, rows, maxval, lx, py, rx - lx + 1, 1,
	  drawprocP, clientdata);
	lx = (rx = cp->x);
	py = cp->y;
	edge = cp->edge;
	leftside = 1;
      }
      else
      {
	if(cp->edge == edge)
	{
	  rx = cp->x;
	}
	else
	{
	  if(leftside)
	  {
	    rx = cp->x;
	    leftside = 0;
	  }
	  else
	  {
	    ppmd_filledrectangle(pixels, cols, rows, maxval, lx, py, rx - lx +
	      1, 1, drawprocP, clientdata);
	    lx = (rx = cp->x);
	    leftside = 1;
	  }
	  edge = cp->edge;
	}
      }
    }
  }
  free(fh->coords);
  free(fh);
}


#pragma combiner("./spec_image.i", "-g -O -I/home/scott/wrk/safec/cil/lib ")

#pragma boxalloc("malloc", nozero, sizein(0))

#pragma boxalloc("alloca", nozero, sizein(0))

#pragma boxalloc("calloc", zero, sizemul(0, 1))

#pragma boxprintf("printf", 0)

#pragma boxprintf("fprintf", 1)

#pragma boxprintf("sprintf", 1)

#pragma boxprintf("snprintf", 2)

#pragma boxpoly("memcpy")

#pragma boxexported("main")
extern double acos(double __x ) ; /*decdef*/
extern double __acos(double __x ) ; /*decdef*/
extern double asin(double __x ) ; /*decdef*/
extern double __asin(double __x ) ; /*decdef*/
extern double atan(double __x ) ; /*decdef*/
extern double __atan(double __x ) ; /*decdef*/
extern double atan2(double __y , double __x ) ; /*decdef*/
extern double __atan2(double __y , double __x ) ; /*decdef*/
extern double cos(double __x ) ; /*decdef*/
extern double __cos(double __x ) ; /*decdef*/
extern double sin(double __x ) ; /*decdef*/
extern double __sin(double __x ) ; /*decdef*/
extern double tan(double __x ) ; /*decdef*/
extern double __tan(double __x ) ; /*decdef*/
extern double cosh(double __x ) ; /*decdef*/
extern double __cosh(double __x ) ; /*decdef*/
extern double sinh(double __x ) ; /*decdef*/
extern double __sinh(double __x ) ; /*decdef*/
extern double tanh(double __x ) ; /*decdef*/
extern double __tanh(double __x ) ; /*decdef*/
extern double acosh(double __x ) ; /*decdef*/
extern double __acosh(double __x ) ; /*decdef*/
extern double asinh(double __x ) ; /*decdef*/
extern double __asinh(double __x ) ; /*decdef*/
extern double atanh(double __x ) ; /*decdef*/
extern double __atanh(double __x ) ; /*decdef*/
extern double exp(double __x ) ; /*decdef*/
extern double __exp(double __x ) ; /*decdef*/
extern double frexp(double __x , int *  __exponent ) ; /*decdef*/
extern double __frexp(double __x , int *  __exponent ) ; /*decdef*/
extern double ldexp(double __x , int __exponent ) ; /*decdef*/
extern double __ldexp(double __x , int __exponent ) ; /*decdef*/
extern double log(double __x ) ; /*decdef*/
extern double __log(double __x ) ; /*decdef*/
extern double log10(double __x ) ; /*decdef*/
extern double __log10(double __x ) ; /*decdef*/
extern double modf(double __x , double *  __iptr ) ; /*decdef*/
extern double __modf(double __x , double *  __iptr ) ; /*decdef*/
extern double expm1(double __x ) ; /*decdef*/
extern double __expm1(double __x ) ; /*decdef*/
extern double log1p(double __x ) ; /*decdef*/
extern double __log1p(double __x ) ; /*decdef*/
extern double logb(double __x ) ; /*decdef*/
extern double __logb(double __x ) ; /*decdef*/
extern double pow(double __x , double __y ) ; /*decdef*/
extern double __pow(double __x , double __y ) ; /*decdef*/
extern double sqrt(double __x ) ; /*decdef*/
extern double __sqrt(double __x ) ; /*decdef*/
extern double hypot(double __x , double __y ) ; /*decdef*/
extern double __hypot(double __x , double __y ) ; /*decdef*/
extern double cbrt(double __x ) ; /*decdef*/
extern double __cbrt(double __x ) ; /*decdef*/
extern double ceil(double __x ) ; /*decdef*/
extern double __ceil(double __x ) ; /*decdef*/
extern double fabs(double __x ) __attribute__((const)) ; /*decdef*/
extern double __fabs(double __x ) __attribute__((const)) ; /*decdef*/
extern double floor(double __x ) ; /*decdef*/
extern double __floor(double __x ) ; /*decdef*/
extern double fmod(double __x , double __y ) ; /*decdef*/
extern double __fmod(double __x , double __y ) ; /*decdef*/
extern int __isinf(double __value ) __attribute__((const)) ; /*decdef*/
extern int isinf(double __value ) __attribute__((const)) ; /*decdef*/
extern int finite(double __value ) __attribute__((const)) ; /*decdef*/
extern int __finite(double __value ) __attribute__((const)) ; /*decdef*/
extern double infnan(int __error ) __attribute__((const)) ; /*decdef*/
extern double __infnan(int __error ) __attribute__((const)) ; /*decdef*/
extern double drem(double __x , double __y ) ; /*decdef*/
extern double __drem(double __x , double __y ) ; /*decdef*/
extern double significand(double __x ) ; /*decdef*/
extern double __significand(double __x ) ; /*decdef*/
extern double copysign(double __x , double __y ) __attribute__((const))
  ; /*decdef*/
extern double __copysign(double __x , double __y ) __attribute__((const))
  ; /*decdef*/
extern int isnan(double __value ) __attribute__((const)) ; /*decdef*/
extern int __isnan(double __value ) __attribute__((const)) ; /*decdef*/
extern double j0(double  ) ; /*decdef*/
extern double __j0(double  ) ; /*decdef*/
extern double j1(double  ) ; /*decdef*/
extern double __j1(double  ) ; /*decdef*/
extern double jn(int  , double  ) ; /*decdef*/
extern double __jn(int  , double  ) ; /*decdef*/
extern double y0(double  ) ; /*decdef*/
extern double __y0(double  ) ; /*decdef*/
extern double y1(double  ) ; /*decdef*/
extern double __y1(double  ) ; /*decdef*/
extern double yn(int  , double  ) ; /*decdef*/
extern double __yn(int  , double  ) ; /*decdef*/
extern double erf(double  ) ; /*decdef*/
extern double __erf(double  ) ; /*decdef*/
extern double erfc(double  ) ; /*decdef*/
extern double __erfc(double  ) ; /*decdef*/
extern double lgamma(double  ) ; /*decdef*/
extern double __lgamma(double  ) ; /*decdef*/
extern double tgamma(double  ) ; /*decdef*/
extern double __tgamma(double  ) ; /*decdef*/
extern double gamma(double  ) ; /*decdef*/
extern double __gamma(double  ) ; /*decdef*/
extern double lgamma_r(double  , int *  __signgamp ) ; /*decdef*/
extern double __lgamma_r(double  , int *  __signgamp ) ; /*decdef*/
extern double rint(double __x ) ; /*decdef*/
extern double __rint(double __x ) ; /*decdef*/
extern double nextafter(double __x , double __y ) __attribute__((const))
  ; /*decdef*/
extern double __nextafter(double __x , double __y ) __attribute__((const))
  ; /*decdef*/
extern double remainder(double __x , double __y ) ; /*decdef*/
extern double __remainder(double __x , double __y ) ; /*decdef*/
extern double scalb(double __x , double __n ) ; /*decdef*/
extern double __scalb(double __x , double __n ) ; /*decdef*/
extern double scalbn(double __x , int __n ) ; /*decdef*/
extern double __scalbn(double __x , int __n ) ; /*decdef*/
extern int ilogb(double __x ) ; /*decdef*/
extern int __ilogb(double __x ) ; /*decdef*/
extern float acosf(float __x ) ; /*decdef*/
extern float __acosf(float __x ) ; /*decdef*/
extern float asinf(float __x ) ; /*decdef*/
extern float __asinf(float __x ) ; /*decdef*/
extern float atanf(float __x ) ; /*decdef*/
extern float __atanf(float __x ) ; /*decdef*/
extern float atan2f(float __y , float __x ) ; /*decdef*/
extern float __atan2f(float __y , float __x ) ; /*decdef*/
extern float cosf(float __x ) ; /*decdef*/
extern float __cosf(float __x ) ; /*decdef*/
extern float sinf(float __x ) ; /*decdef*/
extern float __sinf(float __x ) ; /*decdef*/
extern float tanf(float __x ) ; /*decdef*/
extern float __tanf(float __x ) ; /*decdef*/
extern float coshf(float __x ) ; /*decdef*/
extern float __coshf(float __x ) ; /*decdef*/
extern float sinhf(float __x ) ; /*decdef*/
extern float __sinhf(float __x ) ; /*decdef*/
extern float tanhf(float __x ) ; /*decdef*/
extern float __tanhf(float __x ) ; /*decdef*/
extern float acoshf(float __x ) ; /*decdef*/
extern float __acoshf(float __x ) ; /*decdef*/
extern float asinhf(float __x ) ; /*decdef*/
extern float __asinhf(float __x ) ; /*decdef*/
extern float atanhf(float __x ) ; /*decdef*/
extern float __atanhf(float __x ) ; /*decdef*/
extern float expf(float __x ) ; /*decdef*/
extern float __expf(float __x ) ; /*decdef*/
extern float frexpf(float __x , int *  __exponent ) ; /*decdef*/
extern float __frexpf(float __x , int *  __exponent ) ; /*decdef*/
extern float ldexpf(float __x , int __exponent ) ; /*decdef*/
extern float __ldexpf(float __x , int __exponent ) ; /*decdef*/
extern float logf(float __x ) ; /*decdef*/
extern float __logf(float __x ) ; /*decdef*/
extern float log10f(float __x ) ; /*decdef*/
extern float __log10f(float __x ) ; /*decdef*/
extern float modff(float __x , float *  __iptr ) ; /*decdef*/
extern float __modff(float __x , float *  __iptr ) ; /*decdef*/
extern float expm1f(float __x ) ; /*decdef*/
extern float __expm1f(float __x ) ; /*decdef*/
extern float log1pf(float __x ) ; /*decdef*/
extern float __log1pf(float __x ) ; /*decdef*/
extern float logbf(float __x ) ; /*decdef*/
extern float __logbf(float __x ) ; /*decdef*/
extern float powf(float __x , float __y ) ; /*decdef*/
extern float __powf(float __x , float __y ) ; /*decdef*/
extern float sqrtf(float __x ) ; /*decdef*/
extern float __sqrtf(float __x ) ; /*decdef*/
extern float hypotf(float __x , float __y ) ; /*decdef*/
extern float __hypotf(float __x , float __y ) ; /*decdef*/
extern float cbrtf(float __x ) ; /*decdef*/
extern float __cbrtf(float __x ) ; /*decdef*/
extern float ceilf(float __x ) ; /*decdef*/
extern float __ceilf(float __x ) ; /*decdef*/
extern float fabsf(float __x ) __attribute__((const)) ; /*decdef*/
extern float __fabsf(float __x ) __attribute__((const)) ; /*decdef*/
extern float floorf(float __x ) ; /*decdef*/
extern float __floorf(float __x ) ; /*decdef*/
extern float fmodf(float __x , float __y ) ; /*decdef*/
extern float __fmodf(float __x , float __y ) ; /*decdef*/
extern int __isinff(float __value ) __attribute__((const)) ; /*decdef*/
extern int isinff(float __value ) __attribute__((const)) ; /*decdef*/
extern int finitef(float __value ) __attribute__((const)) ; /*decdef*/
extern int __finitef(float __value ) __attribute__((const)) ; /*decdef*/
extern float infnanf(int __error ) __attribute__((const)) ; /*decdef*/
extern float __infnanf(int __error ) __attribute__((const)) ; /*decdef*/
extern float dremf(float __x , float __y ) ; /*decdef*/
extern float __dremf(float __x , float __y ) ; /*decdef*/
extern float significandf(float __x ) ; /*decdef*/
extern float __significandf(float __x ) ; /*decdef*/
extern float copysignf(float __x , float __y ) __attribute__((const))
  ; /*decdef*/
extern float __copysignf(float __x , float __y ) __attribute__((const))
  ; /*decdef*/
extern int isnanf(float __value ) __attribute__((const)) ; /*decdef*/
extern int __isnanf(float __value ) __attribute__((const)) ; /*decdef*/
extern float j0f(float  ) ; /*decdef*/
extern float __j0f(float  ) ; /*decdef*/
extern float j1f(float  ) ; /*decdef*/
extern float __j1f(float  ) ; /*decdef*/
extern float jnf(int  , float  ) ; /*decdef*/
extern float __jnf(int  , float  ) ; /*decdef*/
extern float y0f(float  ) ; /*decdef*/
extern float __y0f(float  ) ; /*decdef*/
extern float y1f(float  ) ; /*decdef*/
extern float __y1f(float  ) ; /*decdef*/
extern float ynf(int  , float  ) ; /*decdef*/
extern float __ynf(int  , float  ) ; /*decdef*/
extern float erff(float  ) ; /*decdef*/
extern float __erff(float  ) ; /*decdef*/
extern float erfcf(float  ) ; /*decdef*/
extern float __erfcf(float  ) ; /*decdef*/
extern float lgammaf(float  ) ; /*decdef*/
extern float __lgammaf(float  ) ; /*decdef*/
extern float tgammaf(float  ) ; /*decdef*/
extern float __tgammaf(float  ) ; /*decdef*/
extern float gammaf(float  ) ; /*decdef*/
extern float __gammaf(float  ) ; /*decdef*/
extern float lgammaf_r(float  , int *  __signgamp ) ; /*decdef*/
extern float __lgammaf_r(float  , int *  __signgamp ) ; /*decdef*/
extern float rintf(float __x ) ; /*decdef*/
extern float __rintf(float __x ) ; /*decdef*/
extern float nextafterf(float __x , float __y ) __attribute__((const))
  ; /*decdef*/
extern float __nextafterf(float __x , float __y ) __attribute__((const))
  ; /*decdef*/
extern float remainderf(float __x , float __y ) ; /*decdef*/
extern float __remainderf(float __x , float __y ) ; /*decdef*/
extern float scalbf(float __x , float __n ) ; /*decdef*/
extern float __scalbf(float __x , float __n ) ; /*decdef*/
extern float scalbnf(float __x , int __n ) ; /*decdef*/
extern float __scalbnf(float __x , int __n ) ; /*decdef*/
extern int ilogbf(float __x ) ; /*decdef*/
extern int __ilogbf(float __x ) ; /*decdef*/
extern long double acosl(long double __x ) ; /*decdef*/
extern long double __acosl(long double __x ) ; /*decdef*/
extern long double asinl(long double __x ) ; /*decdef*/
extern long double __asinl(long double __x ) ; /*decdef*/
extern long double atanl(long double __x ) ; /*decdef*/
extern long double __atanl(long double __x ) ; /*decdef*/
extern long double atan2l(long double __y , long double __x ) ; /*decdef*/
extern long double __atan2l(long double __y , long double __x ) ; /*decdef*/
extern long double cosl(long double __x ) ; /*decdef*/
extern long double __cosl(long double __x ) ; /*decdef*/
extern long double sinl(long double __x ) ; /*decdef*/
extern long double __sinl(long double __x ) ; /*decdef*/
extern long double tanl(long double __x ) ; /*decdef*/
extern long double __tanl(long double __x ) ; /*decdef*/
extern long double coshl(long double __x ) ; /*decdef*/
extern long double __coshl(long double __x ) ; /*decdef*/
extern long double sinhl(long double __x ) ; /*decdef*/
extern long double __sinhl(long double __x ) ; /*decdef*/
extern long double tanhl(long double __x ) ; /*decdef*/
extern long double __tanhl(long double __x ) ; /*decdef*/
extern long double acoshl(long double __x ) ; /*decdef*/
extern long double __acoshl(long double __x ) ; /*decdef*/
extern long double asinhl(long double __x ) ; /*decdef*/
extern long double __asinhl(long double __x ) ; /*decdef*/
extern long double atanhl(long double __x ) ; /*decdef*/
extern long double __atanhl(long double __x ) ; /*decdef*/
extern long double expl(long double __x ) ; /*decdef*/
extern long double __expl(long double __x ) ; /*decdef*/
extern long double frexpl(long double __x , int *  __exponent ) ; /*decdef*/
extern long double __frexpl(long double __x , int *  __exponent ) ; /*decdef*/
extern long double ldexpl(long double __x , int __exponent ) ; /*decdef*/
extern long double __ldexpl(long double __x , int __exponent ) ; /*decdef*/
extern long double logl(long double __x ) ; /*decdef*/
extern long double __logl(long double __x ) ; /*decdef*/
extern long double log10l(long double __x ) ; /*decdef*/
extern long double __log10l(long double __x ) ; /*decdef*/
extern long double modfl(long double __x , long double *  __iptr ) ; /*decdef*/
extern long double __modfl(long double __x , long double *  __iptr )
  ; /*decdef*/
extern long double expm1l(long double __x ) ; /*decdef*/
extern long double __expm1l(long double __x ) ; /*decdef*/
extern long double log1pl(long double __x ) ; /*decdef*/
extern long double __log1pl(long double __x ) ; /*decdef*/
extern long double logbl(long double __x ) ; /*decdef*/
extern long double __logbl(long double __x ) ; /*decdef*/
extern long double powl(long double __x , long double __y ) ; /*decdef*/
extern long double __powl(long double __x , long double __y ) ; /*decdef*/
extern long double sqrtl(long double __x ) ; /*decdef*/
extern long double __sqrtl(long double __x ) ; /*decdef*/
extern long double hypotl(long double __x , long double __y ) ; /*decdef*/
extern long double __hypotl(long double __x , long double __y ) ; /*decdef*/
extern long double cbrtl(long double __x ) ; /*decdef*/
extern long double __cbrtl(long double __x ) ; /*decdef*/
extern long double ceill(long double __x ) ; /*decdef*/
extern long double __ceill(long double __x ) ; /*decdef*/
extern long double fabsl(long double __x ) __attribute__((const)) ; /*decdef*/
extern long double __fabsl(long double __x ) __attribute__((const)) ; /*decdef*/
extern long double floorl(long double __x ) ; /*decdef*/
extern long double __floorl(long double __x ) ; /*decdef*/
extern long double fmodl(long double __x , long double __y ) ; /*decdef*/
extern long double __fmodl(long double __x , long double __y ) ; /*decdef*/
extern int __isinfl(long double __value ) __attribute__((const)) ; /*decdef*/
extern int isinfl(long double __value ) __attribute__((const)) ; /*decdef*/
extern int finitel(long double __value ) __attribute__((const)) ; /*decdef*/
extern int __finitel(long double __value ) __attribute__((const)) ; /*decdef*/
extern long double infnanl(int __error ) __attribute__((const)) ; /*decdef*/
extern long double __infnanl(int __error ) __attribute__((const)) ; /*decdef*/
extern long double dreml(long double __x , long double __y ) ; /*decdef*/
extern long double __dreml(long double __x , long double __y ) ; /*decdef*/
extern long double significandl(long double __x ) ; /*decdef*/
extern long double __significandl(long double __x ) ; /*decdef*/
extern long double copysignl(long double __x , long double __y )
  __attribute__((const)) ; /*decdef*/
extern long double __copysignl(long double __x , long double __y )
  __attribute__((const)) ; /*decdef*/
extern int isnanl(long double __value ) __attribute__((const)) ; /*decdef*/
extern int __isnanl(long double __value ) __attribute__((const)) ; /*decdef*/
extern long double j0l(long double  ) ; /*decdef*/
extern long double __j0l(long double  ) ; /*decdef*/
extern long double j1l(long double  ) ; /*decdef*/
extern long double __j1l(long double  ) ; /*decdef*/
extern long double jnl(int  , long double  ) ; /*decdef*/
extern long double __jnl(int  , long double  ) ; /*decdef*/
extern long double y0l(long double  ) ; /*decdef*/
extern long double __y0l(long double  ) ; /*decdef*/
extern long double y1l(long double  ) ; /*decdef*/
extern long double __y1l(long double  ) ; /*decdef*/
extern long double ynl(int  , long double  ) ; /*decdef*/
extern long double __ynl(int  , long double  ) ; /*decdef*/
extern long double erfl(long double  ) ; /*decdef*/
extern long double __erfl(long double  ) ; /*decdef*/
extern long double erfcl(long double  ) ; /*decdef*/
extern long double __erfcl(long double  ) ; /*decdef*/
extern long double lgammal(long double  ) ; /*decdef*/
extern long double __lgammal(long double  ) ; /*decdef*/
extern long double tgammal(long double  ) ; /*decdef*/
extern long double __tgammal(long double  ) ; /*decdef*/
extern long double gammal(long double  ) ; /*decdef*/
extern long double __gammal(long double  ) ; /*decdef*/
extern long double lgammal_r(long double  , int *  __signgamp ) ; /*decdef*/
extern long double __lgammal_r(long double  , int *  __signgamp ) ; /*decdef*/
extern long double rintl(long double __x ) ; /*decdef*/
extern long double __rintl(long double __x ) ; /*decdef*/
extern long double nextafterl(long double __x , long double __y )
  __attribute__((const)) ; /*decdef*/
extern long double __nextafterl(long double __x , long double __y )
  __attribute__((const)) ; /*decdef*/
extern long double remainderl(long double __x , long double __y ) ; /*decdef*/
extern long double __remainderl(long double __x , long double __y ) ; /*decdef*/
extern long double scalbl(long double __x , long double __n ) ; /*decdef*/
extern long double __scalbl(long double __x , long double __n ) ; /*decdef*/
extern long double scalbnl(long double __x , int __n ) ; /*decdef*/
extern long double __scalbnl(long double __x , int __n ) ; /*decdef*/
extern int ilogbl(long double __x ) ; /*decdef*/
extern int __ilogbl(long double __x ) ; /*decdef*/
extern int signgam ; /*decdef*/

typedef enum  {
  _IEEE_ = - 1,
  _SVID_,
  _XOPEN_,
  _POSIX_,
  _ISOC_
} _LIB_VERSION_TYPE ; /*typedef*/

extern _LIB_VERSION_TYPE _LIB_VERSION ; /*decdef*/

struct exception {
  int type ;
  char *  name ;
  double arg1 ;
  double arg2 ;
  double retval ;
} ; /*onlytypedef*/

extern int matherr(struct exception *  __exc ) ; /*decdef*/

union __convert_long_double {
  unsigned __convert_long_double_i[4] ;
  long double __convert_long_double_d ;
} ; /*onlytypedef*/

extern int __sigismember(const __sigset_t *  , int  ) ; /*decdef*/
extern int __sigaddset(__sigset_t *  , int  ) ; /*decdef*/
extern int __sigdelset(__sigset_t *  , int  ) ; /*decdef*/

typedef __sig_atomic_t sig_atomic_t ; /*typedef*/

typedef __sigset_t sigset_t ; /*typedef*/

typedef void ( *  __sighandler_t )(int  ) ; /*typedef*/

extern __sighandler_t __sysv_signal(int __sig , __sighandler_t __handler )
  ; /*decdef*/
extern __sighandler_t signal(int __sig , __sighandler_t __handler ) ; /*decdef*/
extern int kill(__pid_t __pid , int __sig ) ; /*decdef*/
extern int killpg(__pid_t __pgrp , int __sig ) ; /*decdef*/
extern int raise(int __sig ) ; /*decdef*/
extern __sighandler_t ssignal(int __sig , __sighandler_t __handler )
  ; /*decdef*/
extern int gsignal(int __sig ) ; /*decdef*/
extern void psignal(int __sig , const char *  __s ) ; /*decdef*/
extern int __sigpause(int __sig_or_mask , int __is_sig ) ; /*decdef*/
extern int sigpause(int __mask ) ; /*decdef*/
extern int sigblock(int __mask ) ; /*decdef*/
extern int sigsetmask(int __mask ) ; /*decdef*/
extern int siggetmask(void  ) ; /*decdef*/

typedef __sighandler_t sig_t ; /*typedef*/

typedef union sigval {
  int sival_int ;
  void *  sival_ptr ;
} sigval_t ; /*typedef*/

typedef struct siginfo {
  int si_signo ;
  int si_errno ;
  int si_code ;
  union  {
    int _pad[128 / sizeof(int ) - 3] ;
    struct  {
      __pid_t si_pid ;
      __uid_t si_uid ;
    } _kill ;
    struct  {
      unsigned int _timer1 ;
      unsigned int _timer2 ;
    } _timer ;
    struct  {
      __pid_t si_pid ;
      __uid_t si_uid ;
      sigval_t si_sigval ;
    } _rt ;
    struct  {
      __pid_t si_pid ;
      __uid_t si_uid ;
      int si_status ;
      __clock_t si_utime ;
      __clock_t si_stime ;
    } _sigchld ;
    struct  {
      void *  si_addr ;
    } _sigfault ;
    struct  {
      int si_band ;
      int si_fd ;
    } _sigpoll ;
  } _sifields ;
} siginfo_t ; /*typedef*/

enum  {
  SI_SIGIO = - 5,
  SI_ASYNCIO,
  SI_MESGQ,
  SI_TIMER,
  SI_QUEUE,
  SI_USER
} ; /*onlytypedef*/

enum  {
  ILL_ILLOPC = 1,
  ILL_ILLOPN,
  ILL_ILLADR,
  ILL_ILLTRP,
  ILL_PRVOPC,
  ILL_PRVREG,
  ILL_COPROC,
  ILL_BADSTK
} ; /*onlytypedef*/

enum  {
  FPE_INTDIV = 1,
  FPE_INTOVF,
  FPE_FLTDIV,
  FPE_FLTOVF,
  FPE_FLTUND,
  FPE_FLTRES,
  FPE_FLTINV,
  FPE_FLTSUB
} ; /*onlytypedef*/

enum  {
  SEGV_MAPERR = 1,
  SEGV_ACCERR
} ; /*onlytypedef*/

enum  {
  BUS_ADRALN = 1,
  BUS_ADRERR,
  BUS_OBJERR
} ; /*onlytypedef*/

enum  {
  TRAP_BRKPT = 1,
  TRAP_TRACE
} ; /*onlytypedef*/

enum  {
  CLD_EXITED = 1,
  CLD_KILLED,
  CLD_DUMPED,
  CLD_TRAPPED,
  CLD_STOPPED,
  CLD_CONTINUED
} ; /*onlytypedef*/

enum  {
  POLL_IN = 1,
  POLL_OUT,
  POLL_MSG,
  POLL_ERR,
  POLL_PRI,
  POLL_HUP
} ; /*onlytypedef*/

typedef struct sigevent {
  sigval_t sigev_value ;
  int sigev_signo ;
  int sigev_notify ;
  union  {
    int _pad[64 / sizeof(int ) - 3] ;
    struct  {
      void ( *  _function )(sigval_t ) ;
      void *  _attribute ;
    } _sigev_thread ;
  } _sigev_un ;
} sigevent_t ; /*typedef*/

enum  {
  SIGEV_SIGNAL = 0,
  SIGEV_NONE,
  SIGEV_THREAD
} ; /*onlytypedef*/

extern int sigemptyset(sigset_t *  __set ) ; /*decdef*/
extern int sigfillset(sigset_t *  __set ) ; /*decdef*/
extern int sigaddset(sigset_t *  __set , int __signo ) ; /*decdef*/
extern int sigdelset(sigset_t *  __set , int __signo ) ; /*decdef*/
extern int sigismember(const sigset_t *  __set , int __signo ) ; /*decdef*/

struct sigaction {
  union  {
    __sighandler_t sa_handler ;
    void ( *  sa_sigaction )(int  , siginfo_t *  , void *  ) ;
  } __sigaction_handler ;
  __sigset_t sa_mask ;
  int sa_flags ;
  void ( *  sa_restorer )(void  ) ;
} ; /*onlytypedef*/

extern int sigprocmask(int __how , const sigset_t *  __set , sigset_t *  __oset
  ) ; /*decdef*/
extern int sigsuspend(const sigset_t *  __set ) ; /*decdef*/
extern int __sigaction(int __sig , const struct sigaction *  __act ,
  struct sigaction *  __oact ) ; /*decdef*/
extern int sigaction(int __sig , const struct sigaction *  __act ,
  struct sigaction *  __oact ) ; /*decdef*/
extern int sigpending(sigset_t *  __set ) ; /*decdef*/
extern int sigwait(const sigset_t *  __set , int *  __sig ) ; /*decdef*/
extern int sigwaitinfo(const sigset_t *  __set , siginfo_t *  __info )
  ; /*decdef*/
extern int sigtimedwait(const sigset_t *  __set , siginfo_t *  __info , const
  struct timespec *  __timeout ) ; /*decdef*/
extern int sigqueue(__pid_t __pid , int __sig , const union sigval __val )
  ; /*decdef*/
extern const char * const _sys_siglist[64] ; /*decdef*/
extern const char * const sys_siglist[64] ; /*decdef*/

struct sigvec {
  __sighandler_t sv_handler ;
  int sv_mask ;
  int sv_flags ;
} ; /*onlytypedef*/

extern int sigvec(int __sig , const struct sigvec *  __vec , struct sigvec * 
  __ovec ) ; /*decdef*/

struct _fpreg {
  unsigned short significand[4] ;
  unsigned short exponent ;
} ; /*onlytypedef*/

struct _fpstate {
  unsigned long cw , sw , tag , ipoff , cssel , dataoff , datasel ;
  struct _fpreg _st[8] ;
  unsigned long status ;
} ; /*onlytypedef*/

struct sigcontext {
  unsigned short gs , __gsh ;
  unsigned short fs , __fsh ;
  unsigned short es , __esh ;
  unsigned short ds , __dsh ;
  unsigned long edi ;
  unsigned long esi ;
  unsigned long ebp ;
  unsigned long esp ;
  unsigned long ebx ;
  unsigned long edx ;
  unsigned long ecx ;
  unsigned long eax ;
  unsigned long trapno ;
  unsigned long err ;
  unsigned long eip ;
  unsigned short cs , __csh ;
  unsigned long eflags ;
  unsigned long esp_at_signal ;
  unsigned short ss , __ssh ;
  struct _fpstate *  fpstate ;
  unsigned long oldmask ;
  unsigned long cr2 ;
} ; /*onlytypedef*/

extern int sigreturn(struct sigcontext *  __scp ) ; /*decdef*/
extern int siginterrupt(int __sig , int __interrupt ) ; /*decdef*/

struct sigstack {
  void *  ss_sp ;
  int ss_onstack ;
} ; /*onlytypedef*/

enum  {
  SS_ONSTACK = 1,
  SS_DISABLE
} ; /*onlytypedef*/

typedef struct sigaltstack {
  void *  ss_sp ;
  int ss_flags ;
  size_t ss_size ;
} stack_t ; /*typedef*/

extern int sigstack(const struct sigstack *  __ss , struct sigstack *  __oss )
  ; /*decdef*/
extern int sigaltstack(const struct sigaltstack *  __ss , struct sigaltstack * 
  __oss ) ; /*decdef*/
extern int __libc_current_sigrtmin(void  ) ; /*decdef*/
extern int __libc_current_sigrtmax(void  ) ; /*decdef*/

typedef unsigned char JSAMPLE ; /*typedef*/

typedef short JCOEF ; /*typedef*/

typedef unsigned char JOCTET ; /*typedef*/

typedef unsigned char UINT8 ; /*typedef*/

typedef unsigned short UINT16 ; /*typedef*/

typedef short INT16 ; /*typedef*/

typedef long INT32 ; /*typedef*/

typedef unsigned int JDIMENSION ; /*typedef*/

typedef int boolean ; /*typedef*/

typedef JSAMPLE *  JSAMPROW ; /*typedef*/

typedef JSAMPROW *  JSAMPARRAY ; /*typedef*/

typedef JSAMPARRAY *  JSAMPIMAGE ; /*typedef*/

typedef JCOEF JBLOCK[64] ; /*typedef*/

typedef JBLOCK *  JBLOCKROW ; /*typedef*/

typedef JBLOCKROW *  JBLOCKARRAY ; /*typedef*/

typedef JBLOCKARRAY *  JBLOCKIMAGE ; /*typedef*/

typedef JCOEF *  JCOEFPTR ; /*typedef*/

typedef struct  {
  UINT16 quantval[64] ;
  boolean sent_table ;
} JQUANT_TBL ; /*typedef*/

typedef struct  {
  UINT8 bits[17] ;
  UINT8 huffval[256] ;
  boolean sent_table ;
} JHUFF_TBL ; /*typedef*/

typedef struct  {
  int component_id ;
  int component_index ;
  int h_samp_factor ;
  int v_samp_factor ;
  int quant_tbl_no ;
  int dc_tbl_no ;
  int ac_tbl_no ;
  JDIMENSION width_in_blocks ;
  JDIMENSION height_in_blocks ;
  int DCT_scaled_size ;
  JDIMENSION downsampled_width ;
  JDIMENSION downsampled_height ;
  boolean component_needed ;
  int MCU_width ;
  int MCU_height ;
  int MCU_blocks ;
  int MCU_sample_width ;
  int last_col_width ;
  int last_row_height ;
  void *  dct_table ;
} jpeg_component_info ; /*typedef*/

typedef enum  {
  JCS_UNKNOWN,
  JCS_GRAYSCALE,
  JCS_RGB,
  JCS_YCbCr,
  JCS_CMYK,
  JCS_YCCK
} J_COLOR_SPACE ; /*typedef*/

typedef enum  {
  JDCT_ISLOW,
  JDCT_IFAST,
  JDCT_FLOAT
} J_DCT_METHOD ; /*typedef*/

typedef enum  {
  JDITHER_NONE,
  JDITHER_ORDERED,
  JDITHER_FS
} J_DITHER_MODE ; /*typedef*/

struct jpeg_common_struct {
  struct jpeg_error_mgr *  err ;
  struct jpeg_memory_mgr *  mem ;
  struct jpeg_progress_mgr *  progress ;
  boolean is_decompressor ;
  int global_state ;
} ; /*onlytypedef*/

typedef struct jpeg_common_struct *  j_common_ptr ; /*typedef*/

typedef struct jpeg_compress_struct *  j_compress_ptr ; /*typedef*/

typedef struct jpeg_decompress_struct *  j_decompress_ptr ; /*typedef*/

struct jpeg_compress_struct {
  struct jpeg_error_mgr *  err ;
  struct jpeg_memory_mgr *  mem ;
  struct jpeg_progress_mgr *  progress ;
  boolean is_decompressor ;
  int global_state ;
  struct jpeg_destination_mgr *  dest ;
  JDIMENSION image_width ;
  JDIMENSION image_height ;
  int input_components ;
  J_COLOR_SPACE in_color_space ;
  double input_gamma ;
  int data_precision ;
  int num_components ;
  J_COLOR_SPACE jpeg_color_space ;
  jpeg_component_info *  comp_info ;
  JQUANT_TBL *  quant_tbl_ptrs[4] ;
  JHUFF_TBL *  dc_huff_tbl_ptrs[4] ;
  JHUFF_TBL *  ac_huff_tbl_ptrs[4] ;
  UINT8 arith_dc_L[16] ;
  UINT8 arith_dc_U[16] ;
  UINT8 arith_ac_K[16] ;
  boolean raw_data_in ;
  boolean arith_code ;
  boolean interleave ;
  boolean optimize_coding ;
  boolean CCIR601_sampling ;
  int smoothing_factor ;
  J_DCT_METHOD dct_method ;
  unsigned int restart_interval ;
  int restart_in_rows ;
  boolean write_JFIF_header ;
  UINT8 density_unit ;
  UINT16 X_density ;
  UINT16 Y_density ;
  boolean write_Adobe_marker ;
  JDIMENSION next_scanline ;
  int max_h_samp_factor ;
  int max_v_samp_factor ;
  JDIMENSION total_iMCU_rows ;
  int comps_in_scan ;
  jpeg_component_info *  cur_comp_info[4] ;
  JDIMENSION MCUs_per_row ;
  JDIMENSION MCU_rows_in_scan ;
  int blocks_in_MCU ;
  int MCU_membership[10] ;
  struct jpeg_comp_master *  master ;
  struct jpeg_c_main_controller *  main ;
  struct jpeg_c_prep_controller *  prep ;
  struct jpeg_c_coef_controller *  coef ;
  struct jpeg_marker_writer *  marker ;
  struct jpeg_color_converter *  cconvert ;
  struct jpeg_downsampler *  downsample ;
  struct jpeg_forward_dct *  fdct ;
  struct jpeg_entropy_encoder *  entropy ;
} ; /*onlytypedef*/

struct jpeg_decompress_struct {
  struct jpeg_error_mgr *  err ;
  struct jpeg_memory_mgr *  mem ;
  struct jpeg_progress_mgr *  progress ;
  boolean is_decompressor ;
  int global_state ;
  struct jpeg_source_mgr *  src ;
  JDIMENSION image_width ;
  JDIMENSION image_height ;
  int num_components ;
  J_COLOR_SPACE jpeg_color_space ;
  J_COLOR_SPACE out_color_space ;
  unsigned int scale_num , scale_denom ;
  double output_gamma ;
  boolean raw_data_out ;
  boolean quantize_colors ;
  boolean two_pass_quantize ;
  J_DITHER_MODE dither_mode ;
  int desired_number_of_colors ;
  J_DCT_METHOD dct_method ;
  boolean do_fancy_upsampling ;
  JDIMENSION output_width ;
  JDIMENSION output_height ;
  int out_color_components ;
  int output_components ;
  int rec_outbuf_height ;
  int actual_number_of_colors ;
  JSAMPARRAY colormap ;
  JDIMENSION output_scanline ;
  JQUANT_TBL *  quant_tbl_ptrs[4] ;
  JHUFF_TBL *  dc_huff_tbl_ptrs[4] ;
  JHUFF_TBL *  ac_huff_tbl_ptrs[4] ;
  int data_precision ;
  jpeg_component_info *  comp_info ;
  UINT8 arith_dc_L[16] ;
  UINT8 arith_dc_U[16] ;
  UINT8 arith_ac_K[16] ;
  boolean arith_code ;
  unsigned int restart_interval ;
  boolean saw_JFIF_marker ;
  UINT8 density_unit ;
  UINT16 X_density ;
  UINT16 Y_density ;
  boolean saw_Adobe_marker ;
  UINT8 Adobe_transform ;
  boolean CCIR601_sampling ;
  int max_h_samp_factor ;
  int max_v_samp_factor ;
  int min_DCT_scaled_size ;
  JDIMENSION total_iMCU_rows ;
  JSAMPLE *  sample_range_limit ;
  int comps_in_scan ;
  jpeg_component_info *  cur_comp_info[4] ;
  JDIMENSION MCUs_per_row ;
  JDIMENSION MCU_rows_in_scan ;
  int blocks_in_MCU ;
  int MCU_membership[10] ;
  int unread_marker ;
  struct jpeg_decomp_master *  master ;
  struct jpeg_d_main_controller *  main ;
  struct jpeg_d_coef_controller *  coef ;
  struct jpeg_d_post_controller *  post ;
  struct jpeg_marker_reader *  marker ;
  struct jpeg_entropy_decoder *  entropy ;
  struct jpeg_inverse_dct *  idct ;
  struct jpeg_upsampler *  upsample ;
  struct jpeg_color_deconverter *  cconvert ;
  struct jpeg_color_quantizer *  cquantize ;
} ; /*onlytypedef*/

struct jpeg_error_mgr {
  void ( *  error_exit )(j_common_ptr cinfo ) ;
  void ( *  emit_message )(j_common_ptr cinfo , int msg_level ) ;
  void ( *  output_message )(j_common_ptr cinfo ) ;
  void ( *  format_message )(j_common_ptr cinfo , char *  buffer ) ;
  void ( *  reset_error_mgr )(j_common_ptr cinfo ) ;
  int msg_code ;
  union  {
    int i[8] ;
    char s[80] ;
  } msg_parm ;
  int trace_level ;
  long num_warnings ;
  const char * const *  jpeg_message_table ;
  int last_jpeg_message ;
  const char * const *  addon_message_table ;
  int first_addon_message ;
  int last_addon_message ;
} ; /*onlytypedef*/

struct jpeg_progress_mgr {
  void ( *  progress_monitor )(j_common_ptr cinfo ) ;
  long pass_counter ;
  long pass_limit ;
  int completed_passes ;
  int total_passes ;
} ; /*onlytypedef*/

struct jpeg_destination_mgr {
  JOCTET *  next_output_byte ;
  size_t free_in_buffer ;
  void ( *  init_destination )(j_compress_ptr cinfo ) ;
  boolean ( *  empty_output_buffer )(j_compress_ptr cinfo ) ;
  void ( *  term_destination )(j_compress_ptr cinfo ) ;
} ; /*onlytypedef*/

struct jpeg_source_mgr {
  const JOCTET *  next_input_byte ;
  size_t bytes_in_buffer ;
  void ( *  init_source )(j_decompress_ptr cinfo ) ;
  boolean ( *  fill_input_buffer )(j_decompress_ptr cinfo ) ;
  void ( *  skip_input_data )(j_decompress_ptr cinfo , long num_bytes ) ;
  boolean ( *  resync_to_restart )(j_decompress_ptr cinfo ) ;
  void ( *  term_source )(j_decompress_ptr cinfo ) ;
} ; /*onlytypedef*/

typedef struct jvirt_sarray_control *  jvirt_sarray_ptr ; /*typedef*/

typedef struct jvirt_barray_control *  jvirt_barray_ptr ; /*typedef*/

struct jpeg_memory_mgr {
  void *  ( *  alloc_small )(j_common_ptr cinfo , int pool_id , size_t
    sizeofobject ) ;
  void *  ( *  alloc_large )(j_common_ptr cinfo , int pool_id , size_t
    sizeofobject ) ;
  JSAMPARRAY ( *  alloc_sarray )(j_common_ptr cinfo , int pool_id , JDIMENSION
    samplesperrow , JDIMENSION numrows ) ;
  JBLOCKARRAY ( *  alloc_barray )(j_common_ptr cinfo , int pool_id , JDIMENSION
    blocksperrow , JDIMENSION numrows ) ;
  jvirt_sarray_ptr ( *  request_virt_sarray )(j_common_ptr cinfo , int pool_id ,
    JDIMENSION samplesperrow , JDIMENSION numrows , JDIMENSION unitheight ) ;
  jvirt_barray_ptr ( *  request_virt_barray )(j_common_ptr cinfo , int pool_id ,
    JDIMENSION blocksperrow , JDIMENSION numrows , JDIMENSION unitheight ) ;
  void ( *  realize_virt_arrays )(j_common_ptr cinfo ) ;
  JSAMPARRAY ( *  access_virt_sarray )(j_common_ptr cinfo , jvirt_sarray_ptr ptr
    , JDIMENSION start_row , boolean writable ) ;
  JBLOCKARRAY ( *  access_virt_barray )(j_common_ptr cinfo , jvirt_barray_ptr
    ptr , JDIMENSION start_row , boolean writable ) ;
  void ( *  free_pool )(j_common_ptr cinfo , int pool_id ) ;
  void ( *  self_destruct )(j_common_ptr cinfo ) ;
  long max_memory_to_use ;
} ; /*onlytypedef*/

typedef boolean ( *  jpeg_marker_parser_method )(j_decompress_ptr cinfo )
  ; /*typedef*/

extern struct jpeg_error_mgr *  jpeg_std_error(struct jpeg_error_mgr *  err )
  ; /*decdef*/
extern void jpeg_create_compress(j_compress_ptr cinfo ) ; /*decdef*/
extern void jpeg_create_decompress(j_decompress_ptr cinfo ) ; /*decdef*/
extern void jpeg_destroy_compress(j_compress_ptr cinfo ) ; /*decdef*/
extern void jpeg_destroy_decompress(j_decompress_ptr cinfo ) ; /*decdef*/
extern void jpeg_stdio_dest(j_compress_ptr cinfo , FILE *  outfile )
  ; /*decdef*/
extern void jpeg_stdio_src(j_decompress_ptr cinfo , FILE *  infile )
  ; /*decdef*/
extern void jpeg_set_defaults(j_compress_ptr cinfo ) ; /*decdef*/
extern void jpeg_set_colorspace(j_compress_ptr cinfo , J_COLOR_SPACE colorspace
  ) ; /*decdef*/
extern void jpeg_default_colorspace(j_compress_ptr cinfo ) ; /*decdef*/
extern void jpeg_set_quality(j_compress_ptr cinfo , int quality , boolean
  force_baseline ) ; /*decdef*/
extern void jpeg_set_linear_quality(j_compress_ptr cinfo , int scale_factor ,
  boolean force_baseline ) ; /*decdef*/
extern void jpeg_add_quant_table(j_compress_ptr cinfo , int which_tbl , const
  unsigned int *  basic_table , int scale_factor , boolean force_baseline )
  ; /*decdef*/
extern int jpeg_quality_scaling(int quality ) ; /*decdef*/
extern void jpeg_suppress_tables(j_compress_ptr cinfo , boolean suppress )
  ; /*decdef*/
extern JQUANT_TBL *  jpeg_alloc_quant_table(j_common_ptr cinfo ) ; /*decdef*/
extern JHUFF_TBL *  jpeg_alloc_huff_table(j_common_ptr cinfo ) ; /*decdef*/
extern void jpeg_start_compress(j_compress_ptr cinfo , boolean write_all_tables
  ) ; /*decdef*/
extern JDIMENSION jpeg_write_scanlines(j_compress_ptr cinfo , JSAMPARRAY
  scanlines , JDIMENSION num_lines ) ; /*decdef*/
extern void jpeg_finish_compress(j_compress_ptr cinfo ) ; /*decdef*/
extern JDIMENSION jpeg_write_raw_data(j_compress_ptr cinfo , JSAMPIMAGE data ,
  JDIMENSION num_lines ) ; /*decdef*/
extern void jpeg_write_marker(j_compress_ptr cinfo , int marker , const JOCTET
  *  dataptr , unsigned int datalen ) ; /*decdef*/
extern void jpeg_write_tables(j_compress_ptr cinfo ) ; /*decdef*/
extern int jpeg_read_header(j_decompress_ptr cinfo , boolean require_image )
  ; /*decdef*/
extern void jpeg_start_decompress(j_decompress_ptr cinfo ) ; /*decdef*/
extern JDIMENSION jpeg_read_scanlines(j_decompress_ptr cinfo , JSAMPARRAY
  scanlines , JDIMENSION max_lines ) ; /*decdef*/
extern boolean jpeg_finish_decompress(j_decompress_ptr cinfo ) ; /*decdef*/
extern JDIMENSION jpeg_read_raw_data(j_decompress_ptr cinfo , JSAMPIMAGE data ,
  JDIMENSION max_lines ) ; /*decdef*/
extern void jpeg_calc_output_dimensions(j_decompress_ptr cinfo ) ; /*decdef*/
extern void jpeg_set_marker_processor(j_decompress_ptr cinfo , int marker_code ,
  jpeg_marker_parser_method routine ) ; /*decdef*/
extern void jpeg_abort_compress(j_compress_ptr cinfo ) ; /*decdef*/
extern void jpeg_abort_decompress(j_decompress_ptr cinfo ) ; /*decdef*/
extern void jpeg_abort(j_common_ptr cinfo ) ; /*decdef*/
extern void jpeg_destroy(j_common_ptr cinfo ) ; /*decdef*/
extern boolean jpeg_resync_to_restart(j_decompress_ptr cinfo ) ; /*decdef*/

typedef enum  {
  JBUF_PASS_THRU,
  JBUF_CRANK_SOURCE,
  JBUF_SAVE_SOURCE,
  JBUF_CRANK_DEST,
  JBUF_SAVE_AND_PASS
} J_BUF_MODE ; /*typedef*/

struct jpeg_comp_master {
  void ( *  prepare_for_pass )(j_compress_ptr cinfo ) ;
  void ( *  pass_startup )(j_compress_ptr cinfo ) ;
  void ( *  finish_pass )(j_compress_ptr cinfo ) ;
  boolean call_pass_startup ;
  boolean is_last_pass ;
} ; /*onlytypedef*/

struct jpeg_c_main_controller {
  void ( *  start_pass )(j_compress_ptr cinfo , J_BUF_MODE pass_mode ) ;
  void ( *  process_data )(j_compress_ptr cinfo , JSAMPARRAY input_buf ,
    JDIMENSION *  in_row_ctr , JDIMENSION in_rows_avail ) ;
} ; /*onlytypedef*/

struct jpeg_c_prep_controller {
  void ( *  start_pass )(j_compress_ptr cinfo , J_BUF_MODE pass_mode ) ;
  void ( *  pre_process_data )(j_compress_ptr cinfo , JSAMPARRAY input_buf ,
    JDIMENSION *  in_row_ctr , JDIMENSION in_rows_avail , JSAMPIMAGE output_buf
    , JDIMENSION *  out_row_group_ctr , JDIMENSION out_row_groups_avail ) ;
} ; /*onlytypedef*/

struct jpeg_c_coef_controller {
  void ( *  start_pass )(j_compress_ptr cinfo , J_BUF_MODE pass_mode ) ;
  void ( *  compress_data )(j_compress_ptr cinfo , JSAMPIMAGE input_buf ,
    JDIMENSION *  in_mcu_ctr ) ;
} ; /*onlytypedef*/

struct jpeg_color_converter {
  void ( *  start_pass )(j_compress_ptr cinfo ) ;
  void ( *  color_convert )(j_compress_ptr cinfo , JSAMPARRAY input_buf ,
    JSAMPIMAGE output_buf , JDIMENSION output_row , int num_rows ) ;
} ; /*onlytypedef*/

struct jpeg_downsampler {
  void ( *  start_pass )(j_compress_ptr cinfo ) ;
  void ( *  downsample )(j_compress_ptr cinfo , JSAMPIMAGE input_buf ,
    JDIMENSION in_row_index , JSAMPIMAGE output_buf , JDIMENSION
    out_row_group_index ) ;
  boolean need_context_rows ;
} ; /*onlytypedef*/

struct jpeg_forward_dct {
  void ( *  start_pass )(j_compress_ptr cinfo ) ;
  void ( *  forward_DCT )(j_compress_ptr cinfo , jpeg_component_info *  compptr
    , JSAMPARRAY sample_data , JBLOCKROW coef_blocks , JDIMENSION start_row ,
    JDIMENSION start_col , JDIMENSION num_blocks ) ;
} ; /*onlytypedef*/

struct jpeg_entropy_encoder {
  void ( *  start_pass )(j_compress_ptr cinfo , boolean gather_statistics ) ;
  boolean ( *  encode_mcu )(j_compress_ptr cinfo , JBLOCKROW *  MCU_data ) ;
  void ( *  finish_pass )(j_compress_ptr cinfo ) ;
} ; /*onlytypedef*/

struct jpeg_marker_writer {
  void ( *  write_any_marker )(j_compress_ptr cinfo , int marker , const JOCTET
    *  dataptr , unsigned int datalen ) ;
  void ( *  write_file_header )(j_compress_ptr cinfo ) ;
  void ( *  write_frame_header )(j_compress_ptr cinfo ) ;
  void ( *  write_scan_header )(j_compress_ptr cinfo ) ;
  void ( *  write_file_trailer )(j_compress_ptr cinfo ) ;
  void ( *  write_tables_only )(j_compress_ptr cinfo ) ;
} ; /*onlytypedef*/

struct jpeg_decomp_master {
  void ( *  prepare_for_pass )(j_decompress_ptr cinfo ) ;
  void ( *  finish_pass )(j_decompress_ptr cinfo ) ;
  boolean is_last_pass ;
  boolean eoi_processed ;
} ; /*onlytypedef*/

struct jpeg_d_main_controller {
  void ( *  start_pass )(j_decompress_ptr cinfo , J_BUF_MODE pass_mode ) ;
  void ( *  process_data )(j_decompress_ptr cinfo , JSAMPARRAY output_buf ,
    JDIMENSION *  out_row_ctr , JDIMENSION out_rows_avail ) ;
  JDIMENSION num_chunks ;
} ; /*onlytypedef*/

struct jpeg_d_coef_controller {
  void ( *  start_pass )(j_decompress_ptr cinfo , J_BUF_MODE pass_mode ) ;
  boolean ( *  decompress_data )(j_decompress_ptr cinfo , JSAMPIMAGE output_buf
    ) ;
} ; /*onlytypedef*/

struct jpeg_d_post_controller {
  void ( *  start_pass )(j_decompress_ptr cinfo , J_BUF_MODE pass_mode ) ;
  void ( *  post_process_data )(j_decompress_ptr cinfo , JSAMPIMAGE input_buf ,
    JDIMENSION *  in_row_group_ctr , JDIMENSION in_row_groups_avail , JSAMPARRAY
    output_buf , JDIMENSION *  out_row_ctr , JDIMENSION out_rows_avail ) ;
} ; /*onlytypedef*/

struct jpeg_marker_reader {
  void ( *  reset_marker_reader )(j_decompress_ptr cinfo ) ;
  int ( *  read_markers )(j_decompress_ptr cinfo ) ;
  jpeg_marker_parser_method read_restart_marker ;
  jpeg_marker_parser_method process_COM ;
  jpeg_marker_parser_method process_APPn[16] ;
  boolean saw_SOI ;
  boolean saw_SOF ;
  int next_restart_num ;
  unsigned int discarded_bytes ;
} ; /*onlytypedef*/

struct jpeg_entropy_decoder {
  void ( *  start_pass )(j_decompress_ptr cinfo ) ;
  boolean ( *  decode_mcu )(j_decompress_ptr cinfo , JBLOCKROW *  MCU_data ) ;
} ; /*onlytypedef*/

typedef void ( *  inverse_DCT_method_ptr )(j_decompress_ptr cinfo ,
  jpeg_component_info *  compptr , JCOEFPTR coef_block , JSAMPARRAY output_buf ,
  JDIMENSION output_col ) ; /*typedef*/

struct jpeg_inverse_dct {
  void ( *  start_input_pass )(j_decompress_ptr cinfo ) ;
  void ( *  start_output_pass )(j_decompress_ptr cinfo ) ;
  inverse_DCT_method_ptr inverse_DCT[10] ;
} ; /*onlytypedef*/

struct jpeg_upsampler {
  void ( *  start_pass )(j_decompress_ptr cinfo ) ;
  void ( *  upsample )(j_decompress_ptr cinfo , JSAMPIMAGE input_buf ,
    JDIMENSION *  in_row_group_ctr , JDIMENSION in_row_groups_avail , JSAMPARRAY
    output_buf , JDIMENSION *  out_row_ctr , JDIMENSION out_rows_avail ) ;
  boolean need_context_rows ;
} ; /*onlytypedef*/

struct jpeg_color_deconverter {
  void ( *  start_pass )(j_decompress_ptr cinfo ) ;
  void ( *  color_convert )(j_decompress_ptr cinfo , JSAMPIMAGE input_buf ,
    JDIMENSION input_row , JSAMPARRAY output_buf , int num_rows ) ;
} ; /*onlytypedef*/

struct jpeg_color_quantizer {
  void ( *  start_pass )(j_decompress_ptr cinfo , boolean is_pre_scan ) ;
  void ( *  color_quantize )(j_decompress_ptr cinfo , JSAMPARRAY input_buf ,
    JSAMPARRAY output_buf , int num_rows ) ;
  void ( *  finish_pass )(j_decompress_ptr cinfo ) ;
} ; /*onlytypedef*/

extern void jinit_master_compress(j_compress_ptr cinfo ) ; /*decdef*/
extern void jinit_c_main_controller(j_compress_ptr cinfo , boolean
  need_full_buffer ) ; /*decdef*/
extern void jinit_c_prep_controller(j_compress_ptr cinfo , boolean
  need_full_buffer ) ; /*decdef*/
extern void jinit_c_coef_controller(j_compress_ptr cinfo , boolean
  need_full_buffer ) ; /*decdef*/
extern void jinit_color_converter(j_compress_ptr cinfo ) ; /*decdef*/
extern void jinit_downsampler(j_compress_ptr cinfo ) ; /*decdef*/
extern void jinit_forward_dct(j_compress_ptr cinfo ) ; /*decdef*/
extern void jinit_huff_encoder(j_compress_ptr cinfo ) ; /*decdef*/
extern void jinit_marker_writer(j_compress_ptr cinfo ) ; /*decdef*/
extern void jinit_master_decompress(j_decompress_ptr cinfo ) ; /*decdef*/
extern void jinit_d_main_controller(j_decompress_ptr cinfo , boolean
  need_full_buffer ) ; /*decdef*/
extern void jinit_d_coef_controller(j_decompress_ptr cinfo , boolean
  need_full_buffer ) ; /*decdef*/
extern void jinit_d_post_controller(j_decompress_ptr cinfo , boolean
  need_full_buffer ) ; /*decdef*/
extern void jinit_marker_reader(j_decompress_ptr cinfo ) ; /*decdef*/
extern void jinit_huff_decoder(j_decompress_ptr cinfo ) ; /*decdef*/
extern void jinit_inverse_dct(j_decompress_ptr cinfo ) ; /*decdef*/
extern void jinit_upsampler(j_decompress_ptr cinfo ) ; /*decdef*/
extern void jinit_color_deconverter(j_decompress_ptr cinfo ) ; /*decdef*/
extern void jinit_1pass_quantizer(j_decompress_ptr cinfo ) ; /*decdef*/
extern void jinit_2pass_quantizer(j_decompress_ptr cinfo ) ; /*decdef*/
extern void jinit_merged_upsampler(j_decompress_ptr cinfo ) ; /*decdef*/
extern void jinit_memory_mgr(j_common_ptr cinfo ) ; /*decdef*/
extern long jdiv_round_up(long a , long b ) ; /*decdef*/
extern long jround_up(long a , long b ) ; /*decdef*/
extern void jcopy_sample_rows(JSAMPARRAY input_array , int source_row ,
  JSAMPARRAY output_array , int dest_row , int num_rows , JDIMENSION num_cols )
  ; /*decdef*/
extern void jcopy_block_row(JBLOCKROW input_row , JBLOCKROW output_row ,
  JDIMENSION num_blocks ) ; /*decdef*/
extern void jzero_far(void *  target , size_t bytestozero ) ; /*decdef*/

struct spec_image_s {
  JDIMENSION image_width ;
  JDIMENSION image_height ;
  int num_color_components ;
  int max_color_component ;
  J_COLOR_SPACE color_space ;
  double gamma ;
  JSAMPARRAY buffer ;
} ; /*onlytypedef*/

typedef struct spec_image_s spec_image ; /*typedef*/

void spec_read_original_image(char *  filename ) ; /*decdef*/
void spec_allocate_similar_image(spec_image *  pattern , spec_image *  new )
  ; /*decdef*/
void spec_define_subimage_fp(spec_image *  image , spec_image *  subimage ,
  float ulx , float uly , float lrx , float lry ) ; /*decdef*/
void spec_define_subimage_int(spec_image *  image , spec_image *  subimage ,
  int ulx , int uly , int lrx , int lry ) ; /*decdef*/
void spec_free_subimage(spec_image *  subimage ) ; /*decdef*/
void spec_write_image(char *  filename , spec_image *  image ) ; /*decdef*/
void spec_difference_images(spec_image *  a , spec_image *  b , spec_image *  d
  , int row_stride , int col_stride ) ; /*decdef*/
void spec_checksum_image(spec_image *  a , int row_stride , int col_stride )
  ; /*decdef*/
void Usage() ; /*decdef*/
spec_image original_image ; /*decdef*/
spec_image decompressed_image ; /*decdef*/
spec_image difference_image ; /*decdef*/
spec_image sliced_original_image ; /*decdef*/
int debug_flag ; /*decdef*/
int verbose_flag ; /*decdef*/
int histogram_flag ; /*decdef*/
char *  image_filename ; /*decdef*/
int L1_norm_flag ; /*decdef*/
int L2_norm_flag ; /*decdef*/
int difference_flag ; /*decdef*/
int checksum_flag ; /*decdef*/
int x_stride ; /*decdef*/
int y_stride ; /*decdef*/
struct jpeg_compress_struct TBD_image_cinfo ; /*decdef*/
struct jpeg_error_mgr TBD_image_jerr ; /*decdef*/


#pragma boxprintf("pm_message", 0)

#pragma boxprintf("pm_error", 0)
void spec_view_image(char *  filename , char *  comment , spec_image *  image )
{
}

void spec_read_original_image(char *  filename )
{
  FILE *  infile ; /*decdef*/
  pixval max_color_component ; /*decdef*/
  if(! strcmp(filename, "stdin"))
  {
    infile = get_stdin();
  }
  else
  {
    infile = fopen(filename, "r");
    if(infile == 0)
    {
      fprintf(get_stderr(), "error opening input file <%s>\n", filename);
      exit(1);
    }
  }
  original_image.buffer = (JSAMPARRAY )ppm_readppm(infile, (int *  )(&
    original_image.image_width), (int *  )(& original_image.image_height), &
    max_color_component);
  if(original_image.buffer == 0)
  {
    fprintf(get_stderr(), "error allocating decompressed_image.buffer\n");
    exit(1);
  }
  original_image.max_color_component = max_color_component;
  original_image.num_color_components = 3;
  original_image.color_space = JCS_RGB;
}

void spec_allocate_similar_image(spec_image *  pattern , spec_image *  new )
{
  new->image_height = pattern->image_height;
  new->image_width = pattern->image_width;
  new->max_color_component = pattern->max_color_component;
  new->num_color_components = pattern->num_color_components;
  new->color_space = pattern->color_space;
  new->buffer = (JSAMPARRAY )((pixel *  *  )pm_allocarray(pattern->image_width,
    pattern->image_height, sizeof(pixel )));
  if(new->buffer == 0)
  {
    fprintf(get_stderr(), "error allocating new->buffer\n");
    exit(1);
  }
}

void spec_free_image(spec_image *  image )
{
  if(image->buffer)
  {
    pm_freearray((char *  *  )((pixel *  *  )image->buffer),
      image->image_height);
  }
  image->buffer = 0;
  image->image_height = - 1;
  image->image_width = - 1;
  image->max_color_component = - 1;
  image->num_color_components = - 1;
  image->color_space = - 1;
}

void spec_define_subimage_fp(spec_image *  image , spec_image *  subimage ,
  float ulx , float uly , float lrx , float lry )
{
  int in_range = 1 && 0.0 <= ulx && ulx <= 1.0 && 0.0 <= lrx && lrx <= 1.0 &&
    ulx < lrx && 0.0 <= uly && uly <= 1.0 && 0.0 <= lry && lry <= 1.0 && uly <
    lry; /*decdef*/
  if(! in_range)
  {
    fprintf(get_stderr(), "%s:%d: badly defined fp subimage\n", "spec_image.c",
      184);
    fprintf(get_stderr(), "    ul:(%g,%g) lr:(%g,%g)\n", ulx, uly, lrx, lry);
    exit(1);
  }
  spec_define_subimage_int(image, subimage, (int )(ulx * (image->image_width -
    1)), (int )(uly * (image->image_height - 1)), (int )(lrx *
    (image->image_width - 1)), (int )(lry * (image->image_height - 1)));
}

void spec_define_subimage_int(spec_image *  image , spec_image *  subimage ,
  int ulx , int uly , int lrx , int lry )
{
  int j , jj ; /*decdef*/
  int in_range = 1 && 0 <= ulx && ulx < image->image_width && 0 <= lrx && lrx <
    image->image_width && ulx < lrx && 0 <= uly && uly < image->image_height &&
    0 <= lry && lry < image->image_height && uly < lry; /*decdef*/
  if(! in_range)
  {
    fprintf(get_stderr(), "%s:%d: badly defined int subimage\n", "spec_image.c",
      217);
    fprintf(get_stderr(), "    ul:(%d,%d) lr:(%d,%d) image:(%d,%d)\n", ulx, uly,
      lrx, lry, image->image_width, image->image_height);
    exit(1);
  }
  subimage->image_height = lry - uly + 1;
  subimage->image_width = lrx - ulx + 1;
  subimage->max_color_component = image->max_color_component;
  subimage->num_color_components = image->num_color_components;
  subimage->color_space = image->color_space;
  subimage->buffer = (JSAMPARRAY )malloc(subimage->image_height * sizeof(*
    subimage->buffer));
  if(subimage->buffer == 0)
  {
    fprintf(get_stderr(), "error allocating subimage->buffer\n");
    exit(1);
  }
  for(j = uly, jj = 0; j <= lry; j++, jj++)
  {
    (subimage->buffer)[jj] = (image->buffer)[j] + image->num_color_components *
      ulx;
  }
}

void spec_free_subimage(spec_image *  subimage )
{
  subimage->image_height = 0;
  subimage->image_width = 0;
  subimage->max_color_component = 0;
  subimage->num_color_components = 0;
  subimage->color_space = 0;
  if(subimage->buffer)
  {
    free(subimage->buffer);
  }
  subimage->buffer = 0;
}

void spec_write_image(char *  filename , spec_image *  image )
{
  FILE *  outfile ; /*decdef*/
  if(! strcmp(filename, "stdout"))
  {
    outfile = get_stdout();
  }
  else
  {
    outfile = fopen(filename, "w+");
    if(outfile == 0)
    {
      fprintf(get_stderr(), "error opening output file <%s>\n", filename);
      exit(1);
    }
  }
  ppm_writeppm(outfile, (pixel *  *  )image->buffer, image->image_width,
    image->image_height, image->max_color_component, 1);
  if(fclose(outfile))
  {
    fprintf(get_stderr(), "error closing output file <%s>\n", filename);
    exit(0);
  }
}

int histogram[128 - - 128 + 1] ; /*decdef*/
int histo_underflow = 0; /*decdef*/
int histo_overflow = 0; /*decdef*/

static zero_histogram()
{
  int i ; /*decdef*/
  histo_underflow = 0;
  histo_overflow = 0;
  for(i = - 128; i <= 128; i++)
  {
    histogram[i - - 128] = 0;
  }
}

static print_histogram()
{
  int i ; /*decdef*/
  printf("underflow\t%d\n", histo_underflow);
  printf("overflow\t%d\n", histo_overflow);
  for(i = - 128; i <= 128; i++)
  {
    printf("%d  - %d\n", i, histogram[i - - 128]);
  }
  printf("\n");
}

void spec_difference_images(spec_image *  a , spec_image *  b , spec_image *  d
  , int row_stride , int col_stride )
{
  int row , col , channel ; /*decdef*/
  int dif ; /*decdef*/
  int bias = a->max_color_component >> 1; /*decdef*/
  unsigned L1_norm = 0; /*decdef*/
  unsigned L2_norm = 0; /*decdef*/
  if(a->image_width != b->image_width || a->image_height != b->image_height ||
    a->num_color_components != b->num_color_components || a->max_color_component
    != b->max_color_component || a->color_space != b->color_space || a->gamma !=
    b->gamma)
  {
    fprintf(get_stderr(), "error: mismatched images differencing\n");
    exit(1);
  }
  d->image_width = a->image_width;
  d->image_height = a->image_height;
  d->num_color_components = a->num_color_components;
  d->max_color_component = a->max_color_component;
  d->color_space = a->color_space;
  d->gamma = a->gamma;
  zero_histogram();
  for(row = 0; row < d->image_height; row += row_stride)
  {
    for(col = 0; col < d->image_width; col += col_stride)
    {
      for(channel = 0; channel < d->num_color_components; channel++)
      {
	dif = ((a->buffer)[row])[col * d->num_color_components + channel] -
	  ((b->buffer)[row])[col * d->num_color_components + channel];
	if(histogram_flag)
	{
	  if(dif < - 128)
	  {
	    histo_underflow++;
	  }
	  else
	  {
	    if(dif > 128)
	    {
	      histo_overflow++;
	    }
	    else
	    {
	      histogram[dif - - 128]++;
	    }
	  }
	}
	if(difference_flag)
	{
	  if(dif + bias < 0)
	  {
	    ((d->buffer)[row])[col * d->num_color_components + channel] = 0;
	  }
	  else
	  {
	    if(dif + bias > d->max_color_component)
	    {
	      ((d->buffer)[row])[col * d->num_color_components + channel] =
		d->max_color_component - 1;
	    }
	    else
	    {
	      ((d->buffer)[row])[col * d->num_color_components + channel] = dif
		+ bias;
	    }
	  }
	}
	if(L1_norm_flag)
	{
	  dif = dif >= 0 ? dif : - dif;
	  if(dif > 64)
	    dif = 64;
	  if(L1_norm + dif > 1024 * 1024 * 1024)
	  {
	    L1_norm = 1024 * 1024 * 1024;
	  }
	  else
	  {
	    L1_norm += dif;
	  }
	}
	if(L2_norm_flag)
	{
	  dif = dif * dif;
	  if(L2_norm + dif > 1024 * 1024 * 1024)
	  {
	    L2_norm = 1024 * 1024 * 1024;
	  }
	  else
	  {
	    L2_norm += dif;
	  }
	}
      }
    }
  }
  if(L1_norm_flag)
  {
    printf("L1 norm = %d\n", L1_norm);
  }
  if(L2_norm_flag)
  {
    printf("L2 norm = %d\n", L2_norm);
  }
  if(histogram_flag)
  {
    print_histogram();
  }
}

void spec_checksum_image(spec_image *  a , int row_stride , int col_stride )
{
  int row , col , channel ; /*decdef*/
  int checksum = 0; /*decdef*/
  for(row = 0; row < a->image_height; row += row_stride)
  {
    for(col = 0; col < a->image_width; col += col_stride)
    {
      for(channel = 0; channel < a->num_color_components; channel++)
      {
	checksum ^= ((a->buffer)[row])[col * a->num_color_components + channel];
      }
    }
  }
  printf("checksum: %d\n", checksum);
}


#pragma combiner("./spec_jmemdst.i", "-g -O -I/home/scott/wrk/safec/cil/lib ")

#pragma boxalloc("malloc", nozero, sizein(0))

#pragma boxalloc("alloca", nozero, sizein(0))

#pragma boxalloc("calloc", zero, sizemul(0, 1))

#pragma boxprintf("printf", 0)

#pragma boxprintf("fprintf", 1)

#pragma boxprintf("sprintf", 1)

#pragma boxprintf("snprintf", 2)

#pragma boxpoly("memcpy")

#pragma boxexported("main")
typedef int ptrdiff_t ; /*typedef*/

typedef enum  {
  JMSG_NOMESSAGE,
  JERR_ARITH_NOTIMPL,
  JERR_BAD_ALIGN_TYPE,
  JERR_BAD_ALLOC_CHUNK,
  JERR_BAD_BUFFER_MODE,
  JERR_BAD_COMPONENT_ID,
  JERR_BAD_DCTSIZE,
  JERR_BAD_IN_COLORSPACE,
  JERR_BAD_J_COLORSPACE,
  JERR_BAD_LENGTH,
  JERR_BAD_MCU_SIZE,
  JERR_BAD_POOL_ID,
  JERR_BAD_PRECISION,
  JERR_BAD_SAMPLING,
  JERR_BAD_STATE,
  JERR_BAD_VIRTUAL_ACCESS,
  JERR_BUFFER_SIZE,
  JERR_CANT_SUSPEND,
  JERR_CCIR601_NOTIMPL,
  JERR_COMPONENT_COUNT,
  JERR_CONVERSION_NOTIMPL,
  JERR_DAC_INDEX,
  JERR_DAC_VALUE,
  JERR_DHT_COUNTS,
  JERR_DHT_INDEX,
  JERR_DQT_INDEX,
  JERR_EMPTY_IMAGE,
  JERR_EMS_READ,
  JERR_EMS_WRITE,
  JERR_EOI_EXPECTED,
  JERR_FILE_READ,
  JERR_FILE_WRITE,
  JERR_FRACT_SAMPLE_NOTIMPL,
  JERR_HUFF_CLEN_OVERFLOW,
  JERR_HUFF_MISSING_CODE,
  JERR_IMAGE_TOO_BIG,
  JERR_INPUT_EMPTY,
  JERR_INPUT_EOF,
  JERR_JFIF_MAJOR,
  JERR_NOTIMPL,
  JERR_NOT_COMPILED,
  JERR_NO_BACKING_STORE,
  JERR_NO_HUFF_TABLE,
  JERR_NO_IMAGE,
  JERR_NO_QUANT_TABLE,
  JERR_NO_SOI,
  JERR_OUT_OF_MEMORY,
  JERR_QUANT_COMPONENTS,
  JERR_QUANT_FEW_COLORS,
  JERR_QUANT_MANY_COLORS,
  JERR_SOF_DUPLICATE,
  JERR_SOF_NO_SOS,
  JERR_SOF_UNSUPPORTED,
  JERR_SOI_DUPLICATE,
  JERR_SOS_NO_SOF,
  JERR_TFILE_CREATE,
  JERR_TFILE_READ,
  JERR_TFILE_SEEK,
  JERR_TFILE_WRITE,
  JERR_TOO_LITTLE_DATA,
  JERR_UNKNOWN_MARKER,
  JERR_VIRTUAL_BUG,
  JERR_WIDTH_OVERFLOW,
  JERR_XMS_READ,
  JERR_XMS_WRITE,
  JMSG_COPYRIGHT,
  JMSG_VERSION,
  JTRC_16BIT_TABLES,
  JTRC_ADOBE,
  JTRC_APP0,
  JTRC_APP14,
  JTRC_DAC,
  JTRC_DHT,
  JTRC_DQT,
  JTRC_DRI,
  JTRC_EMS_CLOSE,
  JTRC_EMS_OPEN,
  JTRC_EOI,
  JTRC_HUFFBITS,
  JTRC_JFIF,
  JTRC_JFIF_BADTHUMBNAILSIZE,
  JTRC_JFIF_MINOR,
  JTRC_JFIF_THUMBNAIL,
  JTRC_MISC_MARKER,
  JTRC_PARMLESS_MARKER,
  JTRC_QUANTVALS,
  JTRC_QUANT_3_NCOLORS,
  JTRC_QUANT_NCOLORS,
  JTRC_QUANT_SELECTED,
  JTRC_RECOVERY_ACTION,
  JTRC_RST,
  JTRC_SMOOTH_NOTIMPL,
  JTRC_SOF,
  JTRC_SOF_COMPONENT,
  JTRC_SOI,
  JTRC_SOS,
  JTRC_SOS_COMPONENT,
  JTRC_TFILE_CLOSE,
  JTRC_TFILE_OPEN,
  JTRC_UNKNOWN_IDS,
  JTRC_XMS_CLOSE,
  JTRC_XMS_OPEN,
  JWRN_ADOBE_XFORM,
  JWRN_EXTRANEOUS_DATA,
  JWRN_HIT_MARKER,
  JWRN_HUFF_BAD_CODE,
  JWRN_JPEG_EOF,
  JWRN_MUST_RESYNC,
  JWRN_NOT_SEQUENTIAL,
  JWRN_TOO_MUCH_DATA,
  JMSG_LASTMSGCODE
} J_MESSAGE_CODE ; /*typedef*/

typedef struct  {
  struct jpeg_destination_mgr pub ;
  JOCTET *  jmd_buffer ;
  int jmd_max_bufsz ;
  int *  jmd_actual_bufszptr ;
} jmd_my_destination_mgr ; /*typedef*/

typedef jmd_my_destination_mgr *  jmd_my_dest_ptr ; /*typedef*/

static void jmd_init_destination(j_compress_ptr cinfo )
{
  jmd_my_dest_ptr dest = (jmd_my_dest_ptr )cinfo->dest; /*decdef*/
  (dest->pub).next_output_byte = dest->jmd_buffer;
  (dest->pub).free_in_buffer = dest->jmd_max_bufsz;
  * dest->jmd_actual_bufszptr = 0;
}

static boolean jmd_empty_output_buffer(j_compress_ptr cinfo )
{
  fprintf(get_stderr(), "jmd_empty_output_buffer called\n");
  exit(1);
  return 1;
}

static void jmd_term_destination(j_compress_ptr cinfo )
{
  jmd_my_dest_ptr dest = (jmd_my_dest_ptr )cinfo->dest; /*decdef*/
  * dest->jmd_actual_bufszptr = dest->jmd_max_bufsz -
    (dest->pub).free_in_buffer;
}

void spec_jpeg_mem_dest(j_compress_ptr cinfo , JOCTET *  jmd_buffer ,
  int jmd_max_bufsz , int *  jmd_actual_bufszptr )
{
  jmd_my_dest_ptr dest ; /*decdef*/
  if(cinfo->dest == (void *  )0)
  {
    cinfo->dest = (struct jpeg_destination_mgr *  )(*
      (cinfo->mem)->alloc_small)((j_common_ptr )cinfo, 0, (size_t
      )sizeof(jmd_my_destination_mgr ));
    if(cinfo->dest == (void *  )0)
    {
      fprintf(get_stderr(),
	"error allocating jpeg memory destination buffer\n");
      exit(1);
    }
  }
  dest = (jmd_my_dest_ptr )cinfo->dest;
  (dest->pub).init_destination = jmd_init_destination;
  (dest->pub).empty_output_buffer = jmd_empty_output_buffer;
  (dest->pub).term_destination = jmd_term_destination;
  dest->jmd_buffer = jmd_buffer;
  dest->jmd_max_bufsz = jmd_max_bufsz;
  dest->jmd_actual_bufszptr = jmd_actual_bufszptr;
}


#pragma combiner("./spec_jmemsrc.i", "-g -O -I/home/scott/wrk/safec/cil/lib ")

#pragma boxalloc("malloc", nozero, sizein(0))

#pragma boxalloc("alloca", nozero, sizein(0))

#pragma boxalloc("calloc", zero, sizemul(0, 1))

#pragma boxprintf("printf", 0)

#pragma boxprintf("fprintf", 1)

#pragma boxprintf("sprintf", 1)

#pragma boxprintf("snprintf", 2)

#pragma boxpoly("memcpy")

#pragma boxexported("main")
typedef struct  {
  struct jpeg_source_mgr pub ;
} jms_my_source_mgr ; /*typedef*/

typedef jms_my_source_mgr *  jms_my_src_ptr ; /*typedef*/

static void jms_init_source(j_decompress_ptr dinfo )
{
}

static boolean jms_fill_input_buffer(j_decompress_ptr dinfo )
{
  fprintf(get_stderr(), "Error: jms_fill_input_buffer_called\n");
  exit(1);
  return 1;
}

static void jms_skip_input_data(j_decompress_ptr dinfo , long num_bytes )
{
  jms_my_src_ptr src = (jms_my_src_ptr )dinfo->src; /*decdef*/
  (src->pub).next_input_byte += (size_t )num_bytes;
  (src->pub).bytes_in_buffer -= (size_t )num_bytes;
  if((src->pub).bytes_in_buffer < 0)
  {
    fprintf(get_stderr(), "jms_skip_input_data skips past end\n");
    exit(1);
  }
}

static void jms_term_source(j_decompress_ptr dinfo )
{
}

void spec_jpeg_mem_src(j_decompress_ptr dinfo , JOCTET *  jms_buffer ,
  int jms_bufsz )
{
  jms_my_src_ptr src ; /*decdef*/
  if(dinfo->src == (void *  )0)
  {
    dinfo->src = (struct jpeg_source_mgr *  )(*
      (dinfo->mem)->alloc_small)((j_common_ptr )dinfo, 0, (size_t
      )sizeof(jms_my_source_mgr ));
  }
  src = (jms_my_src_ptr )dinfo->src;
  (src->pub).init_source = jms_init_source;
  (src->pub).fill_input_buffer = jms_fill_input_buffer;
  (src->pub).skip_input_data = jms_skip_input_data;
  (src->pub).resync_to_restart = jpeg_resync_to_restart;
  (src->pub).term_source = jms_term_source;
  (src->pub).bytes_in_buffer = jms_bufsz;
  (src->pub).next_input_byte = jms_buffer;
}


#pragma combiner("./spec_main.i", "-g -O -I/home/scott/wrk/safec/cil/lib ")

#pragma boxalloc("malloc", nozero, sizein(0))

#pragma boxalloc("alloca", nozero, sizein(0))

#pragma boxalloc("calloc", zero, sizemul(0, 1))

#pragma boxprintf("printf", 0)

#pragma boxprintf("fprintf", 1)

#pragma boxprintf("sprintf", 1)

#pragma boxprintf("snprintf", 2)

#pragma boxpoly("memcpy")

#pragma boxexported("main")
char rcsid[]
  = "$Header$"; /*decdef*/
int jpeg_compressed_data_max_size = 16 * 1024 * 1024; /*decdef*/
int jpgcmpdatactsiz = 0; /*decdef*/
JOCTET jpeg_compressed_data[16 * 1024 * 1024] ; /*decdef*/
int loop_comp_quality ; /*decdef*/
int loop_comp_smooth ; /*decdef*/
int loop_comp_opt ; /*decdef*/

struct coord_s {
  float x , y ;
} ; /*onlytypedef*/

struct subimage_s {
  struct coord_s upper_left ;
  struct coord_s lower_right ;
} ; /*onlytypedef*/

struct compression_parameter_s {
  int quality ;
  int optimize_coding ;
  int smoothing_factor ;
  struct subimage_s subimage ;
} ; /*onlytypedef*/

struct compression_parameter_s compression_parameter = {100, 1, 0, {{0.0, 0.0},
  {1.0, 1.0}}}; /*decdef*/

struct decompression_parameter_s {
  int quantize_colors ;
  int do_fancy_upsampling ;
  int desired_number_of_colors ;
  int two_pass_quantize ;
  int dither_mode ;
} ; /*onlytypedef*/

struct decompression_parameter_s decompression_parameter = {0, 0, 0, 0,
  JDITHER_NONE}; /*decdef*/

static void compress(struct compression_parameter_s *  cp )
{
  int nlines ; /*decdef*/
  struct jpeg_compress_struct cinfo ; /*decdef*/
  struct jpeg_error_mgr jerr ; /*decdef*/
  cinfo.err = jpeg_std_error(& jerr);
  jpeg_create_compress(& cinfo);
  cinfo.image_width = sliced_original_image.image_width;
  cinfo.image_height = sliced_original_image.image_height;
  cinfo.input_components = sliced_original_image.num_color_components;
  cinfo.in_color_space = sliced_original_image.color_space;
  jpeg_set_defaults(& cinfo);
  jpeg_set_quality(& cinfo, cp->quality, 1);
  cinfo.optimize_coding = cp->optimize_coding;
  cinfo.smoothing_factor = cp->smoothing_factor;
  spec_jpeg_mem_dest(& cinfo, jpeg_compressed_data,
    jpeg_compressed_data_max_size, & jpgcmpdatactsiz);
  jpeg_start_compress(& cinfo, 1);
  nlines = jpeg_write_scanlines(& cinfo, sliced_original_image.buffer,
    sliced_original_image.image_height);
  if(nlines != sliced_original_image.image_height)
  {
    fprintf(get_stderr(), "Error: jpeg_write_scanlines returned %d not %d\n",
      nlines, sliced_original_image.image_height);
    exit(1);
  }
  jpeg_finish_compress(& cinfo);
  jpeg_destroy_compress(& cinfo);
}

static void decompress(struct decompression_parameter_s *  dp )
{
  int nlines ; /*decdef*/
  struct jpeg_decompress_struct dinfo ; /*decdef*/
  struct jpeg_error_mgr jerr ; /*decdef*/
  dinfo.err = jpeg_std_error(& jerr);
  jpeg_create_decompress(& dinfo);
  spec_jpeg_mem_src(& dinfo, jpeg_compressed_data, jpgcmpdatactsiz);
  (void )jpeg_read_header(& dinfo, 1);
  dinfo.quantize_colors = dp->quantize_colors;
  dinfo.desired_number_of_colors = dp->desired_number_of_colors;
  dinfo.two_pass_quantize = dp->two_pass_quantize;
  dinfo.dither_mode = dp->dither_mode;
  dinfo.do_fancy_upsampling = dp->do_fancy_upsampling;
  jpeg_start_decompress(& dinfo);
  while(dinfo.output_scanline < dinfo.output_height)
  {
    nlines = jpeg_read_scanlines(& dinfo, decompressed_image.buffer +
      dinfo.output_scanline, dinfo.image_height - dinfo.output_scanline);
  }
  (void )jpeg_finish_decompress(& dinfo);
  decompressed_image.image_height = dinfo.image_height;
  decompressed_image.image_width = dinfo.image_width;
  jpeg_destroy_decompress(& dinfo);
}

static void print_parameters(char *  image_filename ,
  struct compression_parameter_s *  cp , struct decompression_parameter_s *  dp
  )
{
  int uncompressed_data_size = sliced_original_image.image_width *
    sliced_original_image.image_height *
    sliced_original_image.num_color_components; /*decdef*/
  printf("\n");
  printf("image filename: \"%s\"\n", image_filename);
  printf("compression statistics:\n");
  printf("\tuncompressed data size:   %d\n", uncompressed_data_size);
  printf("\tcompressed data size:   %d\n", jpgcmpdatactsiz);
  printf("compression parameters:\n");
  printf("\tquality\t        : %d\n", cp->quality);
  printf("\toptimize_coding : %d\n", cp->optimize_coding);
  printf("\tsmoothing_factor: %d\n", cp->smoothing_factor);
  printf("\tsubimage    \t: ul(%g,%g) lr(%g,%g)\n",
    ((cp->subimage).upper_left).x, ((cp->subimage).upper_left).y,
    ((cp->subimage).lower_right).x, ((cp->subimage).lower_right).y);
  printf("decompression parameters:\n");
  printf("\tquantize_colors         : %d\n", dp->quantize_colors);
  printf("\tdo_fancy_upsampling     : %d\n", dp->do_fancy_upsampling);
  printf("\tdesired_number_of_colors: %d\n", dp->desired_number_of_colors);
  printf("\ttwo_pass_quantize       : %d\n", dp->two_pass_quantize);
  printf("\tdither_mode             : %d\n", dp->dither_mode);
}

static void go_execute_compression()
{
  if(image_filename == 0)
  {
    fprintf(get_stderr(), "Error: have not defined -image_file\n");
    Usage();
    exit(1);
  }
  spec_free_subimage(& sliced_original_image);
  spec_define_subimage_fp(& original_image, & sliced_original_image,
    ((compression_parameter.subimage).upper_left).x,
    ((compression_parameter.subimage).upper_left).y,
    ((compression_parameter.subimage).lower_right).x,
    ((compression_parameter.subimage).lower_right).y);
  compress(& compression_parameter);
  if(verbose_flag)
  {
    print_parameters(image_filename, & compression_parameter, &
      decompression_parameter);
  }
}

static void go_execute_decompression()
{
  decompress(& decompression_parameter);
  spec_difference_images(& sliced_original_image, & decompressed_image, &
    difference_image, y_stride, x_stride);
  if(checksum_flag)
  {
    spec_checksum_image(& decompressed_image, y_stride, x_stride);
  }
}

static void go_execute_compression_and_decompression()
{
  go_execute_compression();
  go_execute_decompression();
  if(debug_flag)
  {
    spec_view_image("new_original_image.ppm", "", & original_image);
    spec_view_image("new_sliced_original_image.ppm", "", &
      sliced_original_image);
    spec_view_image("new_decompressed_image.ppm", "", & decompressed_image);
    spec_view_image("new_difference_image.ppm", "", & difference_image);
  }
}

void Usage()
{
  fprintf(get_stderr(),
    "spec_jpeg - prototype JPEG benchmark for SPEC95\narguments:\n    -GO\n    \tactually perform a JPEG compression and decompression cycle,\n    \tevaluating results, using parameters specified to the left\n    -GO.compress\n    -GO.decompress\n    \texecute compression and decompression independently,\n    \te.g. when benchmarking, to balance weightings\n\n    -image_file\t<filename>\n    -subimage ulx uly rlx rly\n    \t4 FP values specifying coordinates of upper left (UL)\n    \tand lower right (LR) corners of subimage,\n    \twhere (0,0) is UL and (1,1) are UL and LR corners\n    \tof original image.\n\n    -compression.quality <0-100>\n    \tlowest..highest quality\n    -compression.optimize_coding <0/1>\n    \tdo not/do compute optimum Huffman coding tables\n    -compression.smoothing_factor <0-100>\n    \tminimal..maximal smoothing\n\n    -decompression.quantize_colors <0/1>\n    -decompression.do_fancy_upsampling <0/1>\n    -decompression.desired_number_of_colors <n>\n    \tnumber of colours to quantize to\n    -decompression.two_pass_quantize <0/1>\n    -decompression.dither_mode <mode>\n    \tNONE, ORDERED, or FS\n\n    -difference.image <0/1>\n    \tcalculate the difference of the original and decompressed images\n    -difference.histogram <0/1>\n    \tprint a histogram of RGB differences\n    -difference.L1_norm <0/1>\n    \tcalculate an L1 norm (sum of absolute values of differences)\n    -difference.L2_norm <0/1>\n    \tcalculate an L2 norm (sum of squares of differences)\n    -difference.row_stride <n>\n    -difference.row_stride <n>\n    \tonly look at ever Nth row or column\n    \tas a quick and dirty check\n\n    -checksum <0/1>\n    \tcalculate simple XOR  checksum of the image\n    \tusing row and column strides defined above\n\n    Miscellaneous options:\n\t-help\n\t-usage\n\t    print this message\n\t-verbose <0/1>\n    \t-comment <comment-token>\n    \t-comment.begin ... -comment.end\n    \t-end\n    \t    stop command line parsing\n    \t-debug <0/1>\n    \t    enables debugging (if program was compiled with it)\n\n")
    ;
}

static int parse_args(char *  *  argv , int argstart )
{
  int i = argstart; /*decdef*/
  int go ; /*decdef*/
  for(; argv[i]; i++)
  {
    go = 0;
    if(0)
    {
    }
    else
    {
      if(! strcmp(argv[i], "-image_file"))
      {
	image_filename = argv[++ i];
	spec_free_image(& original_image);
	spec_free_image(& decompressed_image);
	spec_free_image(& difference_image);
	spec_read_original_image(image_filename);
	spec_allocate_similar_image(& original_image, & decompressed_image);
	spec_allocate_similar_image(& original_image, & difference_image);
      }
      else
      {
	if(! strcmp(argv[i], "-subimage"))
	{
	  extern int ( *  __errno_location() ) ; /*decdef*/
	  float ulx , uly , lrx , lry ; /*decdef*/
	  if(argv[i + 1] == 0 || argv[i + 2] == 0 || argv[i + 3] == 0 || argv[i
	    + 4] == 0)
	  {
	    fprintf(get_stderr(),
	      "Expected 4 floating point parameters after -subimage\n");
	    Usage();
	    exit(1);
	  }
	  * __errno_location() = 0;
	  ulx = atof(argv[i + 1]);
	  uly = atof(argv[i + 2]);
	  lrx = atof(argv[i + 3]);
	  lry = atof(argv[i + 4]);
	  i += 4;
	  if(* __errno_location() != 0)
	  {
	    fprintf(get_stderr(),
	      "Expected 4 floating point parameters after -subimage\n");
	    Usage();
	    exit(1);
	  }
	  ((compression_parameter.subimage).upper_left).x = ulx;
	  ((compression_parameter.subimage).upper_left).y = uly;
	  ((compression_parameter.subimage).lower_right).x = lrx;
	  ((compression_parameter.subimage).lower_right).y = lry;
	}
	else
	{
	  if(! strcmp(argv[i], "-compression.quality"))
	  {
	    compression_parameter.quality = atoi(argv[++ i]);
	  }
	  else
	  {
	    if(! strcmp(argv[i], "-compression.optimize_coding"))
	    {
	      compression_parameter.optimize_coding = atoi(argv[++ i]);
	    }
	    else
	    {
	      if(! strcmp(argv[i], "-compression.smoothing_factor"))
	      {
		compression_parameter.smoothing_factor = atoi(argv[++ i]);
	      }
	      else
	      {
		if(! strcmp(argv[i], "-compression.smoothing_factor"))
		{
		  compression_parameter.smoothing_factor = atoi(argv[++ i]);
		}
		else
		{
		  if(! strcmp(argv[i], "-decompression.quantize_colors"))
		  {
		    decompression_parameter.quantize_colors = atoi(argv[++ i]);
		  }
		  else
		  {
		    if(! strcmp(argv[i], "-decompression.do_fancy_upsampling"))
		    {
		      decompression_parameter.do_fancy_upsampling = atoi(argv[++
			i]);
		    }
		    else
		    {
		      if(! strcmp(argv[i],
			"-decompression.desired_number_of_colors"))
		      {
			decompression_parameter.desired_number_of_colors =
			  atoi(argv[++ i]);
		      }
		      else
		      {
			if(! strcmp(argv[i],
			  "-decompression.two_pass_quantize"))
			{
			  decompression_parameter.two_pass_quantize =
			    atoi(argv[++ i]);
			}
			else
			{
			  if(! strcmp(argv[i], "-decompression.dither_mode"))
			  {
			    ++ i;
			    if(! strcmp(argv[i], "NONE"))
			    {
			      decompression_parameter.dither_mode =
				JDITHER_NONE;
			    }
			    else
			    {
			      if(! strcmp(argv[i], "ORDERED"))
			      {
				decompression_parameter.dither_mode =
				  JDITHER_ORDERED;
			      }
			      else
			      {
				if(! strcmp(argv[i], "FS"))
				{
				  decompression_parameter.dither_mode =
				    JDITHER_FS;
				}
				else
				{
				  fprintf(get_stderr(),
				    "Unrecognized -decompression.dither_mode <%s>\n",
				    argv[i]);
				  fprintf(get_stderr(),
				    "Values supported are:\n");
				  fprintf(get_stderr(),
				    "    -decompression.dither_mode NONE\n");
				  fprintf(get_stderr(),
				    "    -decompression.dither_mode ORDERED\n");
				  fprintf(get_stderr(),
				    "    -decompression.dither_mode FS\n");
				  exit(1);
				}
			      }
			    }
			  }
			  else
			  {
			    if(! strcmp(argv[i], "-difference.image"))
			    {
			      difference_flag = atoi(argv[++ i]);
			    }
			    else
			    {
			      if(! strcmp(argv[i], "-difference.x_stride"))
			      {
				x_stride = atoi(argv[++ i]);
			      }
			      else
			      {
				if(! strcmp(argv[i], "-difference.y_stride"))
				{
				  y_stride = atoi(argv[++ i]);
				}
				else
				{
				  if(! strcmp(argv[i], "-difference.histogram"))
				  {
				    histogram_flag = atoi(argv[++ i]);
				  }
				  else
				  {
				    if(! strcmp(argv[i], "-difference.L1_norm"))
				    {
				      L1_norm_flag = atoi(argv[++ i]);
				    }
				    else
				    {
				      if(! strcmp(argv[i],
					"-difference.L2_norm"))
				      {
					L2_norm_flag = atoi(argv[++ i]);
				      }
				      else
				      {
					if(! strcmp(argv[i], "-checksum"))
					{
					  checksum_flag = atoi(argv[++ i]);
					}
					else
					{
					  if(! strcmp(argv[i], "-GO"))
					  {
					    go = 1;
					    go_execute_compression_and_decompression
					      ();
					  }
					  else
					  {
					    if(! strcmp(argv[i],
					      "-GO.compress"))
					    {
					      go = 1;
					      go_execute_compression();
					    }
					    else
					    {
					      if(! strcmp(argv[i],
						"-GO.decompress"))
					      {
						go = 1;
						go_execute_decompression();
					      }
					      else
					      {
						if(! strcmp(argv[i],
						  "-GO.findoptcomp"))
						{
						  loop_comp_quality =
						    compression_parameter.quality
						    ;
						  loop_comp_smooth =
						    compression_parameter.smoothing_factor
						    ;
						  for(compression_parameter.quality
						    = loop_comp_quality;
						    compression_parameter.quality
						    > 10;
						    compression_parameter.quality
						    =
						    compression_parameter.quality
						    - 10)
						  {
						    for(compression_parameter.smoothing_factor
						      = loop_comp_smooth;
						      compression_parameter.smoothing_factor
						      > 10;
						      compression_parameter.smoothing_factor
						      =
						      compression_parameter.smoothing_factor
						      - 10)
						    {
						      compression_parameter.optimize_coding
							= 0;
						      go = 1;
						      go_execute_compression_and_decompression
							();
						      compression_parameter.optimize_coding
							= 1;
						      go = 1;
						      go_execute_compression_and_decompression
							();
						    }
						  }
						}
						else
						{
						  if(! strcmp(argv[i],
						    "-usage"))
						  {
						    Usage();
						  }
						  else
						  {
						    if(! strcmp(argv[i],
						      "-help"))
						    {
						      Usage();
						    }
						    else
						    {
						      if(! strcmp(argv[i],
							"-debug"))
						      {
							debug_flag =
							  atoi(argv[++ i]);
						      }
						      else
						      {
							if(! strcmp(argv[i],
							  "-verbose"))
							{
							  verbose_flag =
							    atoi(argv[++ i]);
							}
							else
							{
							  if(! strcmp(argv[i],
							    "-comment"))
							  {
  ++ i;
							  }
							  else
							  {
  if(! strcmp(argv[i], "-comment.begin"))
  {
    for(; ; )
    {
      ++ i;
      if(argv[i] == 0)
      {
	fprintf(get_stderr(), "Error: -comment.begin without a -comment.end\n");
	Usage();
	exit(1);
      }
      if(! strcmp(argv[i], "-comment.end"))
      {
	break;
      }
    }
  }
  else
  {
    if(! strcmp(argv[i], "-end"))
    {
      exit(0);
    }
    else
    {
      fprintf(get_stderr(), "Unrecognized argument <%s>\n", argv[i]);
      Usage();
      exit(1);
    }
  }
							  }
							}
						      }
						    }
						  }
						}
					      }
					    }
					  }
					}
				      }
				    }
				  }
				}
			      }
			    }
			  }
			}
		      }
		    }
		  }
		}
	      }
	    }
	  }
	}
      }
    }
  }
  if(go == 0)
  {
    fprintf(get_stderr(), "Warning: no -GO argument\n");
    go_execute_compression_and_decompression();
  }
  return i;
}

int main(int argc , char *  *  argv )
{
  verbose_flag = 0;
  histogram_flag = 0;
  image_filename = 0;
  L1_norm_flag = 1;
  L2_norm_flag = 1;
  difference_flag = 1;
  checksum_flag = 1;
  x_stride = 1;
  y_stride = 1;
  (void )parse_args(argv, 1);
  exit(0);
}


#pragma combiner("./rdppm.i", "-g -O -I/home/scott/wrk/safec/cil/lib ")

#pragma boxalloc("malloc", nozero, sizein(0))

#pragma boxalloc("alloca", nozero, sizein(0))

#pragma boxalloc("calloc", zero, sizemul(0, 1))

#pragma boxprintf("printf", 0)

#pragma boxprintf("fprintf", 1)

#pragma boxprintf("sprintf", 1)

#pragma boxprintf("snprintf", 2)

#pragma boxpoly("memcpy")

#pragma boxexported("main")
typedef enum  {
  JMSG_FIRSTADDONCODE = 1000,
  JERR_BMP_BADCMAP,
  JERR_BMP_BADDEPTH,
  JERR_BMP_BADHEADER,
  JERR_BMP_BADPLANES,
  JERR_BMP_COLORSPACE,
  JERR_BMP_COMPRESSED,
  JERR_BMP_NOT,
  JTRC_BMP,
  JTRC_BMP_MAPPED,
  JTRC_BMP_OS2,
  JTRC_BMP_OS2_MAPPED,
  JERR_GIF_BUG,
  JERR_GIF_CODESIZE,
  JERR_GIF_COLORSPACE,
  JERR_GIF_IMAGENOTFOUND,
  JERR_GIF_NOT,
  JTRC_GIF,
  JTRC_GIF_BADVERSION,
  JTRC_GIF_EXTENSION,
  JTRC_GIF_NONSQUARE,
  JWRN_GIF_BADDATA,
  JWRN_GIF_CHAR,
  JWRN_GIF_ENDCODE,
  JWRN_GIF_NOMOREDATA,
  JERR_PPM_COLORSPACE,
  JERR_PPM_NONNUMERIC,
  JERR_PPM_NOT,
  JTRC_PGM,
  JTRC_PGM_TEXT,
  JTRC_PPM,
  JTRC_PPM_TEXT,
  JERR_TGA_BADCMAP,
  JERR_TGA_BADPARMS,
  JERR_TGA_COLORSPACE,
  JTRC_TGA,
  JTRC_TGA_GRAY,
  JTRC_TGA_MAPPED,
  JERR_BAD_CMAP_FILE,
  JERR_TOO_MANY_COLORS,
  JERR_UNGETC_FAILED,
  JERR_UNKNOWN_FORMAT,
  JERR_UNSUPPORTED_FORMAT,
  JMSG_LASTADDONCODE
} ADDON_MESSAGE_CODE ; /*typedef*/

typedef struct cjpeg_source_struct *  cjpeg_source_ptr ; /*typedef*/

struct cjpeg_source_struct {
  void ( *  start_input )(j_compress_ptr cinfo , cjpeg_source_ptr sinfo ) ;
  JDIMENSION ( *  get_pixel_rows )(j_compress_ptr cinfo , cjpeg_source_ptr sinfo
    ) ;
  void ( *  finish_input )(j_compress_ptr cinfo , cjpeg_source_ptr sinfo ) ;
  FILE *  input_file ;
  JSAMPARRAY buffer ;
  JDIMENSION buffer_height ;
} ; /*onlytypedef*/

typedef struct djpeg_dest_struct *  djpeg_dest_ptr ; /*typedef*/

struct djpeg_dest_struct {
  void ( *  start_output )(j_decompress_ptr cinfo , djpeg_dest_ptr dinfo ) ;
  void ( *  put_pixel_rows )(j_decompress_ptr cinfo , djpeg_dest_ptr dinfo ,
    JDIMENSION rows_supplied ) ;
  void ( *  finish_output )(j_decompress_ptr cinfo , djpeg_dest_ptr dinfo ) ;
  FILE *  output_file ;
  JSAMPARRAY buffer ;
  JDIMENSION buffer_height ;
} ; /*onlytypedef*/

struct cdjpeg_progress_mgr {
  struct jpeg_progress_mgr pub ;
  int completed_extra_passes ;
  int total_extra_passes ;
  int percent_done ;
} ; /*onlytypedef*/

typedef struct cdjpeg_progress_mgr *  cd_progress_ptr ; /*typedef*/

extern cjpeg_source_ptr jinit_read_bmp(j_compress_ptr cinfo ) ; /*decdef*/
extern djpeg_dest_ptr jinit_write_bmp(j_decompress_ptr cinfo , boolean is_os2 )
  ; /*decdef*/
extern cjpeg_source_ptr jinit_read_gif(j_compress_ptr cinfo ) ; /*decdef*/
extern djpeg_dest_ptr jinit_write_gif(j_decompress_ptr cinfo ) ; /*decdef*/
extern cjpeg_source_ptr jinit_read_ppm(j_compress_ptr cinfo ) ; /*decdef*/
extern djpeg_dest_ptr jinit_write_ppm(j_decompress_ptr cinfo ) ; /*decdef*/
extern cjpeg_source_ptr jinit_read_rle(j_compress_ptr cinfo ) ; /*decdef*/
extern djpeg_dest_ptr jinit_write_rle(j_decompress_ptr cinfo ) ; /*decdef*/
extern cjpeg_source_ptr jinit_read_targa(j_compress_ptr cinfo ) ; /*decdef*/
extern djpeg_dest_ptr jinit_write_targa(j_decompress_ptr cinfo ) ; /*decdef*/
extern void read_color_map(j_decompress_ptr cinfo , FILE *  infile )
  ; /*decdef*/

typedef unsigned char U_CHAR ; /*typedef*/

typedef struct  {
  struct cjpeg_source_struct pub ;
  U_CHAR *  iobuffer ;
  JSAMPROW pixrow ;
  JDIMENSION buffer_width ;
  JSAMPLE *  rescale ;
} ppm_source_struct ; /*typedef*/

typedef ppm_source_struct *  ppm_source_ptr ; /*typedef*/

static int pbm_getc__0(FILE *  infile )
{
  register int ch ; /*decdef*/
  ch = _IO_getc(infile);
  if(ch == '#')
  {
    do
    {
      ch = _IO_getc(infile);
    }
    while(ch != '\n' && ch != - 1);
  }
  return ch;
}

static unsigned int read_pbm_integer(j_compress_ptr cinfo , FILE *  infile )
{
  register int ch ; /*decdef*/
  register unsigned int val ; /*decdef*/
  do
  {
    ch = pbm_getc__0(infile);
    if(ch == - 1)
      (cinfo->err)->msg_code = JERR_INPUT_EOF, (*
	(cinfo->err)->error_exit)((j_common_ptr )cinfo);
  }
  while(ch == ' ' || ch == '\t' || ch == '\n' || ch == '\r');
  if(ch < '0' || ch > '9')
    (cinfo->err)->msg_code = JERR_PPM_NONNUMERIC, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  val = ch - '0';
  while((ch = pbm_getc__0(infile)) >= '0' && ch <= '9')
  {
    val *= 10;
    val += ch - '0';
  }
  return val;
}

static JDIMENSION get_text_gray_row(j_compress_ptr cinfo , cjpeg_source_ptr
  sinfo )
{
  ppm_source_ptr source = (ppm_source_ptr )sinfo; /*decdef*/
  FILE *  infile = (source->pub).input_file; /*decdef*/
  register JSAMPROW ptr ; /*decdef*/
  register JSAMPLE *  rescale = source->rescale; /*decdef*/
  JDIMENSION col ; /*decdef*/
  ptr = ((source->pub).buffer)[0];
  for(col = cinfo->image_width; col > 0; col--)
  {
    * ptr++ = rescale[read_pbm_integer(cinfo, infile)];
  }
  return 1;
}

static JDIMENSION get_text_rgb_row(j_compress_ptr cinfo , cjpeg_source_ptr sinfo
  )
{
  ppm_source_ptr source = (ppm_source_ptr )sinfo; /*decdef*/
  FILE *  infile = (source->pub).input_file; /*decdef*/
  register JSAMPROW ptr ; /*decdef*/
  register JSAMPLE *  rescale = source->rescale; /*decdef*/
  JDIMENSION col ; /*decdef*/
  ptr = ((source->pub).buffer)[0];
  for(col = cinfo->image_width; col > 0; col--)
  {
    * ptr++ = rescale[read_pbm_integer(cinfo, infile)];
    * ptr++ = rescale[read_pbm_integer(cinfo, infile)];
    * ptr++ = rescale[read_pbm_integer(cinfo, infile)];
  }
  return 1;
}

static JDIMENSION get_scaled_gray_row(j_compress_ptr cinfo , cjpeg_source_ptr
  sinfo )
{
  ppm_source_ptr source = (ppm_source_ptr )sinfo; /*decdef*/
  register JSAMPROW ptr ; /*decdef*/
  register U_CHAR *  bufferptr ; /*decdef*/
  register JSAMPLE *  rescale = source->rescale; /*decdef*/
  JDIMENSION col ; /*decdef*/
  if(! ((size_t )fread((void *  )source->iobuffer, (size_t )1, (size_t
    )source->buffer_width, (source->pub).input_file) == (size_t
    )source->buffer_width))
    (cinfo->err)->msg_code = JERR_INPUT_EOF, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  ptr = ((source->pub).buffer)[0];
  bufferptr = source->iobuffer;
  for(col = cinfo->image_width; col > 0; col--)
  {
    * ptr++ = rescale[(int )(* bufferptr++)];
  }
  return 1;
}

static JDIMENSION get_scaled_rgb_row(j_compress_ptr cinfo , cjpeg_source_ptr
  sinfo )
{
  ppm_source_ptr source = (ppm_source_ptr )sinfo; /*decdef*/
  register JSAMPROW ptr ; /*decdef*/
  register U_CHAR *  bufferptr ; /*decdef*/
  register JSAMPLE *  rescale = source->rescale; /*decdef*/
  JDIMENSION col ; /*decdef*/
  if(! ((size_t )fread((void *  )source->iobuffer, (size_t )1, (size_t
    )source->buffer_width, (source->pub).input_file) == (size_t
    )source->buffer_width))
    (cinfo->err)->msg_code = JERR_INPUT_EOF, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  ptr = ((source->pub).buffer)[0];
  bufferptr = source->iobuffer;
  for(col = cinfo->image_width; col > 0; col--)
  {
    * ptr++ = rescale[(int )(* bufferptr++)];
    * ptr++ = rescale[(int )(* bufferptr++)];
    * ptr++ = rescale[(int )(* bufferptr++)];
  }
  return 1;
}

static JDIMENSION get_raw_row(j_compress_ptr cinfo , cjpeg_source_ptr sinfo )
{
  ppm_source_ptr source = (ppm_source_ptr )sinfo; /*decdef*/
  if(! ((size_t )fread((void *  )source->iobuffer, (size_t )1, (size_t
    )source->buffer_width, (source->pub).input_file) == (size_t
    )source->buffer_width))
    (cinfo->err)->msg_code = JERR_INPUT_EOF, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  return 1;
}

static void start_input_ppm(j_compress_ptr cinfo , cjpeg_source_ptr sinfo )
{
  ppm_source_ptr source = (ppm_source_ptr )sinfo; /*decdef*/
  int c ; /*decdef*/
  unsigned int w , h , maxval ; /*decdef*/
  boolean can_use_raw ; /*decdef*/
  if(_IO_getc((source->pub).input_file) != 'P')
    (cinfo->err)->msg_code = JERR_PPM_NOT, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  c = _IO_getc((source->pub).input_file);
  w = read_pbm_integer(cinfo, (source->pub).input_file);
  h = read_pbm_integer(cinfo, (source->pub).input_file);
  maxval = read_pbm_integer(cinfo, (source->pub).input_file);
  if(w <= 0 || h <= 0 || maxval <= 0)
    (cinfo->err)->msg_code = JERR_PPM_NOT, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  cinfo->data_precision = 8;
  cinfo->image_width = (JDIMENSION )w;
  cinfo->image_height = (JDIMENSION )h;
  can_use_raw = maxval == 255 && (size_t )sizeof(JSAMPLE ) == (size_t
    )sizeof(U_CHAR );
  switch(c)
  {
  case '2':
      ;
    cinfo->input_components = 1;
    cinfo->in_color_space = JCS_GRAYSCALE;
    (cinfo->err)->msg_code = JTRC_PGM_TEXT, (((cinfo->err)->msg_parm).i)[0] = w,
      (((cinfo->err)->msg_parm).i)[1] = h, (*
      (cinfo->err)->emit_message)((j_common_ptr )cinfo, 1);
    (source->pub).get_pixel_rows = get_text_gray_row;
    can_use_raw = 0;
    break;
  case '3':
      ;
    cinfo->input_components = 3;
    cinfo->in_color_space = JCS_RGB;
    (cinfo->err)->msg_code = JTRC_PPM_TEXT, (((cinfo->err)->msg_parm).i)[0] = w,
      (((cinfo->err)->msg_parm).i)[1] = h, (*
      (cinfo->err)->emit_message)((j_common_ptr )cinfo, 1);
    (source->pub).get_pixel_rows = get_text_rgb_row;
    can_use_raw = 0;
    break;
  case '5':
      ;
    cinfo->input_components = 1;
    cinfo->in_color_space = JCS_GRAYSCALE;
    (cinfo->err)->msg_code = JTRC_PGM, (((cinfo->err)->msg_parm).i)[0] = w,
      (((cinfo->err)->msg_parm).i)[1] = h, (*
      (cinfo->err)->emit_message)((j_common_ptr )cinfo, 1);
    if(can_use_raw)
      (source->pub).get_pixel_rows = get_raw_row;
    else
      (source->pub).get_pixel_rows = get_scaled_gray_row;
    source->iobuffer = (U_CHAR *  )(* (cinfo->mem)->alloc_small)((j_common_ptr
      )cinfo, 1, (size_t )((size_t )sizeof(U_CHAR ) * (size_t )w));
    break;
  case '6':
      ;
    cinfo->input_components = 3;
    cinfo->in_color_space = JCS_RGB;
    (cinfo->err)->msg_code = JTRC_PPM, (((cinfo->err)->msg_parm).i)[0] = w,
      (((cinfo->err)->msg_parm).i)[1] = h, (*
      (cinfo->err)->emit_message)((j_common_ptr )cinfo, 1);
    if(can_use_raw)
      (source->pub).get_pixel_rows = get_raw_row;
    else
      (source->pub).get_pixel_rows = get_scaled_rgb_row;
    source->iobuffer = (U_CHAR *  )(* (cinfo->mem)->alloc_small)((j_common_ptr
      )cinfo, 1, (size_t )(3 * (size_t )sizeof(U_CHAR ) * (size_t )w));
    break;
  default :
      ;
    (cinfo->err)->msg_code = JERR_PPM_NOT, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
    break;
  }
  source->buffer_width = (JDIMENSION )w * cinfo->input_components;
  if(can_use_raw)
  {
    source->pixrow = (JSAMPROW )source->iobuffer;
    (source->pub).buffer = & source->pixrow;
    (source->pub).buffer_height = 1;
  }
  else
  {
    (source->pub).buffer = (* (cinfo->mem)->alloc_sarray)((j_common_ptr )cinfo,
      1, source->buffer_width, (JDIMENSION )1);
    (source->pub).buffer_height = 1;
  }
  if(can_use_raw)
  {
    source->rescale = (void *  )0;
  }
  else
  {
    INT32 val , half_maxval ; /*decdef*/
    source->rescale = (JSAMPLE *  )(* (cinfo->mem)->alloc_small)((j_common_ptr
      )cinfo, 1, (size_t )(((long )maxval + 1L) * (size_t )sizeof(JSAMPLE )));
    half_maxval = maxval / 2;
    for(val = 0; val <= (INT32 )maxval; val++)
    {
      (source->rescale)[val] = (JSAMPLE )((val * 255 + half_maxval) / maxval);
    }
  }
}

static void finish_input_ppm(j_compress_ptr cinfo , cjpeg_source_ptr sinfo )
{
}

cjpeg_source_ptr jinit_read_ppm(j_compress_ptr cinfo )
{
  ppm_source_ptr source ; /*decdef*/
  source = (ppm_source_ptr )(* (cinfo->mem)->alloc_small)((j_common_ptr )cinfo,
    1, (size_t )sizeof(ppm_source_struct ));
  (source->pub).start_input = start_input_ppm;
  (source->pub).finish_input = finish_input_ppm;
  return (cjpeg_source_ptr )source;
}


#pragma combiner("./wrppm.i", "-g -O -I/home/scott/wrk/safec/cil/lib ")

#pragma boxalloc("malloc", nozero, sizein(0))

#pragma boxalloc("alloca", nozero, sizein(0))

#pragma boxalloc("calloc", zero, sizemul(0, 1))

#pragma boxprintf("printf", 0)

#pragma boxprintf("fprintf", 1)

#pragma boxprintf("sprintf", 1)

#pragma boxprintf("snprintf", 2)

#pragma boxpoly("memcpy")

#pragma boxexported("main")
typedef struct  {
  struct djpeg_dest_struct pub ;
  char *  iobuffer ;
  JSAMPROW pixrow ;
  JDIMENSION buffer_width ;
} ppm_dest_struct ; /*typedef*/

typedef ppm_dest_struct *  ppm_dest_ptr ; /*typedef*/

static void put_pixel_rows(j_decompress_ptr cinfo , djpeg_dest_ptr dinfo ,
  JDIMENSION rows_supplied )
{
  ppm_dest_ptr dest = (ppm_dest_ptr )dinfo; /*decdef*/
  (void )((size_t )fwrite((const void *  )dest->iobuffer, (size_t )1, (size_t
    )dest->buffer_width, (dest->pub).output_file));
}

static void copy_pixel_rows(j_decompress_ptr cinfo , djpeg_dest_ptr dinfo ,
  JDIMENSION rows_supplied )
{
  ppm_dest_ptr dest = (ppm_dest_ptr )dinfo; /*decdef*/
  register char *  bufferptr ; /*decdef*/
  register JSAMPROW ptr ; /*decdef*/
  register JDIMENSION col ; /*decdef*/
  ptr = ((dest->pub).buffer)[0];
  bufferptr = dest->iobuffer;
  for(col = dest->buffer_width; col > 0; col--)
  {
    * bufferptr++ = (char )((int )(* ptr++));
  }
  (void )((size_t )fwrite((const void *  )dest->iobuffer, (size_t )1, (size_t
    )dest->buffer_width, (dest->pub).output_file));
}

static void put_demapped_rgb(j_decompress_ptr cinfo , djpeg_dest_ptr dinfo ,
  JDIMENSION rows_supplied )
{
  ppm_dest_ptr dest = (ppm_dest_ptr )dinfo; /*decdef*/
  register char *  bufferptr ; /*decdef*/
  register int pixval ; /*decdef*/
  register JSAMPROW ptr ; /*decdef*/
  register JSAMPROW color_map0 = (cinfo->colormap)[0]; /*decdef*/
  register JSAMPROW color_map1 = (cinfo->colormap)[1]; /*decdef*/
  register JSAMPROW color_map2 = (cinfo->colormap)[2]; /*decdef*/
  register JDIMENSION col ; /*decdef*/
  ptr = ((dest->pub).buffer)[0];
  bufferptr = dest->iobuffer;
  for(col = cinfo->output_width; col > 0; col--)
  {
    pixval = (int )(* ptr++);
    * bufferptr++ = (char )((int )color_map0[pixval]);
    * bufferptr++ = (char )((int )color_map1[pixval]);
    * bufferptr++ = (char )((int )color_map2[pixval]);
  }
  (void )((size_t )fwrite((const void *  )dest->iobuffer, (size_t )1, (size_t
    )dest->buffer_width, (dest->pub).output_file));
}

static void put_demapped_gray(j_decompress_ptr cinfo , djpeg_dest_ptr dinfo ,
  JDIMENSION rows_supplied )
{
  ppm_dest_ptr dest = (ppm_dest_ptr )dinfo; /*decdef*/
  register char *  bufferptr ; /*decdef*/
  register JSAMPROW ptr ; /*decdef*/
  register JSAMPROW color_map = (cinfo->colormap)[0]; /*decdef*/
  register JDIMENSION col ; /*decdef*/
  ptr = ((dest->pub).buffer)[0];
  bufferptr = dest->iobuffer;
  for(col = cinfo->output_width; col > 0; col--)
  {
    * bufferptr++ = (char )((int )color_map[(int )(* ptr++)]);
  }
  (void )((size_t )fwrite((const void *  )dest->iobuffer, (size_t )1, (size_t
    )dest->buffer_width, (dest->pub).output_file));
}

static void start_output_ppm(j_decompress_ptr cinfo , djpeg_dest_ptr dinfo )
{
  ppm_dest_ptr dest = (ppm_dest_ptr )dinfo; /*decdef*/
  switch(cinfo->out_color_space)
  {
  case JCS_GRAYSCALE:
      ;
    fprintf((dest->pub).output_file, "P5\n%ld %ld\n%d\n",
      (long )cinfo->output_width, (long )cinfo->output_height, 255);
    break;
  case JCS_RGB:
      ;
    fprintf((dest->pub).output_file, "P6\n%ld %ld\n%d\n",
      (long )cinfo->output_width, (long )cinfo->output_height, 255);
    break;
  default :
      ;
    (cinfo->err)->msg_code = JERR_PPM_COLORSPACE, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  }
}

static void finish_output_ppm(j_decompress_ptr cinfo , djpeg_dest_ptr dinfo )
{
  fflush(dinfo->output_file);
  if(ferror(dinfo->output_file))
    (cinfo->err)->msg_code = JERR_FILE_WRITE, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
}

djpeg_dest_ptr jinit_write_ppm(j_decompress_ptr cinfo )
{
  ppm_dest_ptr dest ; /*decdef*/
  dest = (ppm_dest_ptr )(* (cinfo->mem)->alloc_small)((j_common_ptr )cinfo, 1,
    (size_t )sizeof(ppm_dest_struct ));
  (dest->pub).start_output = start_output_ppm;
  (dest->pub).finish_output = finish_output_ppm;
  jpeg_calc_output_dimensions(cinfo);
  dest->buffer_width = cinfo->output_width * cinfo->out_color_components;
  dest->iobuffer = (char *  )(* (cinfo->mem)->alloc_small)((j_common_ptr )cinfo,
    1, (size_t )(dest->buffer_width * (size_t )sizeof(char )));
  if(cinfo->quantize_colors || (size_t )sizeof(JSAMPLE ) != (size_t
    )sizeof(char ))
  {
    (dest->pub).buffer = (* (cinfo->mem)->alloc_sarray)((j_common_ptr )cinfo, 1,
      cinfo->output_width * cinfo->output_components, (JDIMENSION )1);
    (dest->pub).buffer_height = 1;
    if(! cinfo->quantize_colors)
      (dest->pub).put_pixel_rows = copy_pixel_rows;
    else
    {
      if(cinfo->out_color_space == JCS_GRAYSCALE)
	(dest->pub).put_pixel_rows = put_demapped_gray;
      else
	(dest->pub).put_pixel_rows = put_demapped_rgb;
    }
  }
  else
  {
    dest->pixrow = (JSAMPROW )dest->iobuffer;
    (dest->pub).buffer = & dest->pixrow;
    (dest->pub).buffer_height = 1;
    (dest->pub).put_pixel_rows = put_pixel_rows;
  }
  return (djpeg_dest_ptr )dest;
}


#pragma combiner("./rdgif.i", "-g -O -I/home/scott/wrk/safec/cil/lib ")

#pragma boxalloc("malloc", nozero, sizein(0))

#pragma boxalloc("alloca", nozero, sizein(0))

#pragma boxalloc("calloc", zero, sizemul(0, 1))

#pragma boxprintf("printf", 0)

#pragma boxprintf("fprintf", 1)

#pragma boxprintf("sprintf", 1)

#pragma boxprintf("snprintf", 2)

#pragma boxpoly("memcpy")

#pragma boxexported("main")
typedef struct  {
  struct cjpeg_source_struct pub ;
  j_compress_ptr cinfo ;
  JSAMPARRAY colormap ;
  char code_buf[256 + 4] ;
  int last_byte ;
  int last_bit ;
  int cur_bit ;
  boolean out_of_blocks ;
  int input_code_size ;
  int clear_code , end_code ;
  int code_size ;
  int limit_code ;
  int max_code ;
  boolean first_time ;
  int oldcode ;
  int firstcode ;
  UINT16 *  symbol_head ;
  UINT8 *  symbol_tail ;
  UINT8 *  symbol_stack ;
  UINT8 *  sp ;
  boolean is_interlaced ;
  jvirt_sarray_ptr interlaced_image ;
  JDIMENSION cur_row_number ;
  JDIMENSION pass2_offset ;
  JDIMENSION pass3_offset ;
  JDIMENSION pass4_offset ;
} gif_source_struct ; /*typedef*/

typedef gif_source_struct *  gif_source_ptr ; /*typedef*/

static JDIMENSION get_pixel_rows(j_compress_ptr cinfo , cjpeg_source_ptr sinfo )
  ; /*decdef*/
static JDIMENSION load_interlaced_image(j_compress_ptr cinfo , cjpeg_source_ptr
  sinfo ) ; /*decdef*/
static JDIMENSION get_interlaced_row(j_compress_ptr cinfo , cjpeg_source_ptr
  sinfo ) ; /*decdef*/

static int ReadByte(gif_source_ptr sinfo )
{
  register FILE *  infile = (sinfo->pub).input_file; /*decdef*/
  int c ; /*decdef*/
  if((c = _IO_getc(infile)) == - 1)
    ((sinfo->cinfo)->err)->msg_code = JERR_INPUT_EOF, (*
      ((sinfo->cinfo)->err)->error_exit)((j_common_ptr )sinfo->cinfo);
  return c;
}

static int GetDataBlock(gif_source_ptr sinfo , char *  buf )
{
  int count ; /*decdef*/
  count = ReadByte(sinfo);
  if(count > 0)
  {
    if(! ((size_t )fread((void *  )buf, (size_t )1, (size_t )count,
      (sinfo->pub).input_file) == (size_t )count))
      ((sinfo->cinfo)->err)->msg_code = JERR_INPUT_EOF, (*
	((sinfo->cinfo)->err)->error_exit)((j_common_ptr )sinfo->cinfo);
  }
  return count;
}

static void SkipDataBlocks(gif_source_ptr sinfo )
{
  char buf[256] ; /*decdef*/
  while(GetDataBlock(sinfo, buf) > 0)
    ;
}

static void ReInitLZW(gif_source_ptr sinfo )
{
  sinfo->code_size = sinfo->input_code_size + 1;
  sinfo->limit_code = sinfo->clear_code << 1;
  sinfo->max_code = sinfo->clear_code + 2;
  sinfo->sp = sinfo->symbol_stack;
}

static void InitLZWCode(gif_source_ptr sinfo )
{
  sinfo->last_byte = 2;
  sinfo->last_bit = 0;
  sinfo->cur_bit = 0;
  sinfo->out_of_blocks = 0;
  sinfo->clear_code = 1 << sinfo->input_code_size;
  sinfo->end_code = sinfo->clear_code + 1;
  sinfo->first_time = 1;
  ReInitLZW(sinfo);
}

static int GetCode(gif_source_ptr sinfo )
{
  register INT32 accum ; /*decdef*/
  int offs , ret , count ; /*decdef*/
  while(sinfo->cur_bit + sinfo->code_size > sinfo->last_bit)
  {
    if(sinfo->out_of_blocks)
    {
      ((sinfo->cinfo)->err)->msg_code = JWRN_GIF_NOMOREDATA, (*
	((sinfo->cinfo)->err)->emit_message)((j_common_ptr )sinfo->cinfo, - 1);
      return sinfo->end_code;
    }
    (sinfo->code_buf)[0] = (sinfo->code_buf)[sinfo->last_byte - 2];
    (sinfo->code_buf)[1] = (sinfo->code_buf)[sinfo->last_byte - 1];
    if((count = GetDataBlock(sinfo, & (sinfo->code_buf)[2])) == 0)
    {
      sinfo->out_of_blocks = 1;
      ((sinfo->cinfo)->err)->msg_code = JWRN_GIF_NOMOREDATA, (*
	((sinfo->cinfo)->err)->emit_message)((j_common_ptr )sinfo->cinfo, - 1);
      return sinfo->end_code;
    }
    sinfo->cur_bit = sinfo->cur_bit - sinfo->last_bit + 16;
    sinfo->last_byte = 2 + count;
    sinfo->last_bit = sinfo->last_byte * 8;
  }
  offs = sinfo->cur_bit >> 3;
  accum = (sinfo->code_buf)[offs + 2];
  accum <<= 8;
  accum |= (sinfo->code_buf)[offs + 1];
  accum <<= 8;
  accum |= (sinfo->code_buf)[offs];
  accum >>= sinfo->cur_bit & 7;
  ret = (int )accum & (1 << sinfo->code_size) - 1;
  sinfo->cur_bit += sinfo->code_size;
  return ret;
}

static int LZWReadByte(gif_source_ptr sinfo )
{
  register int code ; /*decdef*/
  int incode ; /*decdef*/
  if(sinfo->first_time)
  {
    sinfo->first_time = 0;
    code = sinfo->clear_code;
  }
  else
  {
    if(sinfo->sp > sinfo->symbol_stack)
      return (int )(* -- sinfo->sp);
    code = GetCode(sinfo);
  }
  if(code == sinfo->clear_code)
  {
    ReInitLZW(sinfo);
    do
    {
      code = GetCode(sinfo);
    }
    while(code == sinfo->clear_code);
    if(code > sinfo->clear_code)
    {
      ((sinfo->cinfo)->err)->msg_code = JWRN_GIF_BADDATA, (*
	((sinfo->cinfo)->err)->emit_message)((j_common_ptr )sinfo->cinfo, - 1);
      code = 0;
    }
    sinfo->firstcode = (sinfo->oldcode = code);
    return code;
  }
  if(code == sinfo->end_code)
  {
    if(! sinfo->out_of_blocks)
    {
      SkipDataBlocks(sinfo);
      sinfo->out_of_blocks = 1;
    }
    ((sinfo->cinfo)->err)->msg_code = JWRN_GIF_ENDCODE, (*
      ((sinfo->cinfo)->err)->emit_message)((j_common_ptr )sinfo->cinfo, - 1);
    return 0;
  }
  incode = code;
  if(code >= sinfo->max_code)
  {
    if(code > sinfo->max_code)
    {
      ((sinfo->cinfo)->err)->msg_code = JWRN_GIF_BADDATA, (*
	((sinfo->cinfo)->err)->emit_message)((j_common_ptr )sinfo->cinfo, - 1);
      incode = 0;
    }
    * sinfo->sp++ = (UINT8 )sinfo->firstcode;
    code = sinfo->oldcode;
  }
  while(code >= sinfo->clear_code)
  {
    * sinfo->sp++ = (sinfo->symbol_tail)[code];
    code = (sinfo->symbol_head)[code];
  }
  sinfo->firstcode = code;
  if((code = sinfo->max_code) < 1 << 12)
  {
    (sinfo->symbol_head)[code] = sinfo->oldcode;
    (sinfo->symbol_tail)[code] = (UINT8 )sinfo->firstcode;
    sinfo->max_code++;
    if(sinfo->max_code >= sinfo->limit_code && sinfo->code_size < 12)
    {
      sinfo->code_size++;
      sinfo->limit_code <<= 1;
    }
  }
  sinfo->oldcode = incode;
  return sinfo->firstcode;
}

static void ReadColorMap(gif_source_ptr sinfo , int cmaplen , JSAMPARRAY cmap )
{
  int i ; /*decdef*/
  for(i = 0; i < cmaplen; i++)
  {
    (cmap[0])[i] = (JSAMPLE )ReadByte(sinfo);
    (cmap[1])[i] = (JSAMPLE )ReadByte(sinfo);
    (cmap[2])[i] = (JSAMPLE )ReadByte(sinfo);
  }
}

static void DoExtension(gif_source_ptr sinfo )
{
  int extlabel ; /*decdef*/
  extlabel = ReadByte(sinfo);
  ((sinfo->cinfo)->err)->msg_code = JTRC_GIF_EXTENSION,
    ((((sinfo->cinfo)->err)->msg_parm).i)[0] = extlabel, (*
    ((sinfo->cinfo)->err)->emit_message)((j_common_ptr )sinfo->cinfo, 1);
  SkipDataBlocks(sinfo);
}

static void start_input_gif(j_compress_ptr cinfo , cjpeg_source_ptr sinfo )
{
  gif_source_ptr source = (gif_source_ptr )sinfo; /*decdef*/
  char hdrbuf[10] ; /*decdef*/
  unsigned int width , height ; /*decdef*/
  int colormaplen , aspectRatio ; /*decdef*/
  int c ; /*decdef*/
  source->colormap = (* (cinfo->mem)->alloc_sarray)((j_common_ptr )cinfo, 1,
    (JDIMENSION )256, (JDIMENSION )3);
  if(! ((size_t )fread((void *  )hdrbuf, (size_t )1, (size_t )6,
    (source->pub).input_file) == (size_t )6))
    (cinfo->err)->msg_code = JERR_GIF_NOT, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  if(hdrbuf[0] != 'G' || hdrbuf[1] != 'I' || hdrbuf[2] != 'F')
    (cinfo->err)->msg_code = JERR_GIF_NOT, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  if((hdrbuf[3] != '8' || hdrbuf[4] != '7' || hdrbuf[5] != 'a') && (hdrbuf[3] !=
    '8' || hdrbuf[4] != '9' || hdrbuf[5] != 'a'))
  {
    do
    {
      int *  _mp = ((cinfo->err)->msg_parm).i; /*decdef*/
      _mp[0] = hdrbuf[3];
      _mp[1] = hdrbuf[4];
      _mp[2] = hdrbuf[5];
      (cinfo->err)->msg_code = JTRC_GIF_BADVERSION;
      (* (cinfo->err)->emit_message)((j_common_ptr )cinfo, 1);
    }
    while(0);
  }
  if(! ((size_t )fread((void *  )hdrbuf, (size_t )1, (size_t )7,
    (source->pub).input_file) == (size_t )7))
    (cinfo->err)->msg_code = JERR_INPUT_EOF, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  width = (hdrbuf[1] & 0xFF) << 8 | hdrbuf[0] & 0xFF;
  height = (hdrbuf[3] & 0xFF) << 8 | hdrbuf[2] & 0xFF;
  colormaplen = 2 << (hdrbuf[4] & 0x07);
  aspectRatio = hdrbuf[6] & 0xFF;
  if(aspectRatio != 0 && aspectRatio != 49)
    (cinfo->err)->msg_code = JTRC_GIF_NONSQUARE, (*
      (cinfo->err)->emit_message)((j_common_ptr )cinfo, 1);
  if(hdrbuf[4] & 0x80)
    ReadColorMap(source, colormaplen, source->colormap);
  for(; ; )
  {
    c = ReadByte(source);
    if(c == ';')
      (cinfo->err)->msg_code = JERR_GIF_IMAGENOTFOUND, (*
	(cinfo->err)->error_exit)((j_common_ptr )cinfo);
    if(c == '!')
    {
      DoExtension(source);
      continue;
    }
    if(c != ',')
    {
      (cinfo->err)->msg_code = JWRN_GIF_CHAR, (((cinfo->err)->msg_parm).i)[0] =
	c, (* (cinfo->err)->emit_message)((j_common_ptr )cinfo, - 1);
      continue;
    }
    if(! ((size_t )fread((void *  )hdrbuf, (size_t )1, (size_t )9,
      (source->pub).input_file) == (size_t )9))
      (cinfo->err)->msg_code = JERR_INPUT_EOF, (*
	(cinfo->err)->error_exit)((j_common_ptr )cinfo);
    width = (hdrbuf[5] & 0xFF) << 8 | hdrbuf[4] & 0xFF;
    height = (hdrbuf[7] & 0xFF) << 8 | hdrbuf[6] & 0xFF;
    source->is_interlaced = hdrbuf[8] & 0x40;
    if(hdrbuf[8] & 0x80)
    {
      colormaplen = 2 << (hdrbuf[8] & 0x07);
      ReadColorMap(source, colormaplen, source->colormap);
    }
    source->input_code_size = ReadByte(source);
    if(source->input_code_size < 2 || source->input_code_size >= 12)
      (cinfo->err)->msg_code = JERR_GIF_CODESIZE,
	(((cinfo->err)->msg_parm).i)[0] = source->input_code_size, (*
	(cinfo->err)->error_exit)((j_common_ptr )cinfo);
    break;
  }
  source->symbol_head = (UINT16 *  )(* (cinfo->mem)->alloc_large)((j_common_ptr
    )cinfo, 1, (1 << 12) * (size_t )sizeof(UINT16 ));
  source->symbol_tail = (UINT8 *  )(* (cinfo->mem)->alloc_large)((j_common_ptr
    )cinfo, 1, (1 << 12) * (size_t )sizeof(UINT8 ));
  source->symbol_stack = (UINT8 *  )(* (cinfo->mem)->alloc_large)((j_common_ptr
    )cinfo, 1, (1 << 12) * (size_t )sizeof(UINT8 ));
  InitLZWCode(source);
  if(source->is_interlaced)
  {
    source->interlaced_image = (*
      (cinfo->mem)->request_virt_sarray)((j_common_ptr )cinfo, 1, (JDIMENSION
      )width, (JDIMENSION )height, (JDIMENSION )1);
    if(cinfo->progress != (void *  )0)
    {
      cd_progress_ptr progress = (cd_progress_ptr )cinfo->progress; /*decdef*/
      progress->total_extra_passes++;
    }
    (source->pub).get_pixel_rows = load_interlaced_image;
  }
  else
  {
    (source->pub).get_pixel_rows = get_pixel_rows;
  }
  (source->pub).buffer = (* (cinfo->mem)->alloc_sarray)((j_common_ptr )cinfo, 1,
    (JDIMENSION )width * 3, (JDIMENSION )1);
  (source->pub).buffer_height = 1;
  cinfo->in_color_space = JCS_RGB;
  cinfo->input_components = 3;
  cinfo->data_precision = 8;
  cinfo->image_width = width;
  cinfo->image_height = height;
  do
  {
    int *  _mp = ((cinfo->err)->msg_parm).i; /*decdef*/
    _mp[0] = width;
    _mp[1] = height;
    _mp[2] = colormaplen;
    (cinfo->err)->msg_code = JTRC_GIF;
    (* (cinfo->err)->emit_message)((j_common_ptr )cinfo, 1);
  }
  while(0);
}

static JDIMENSION get_pixel_rows(j_compress_ptr cinfo , cjpeg_source_ptr sinfo )
{
  gif_source_ptr source = (gif_source_ptr )sinfo; /*decdef*/
  register int c ; /*decdef*/
  register JSAMPROW ptr ; /*decdef*/
  register JDIMENSION col ; /*decdef*/
  register JSAMPARRAY colormap = source->colormap; /*decdef*/
  ptr = ((source->pub).buffer)[0];
  for(col = cinfo->image_width; col > 0; col--)
  {
    c = LZWReadByte(source);
    * ptr++ = (colormap[0])[c];
    * ptr++ = (colormap[1])[c];
    * ptr++ = (colormap[2])[c];
  }
  return 1;
}

static JDIMENSION load_interlaced_image(j_compress_ptr cinfo , cjpeg_source_ptr
  sinfo )
{
  gif_source_ptr source = (gif_source_ptr )sinfo; /*decdef*/
  JSAMPARRAY image_ptr ; /*decdef*/
  register JSAMPROW sptr ; /*decdef*/
  register JDIMENSION col ; /*decdef*/
  JDIMENSION row ; /*decdef*/
  cd_progress_ptr progress = (cd_progress_ptr )cinfo->progress; /*decdef*/
  for(row = 0; row < cinfo->image_height; row++)
  {
    if(progress != (void *  )0)
    {
      (progress->pub).pass_counter = (long )row;
      (progress->pub).pass_limit = (long )cinfo->image_height;
      (* (progress->pub).progress_monitor)((j_common_ptr )cinfo);
    }
    image_ptr = (* (cinfo->mem)->access_virt_sarray)((j_common_ptr )cinfo,
      source->interlaced_image, row, 1);
    sptr = image_ptr[0];
    for(col = cinfo->image_width; col > 0; col--)
    {
      * sptr++ = (JSAMPLE )LZWReadByte(source);
    }
  }
  if(progress != (void *  )0)
    progress->completed_extra_passes++;
  (source->pub).get_pixel_rows = get_interlaced_row;
  source->cur_row_number = 0;
  source->pass2_offset = (cinfo->image_height + 7) / 8;
  source->pass3_offset = source->pass2_offset + (cinfo->image_height + 3) / 8;
  source->pass4_offset = source->pass3_offset + (cinfo->image_height + 1) / 4;
  return get_interlaced_row(cinfo, sinfo);
}

static JDIMENSION get_interlaced_row(j_compress_ptr cinfo , cjpeg_source_ptr
  sinfo )
{
  gif_source_ptr source = (gif_source_ptr )sinfo; /*decdef*/
  JSAMPARRAY image_ptr ; /*decdef*/
  register int c ; /*decdef*/
  register JSAMPROW sptr , ptr ; /*decdef*/
  register JDIMENSION col ; /*decdef*/
  register JSAMPARRAY colormap = source->colormap; /*decdef*/
  JDIMENSION irow ; /*decdef*/
  switch((int )(source->cur_row_number & 7))
  {
  case 0:
      ;
    irow = source->cur_row_number >> 3;
    break;
  case 4:
      ;
    irow = (source->cur_row_number >> 3) + source->pass2_offset;
    break;
  case 2:
      ;
  case 6:
      ;
    irow = (source->cur_row_number >> 2) + source->pass3_offset;
    break;
  default :
      ;
    irow = (source->cur_row_number >> 1) + source->pass4_offset;
    break;
  }
  image_ptr = (* (cinfo->mem)->access_virt_sarray)((j_common_ptr )cinfo,
    source->interlaced_image, irow, 0);
  sptr = image_ptr[0];
  ptr = ((source->pub).buffer)[0];
  for(col = cinfo->image_width; col > 0; col--)
  {
    c = (int )(* sptr++);
    * ptr++ = (colormap[0])[c];
    * ptr++ = (colormap[1])[c];
    * ptr++ = (colormap[2])[c];
  }
  source->cur_row_number++;
  return 1;
}

static void finish_input_gif(j_compress_ptr cinfo , cjpeg_source_ptr sinfo )
{
}

cjpeg_source_ptr jinit_read_gif(j_compress_ptr cinfo )
{
  gif_source_ptr source ; /*decdef*/
  source = (gif_source_ptr )(* (cinfo->mem)->alloc_small)((j_common_ptr )cinfo,
    1, (size_t )sizeof(gif_source_struct ));
  source->cinfo = cinfo;
  (source->pub).start_input = start_input_gif;
  (source->pub).finish_input = finish_input_gif;
  return (cjpeg_source_ptr )source;
}


#pragma combiner("./wrgif.i", "-g -O -I/home/scott/wrk/safec/cil/lib ")

#pragma boxalloc("malloc", nozero, sizein(0))

#pragma boxalloc("alloca", nozero, sizein(0))

#pragma boxalloc("calloc", zero, sizemul(0, 1))

#pragma boxprintf("printf", 0)

#pragma boxprintf("fprintf", 1)

#pragma boxprintf("sprintf", 1)

#pragma boxprintf("snprintf", 2)

#pragma boxpoly("memcpy")

#pragma boxexported("main")
typedef INT16 code_int ; /*typedef*/

typedef int hash_int ; /*typedef*/

typedef INT32 hash_entry ; /*typedef*/

typedef struct  {
  struct djpeg_dest_struct pub ;
  j_decompress_ptr cinfo ;
  int n_bits ;
  code_int maxcode ;
  int init_bits ;
  INT32 cur_accum ;
  int cur_bits ;
  code_int waiting_code ;
  boolean first_byte ;
  code_int ClearCode ;
  code_int EOFCode ;
  code_int free_code ;
  code_int *  hash_code ;
  hash_entry *  hash_value ;
  int bytesinpkt ;
  char packetbuf[256] ;
} gif_dest_struct ; /*typedef*/

typedef gif_dest_struct *  gif_dest_ptr ; /*typedef*/

static void flush_packet(gif_dest_ptr dinfo )
{
  if(dinfo->bytesinpkt > 0)
  {
    (dinfo->packetbuf)[0] = (char )(dinfo->bytesinpkt++);
    if((size_t )fwrite((const void *  )dinfo->packetbuf, (size_t )1, (size_t
      )dinfo->bytesinpkt, (dinfo->pub).output_file) != (size_t
      )dinfo->bytesinpkt)
      ((dinfo->cinfo)->err)->msg_code = JERR_FILE_WRITE, (*
	((dinfo->cinfo)->err)->error_exit)((j_common_ptr )dinfo->cinfo);
    dinfo->bytesinpkt = 0;
  }
}

static void output(gif_dest_ptr dinfo , code_int code )
{
  dinfo->cur_accum |= (INT32 )code << dinfo->cur_bits;
  dinfo->cur_bits += dinfo->n_bits;
  while(dinfo->cur_bits >= 8)
  {
    {
      (dinfo->packetbuf)[++ dinfo->bytesinpkt] = (char )(dinfo->cur_accum &
	0xFF);
      if(dinfo->bytesinpkt >= 255)
	flush_packet(dinfo);
    }
    ;
    dinfo->cur_accum >>= 8;
    dinfo->cur_bits -= 8;
  }
  if(dinfo->free_code > dinfo->maxcode)
  {
    dinfo->n_bits++;
    if(dinfo->n_bits == 12)
      dinfo->maxcode = (code_int )1 << 12;
    else
      dinfo->maxcode = ((code_int )1 << dinfo->n_bits) - 1;
  }
}

static void clear_hash(gif_dest_ptr dinfo )
{
  memset((void *  )dinfo->hash_code, 0, (size_t )(5003 * (size_t
    )sizeof(code_int )));
}

static void clear_block(gif_dest_ptr dinfo )
{
  clear_hash(dinfo);
  dinfo->free_code = dinfo->ClearCode + 2;
  output(dinfo, dinfo->ClearCode);
  dinfo->n_bits = dinfo->init_bits;
  dinfo->maxcode = ((code_int )1 << dinfo->n_bits) - 1;
}

static void compress_init(gif_dest_ptr dinfo , int i_bits )
{
  dinfo->n_bits = (dinfo->init_bits = i_bits);
  dinfo->maxcode = ((code_int )1 << dinfo->n_bits) - 1;
  dinfo->ClearCode = (code_int )1 << i_bits - 1;
  dinfo->EOFCode = dinfo->ClearCode + 1;
  dinfo->free_code = dinfo->ClearCode + 2;
  dinfo->first_byte = 1;
  dinfo->bytesinpkt = 0;
  dinfo->cur_accum = 0;
  dinfo->cur_bits = 0;
  clear_hash(dinfo);
  output(dinfo, dinfo->ClearCode);
}

static void compress_byte(gif_dest_ptr dinfo , int c )
{
  register hash_int i ; /*decdef*/
  register hash_int disp ; /*decdef*/
  register hash_entry probe_value ; /*decdef*/
  if(dinfo->first_byte)
  {
    dinfo->waiting_code = c;
    dinfo->first_byte = 0;
    return;
  }
  i = ((hash_int )c << 12 - 8) + dinfo->waiting_code;
  if(i >= 5003)
    i -= 5003;
  probe_value = (hash_entry )dinfo->waiting_code << 8 | c;
  if((dinfo->hash_code)[i] != 0)
  {
    if((dinfo->hash_value)[i] == probe_value)
    {
      dinfo->waiting_code = (dinfo->hash_code)[i];
      return;
    }
    if(i == 0)
      disp = 1;
    else
      disp = 5003 - i;
    for(; ; )
    {
      i -= disp;
      if(i < 0)
	i += 5003;
      if((dinfo->hash_code)[i] == 0)
	break;
      if((dinfo->hash_value)[i] == probe_value)
      {
	dinfo->waiting_code = (dinfo->hash_code)[i];
	return;
      }
    }
  }
  output(dinfo, dinfo->waiting_code);
  if(dinfo->free_code < (code_int )1 << 12)
  {
    (dinfo->hash_code)[i] = dinfo->free_code++;
    (dinfo->hash_value)[i] = probe_value;
  }
  else
    clear_block(dinfo);
  dinfo->waiting_code = c;
}

static void compress_term(gif_dest_ptr dinfo )
{
  if(! dinfo->first_byte)
    output(dinfo, dinfo->waiting_code);
  output(dinfo, dinfo->EOFCode);
  if(dinfo->cur_bits > 0)
  {
    {
      (dinfo->packetbuf)[++ dinfo->bytesinpkt] = (char )(dinfo->cur_accum &
	0xFF);
      if(dinfo->bytesinpkt >= 255)
	flush_packet(dinfo);
    }
    ;
  }
  flush_packet(dinfo);
}

static void put_word(gif_dest_ptr dinfo , unsigned int w )
{
  _IO_putc(w & 0xFF, (dinfo->pub).output_file);
  _IO_putc(w >> 8 & 0xFF, (dinfo->pub).output_file);
}

static void put_3bytes(gif_dest_ptr dinfo , int val )
{
  _IO_putc(val, (dinfo->pub).output_file);
  _IO_putc(val, (dinfo->pub).output_file);
  _IO_putc(val, (dinfo->pub).output_file);
}

static void emit_header(gif_dest_ptr dinfo , int num_colors , JSAMPARRAY
  colormap )
{
  int BitsPerPixel , ColorMapSize , InitCodeSize , FlagByte ; /*decdef*/
  int cshift = (dinfo->cinfo)->data_precision - 8; /*decdef*/
  int i ; /*decdef*/
  if(num_colors > 256)
    ((dinfo->cinfo)->err)->msg_code = JERR_TOO_MANY_COLORS,
      ((((dinfo->cinfo)->err)->msg_parm).i)[0] = num_colors, (*
      ((dinfo->cinfo)->err)->error_exit)((j_common_ptr )dinfo->cinfo);
  BitsPerPixel = 1;
  while(num_colors > 1 << BitsPerPixel)
    BitsPerPixel++;
  ColorMapSize = 1 << BitsPerPixel;
  if(BitsPerPixel <= 1)
    InitCodeSize = 2;
  else
    InitCodeSize = BitsPerPixel;
  _IO_putc('G', (dinfo->pub).output_file);
  _IO_putc('I', (dinfo->pub).output_file);
  _IO_putc('F', (dinfo->pub).output_file);
  _IO_putc('8', (dinfo->pub).output_file);
  _IO_putc('7', (dinfo->pub).output_file);
  _IO_putc('a', (dinfo->pub).output_file);
  put_word(dinfo, (unsigned int )(dinfo->cinfo)->output_width);
  put_word(dinfo, (unsigned int )(dinfo->cinfo)->output_height);
  FlagByte = 0x80;
  FlagByte |= BitsPerPixel - 1 << 4;
  FlagByte |= BitsPerPixel - 1;
  _IO_putc(FlagByte, (dinfo->pub).output_file);
  _IO_putc(0, (dinfo->pub).output_file);
  _IO_putc(0, (dinfo->pub).output_file);
  for(i = 0; i < ColorMapSize; i++)
  {
    if(i < num_colors)
    {
      if(colormap != (void *  )0)
      {
	if((dinfo->cinfo)->out_color_space == JCS_RGB)
	{
	  _IO_putc((int )(colormap[0])[i] >> cshift, (dinfo->pub).output_file);
	  _IO_putc((int )(colormap[1])[i] >> cshift, (dinfo->pub).output_file);
	  _IO_putc((int )(colormap[2])[i] >> cshift, (dinfo->pub).output_file);
	}
	else
	{
	  put_3bytes(dinfo, (int )(colormap[0])[i] >> cshift);
	}
      }
      else
      {
	put_3bytes(dinfo, (i * 255 + (num_colors - 1) / 2) / (num_colors - 1));
      }
    }
    else
    {
      put_3bytes(dinfo, 0);
    }
  }
  _IO_putc(',', (dinfo->pub).output_file);
  put_word(dinfo, 0);
  put_word(dinfo, 0);
  put_word(dinfo, (unsigned int )(dinfo->cinfo)->output_width);
  put_word(dinfo, (unsigned int )(dinfo->cinfo)->output_height);
  _IO_putc(0x00, (dinfo->pub).output_file);
  _IO_putc(InitCodeSize, (dinfo->pub).output_file);
  compress_init(dinfo, InitCodeSize + 1);
}

static void start_output_gif(j_decompress_ptr cinfo , djpeg_dest_ptr dinfo )
{
  gif_dest_ptr dest = (gif_dest_ptr )dinfo; /*decdef*/
  if(cinfo->quantize_colors)
    emit_header(dest, cinfo->actual_number_of_colors, cinfo->colormap);
  else
    emit_header(dest, 256, (JSAMPARRAY )((void *  )0));
}

static void put_pixel_rows__0(j_decompress_ptr cinfo , djpeg_dest_ptr dinfo ,
  JDIMENSION rows_supplied )
{
  gif_dest_ptr dest = (gif_dest_ptr )dinfo; /*decdef*/
  register JSAMPROW ptr ; /*decdef*/
  register JDIMENSION col ; /*decdef*/
  ptr = ((dest->pub).buffer)[0];
  for(col = cinfo->output_width; col > 0; col--)
  {
    compress_byte(dest, (int )(* ptr++));
  }
}

static void finish_output_gif(j_decompress_ptr cinfo , djpeg_dest_ptr dinfo )
{
  gif_dest_ptr dest = (gif_dest_ptr )dinfo; /*decdef*/
  compress_term(dest);
  _IO_putc(0, (dest->pub).output_file);
  _IO_putc(';', (dest->pub).output_file);
  fflush((dest->pub).output_file);
  if(ferror((dest->pub).output_file))
    (cinfo->err)->msg_code = JERR_FILE_WRITE, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
}

djpeg_dest_ptr jinit_write_gif(j_decompress_ptr cinfo )
{
  gif_dest_ptr dest ; /*decdef*/
  dest = (gif_dest_ptr )(* (cinfo->mem)->alloc_small)((j_common_ptr )cinfo, 1,
    (size_t )sizeof(gif_dest_struct ));
  dest->cinfo = cinfo;
  (dest->pub).start_output = start_output_gif;
  (dest->pub).put_pixel_rows = put_pixel_rows__0;
  (dest->pub).finish_output = finish_output_gif;
  if(cinfo->out_color_space != JCS_GRAYSCALE && cinfo->out_color_space !=
    JCS_RGB)
    (cinfo->err)->msg_code = JERR_GIF_COLORSPACE, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  if(cinfo->out_color_space != JCS_GRAYSCALE || cinfo->data_precision > 8)
  {
    cinfo->quantize_colors = 1;
    if(cinfo->desired_number_of_colors > 256)
      cinfo->desired_number_of_colors = 256;
  }
  jpeg_calc_output_dimensions(cinfo);
  if(cinfo->output_components != 1)
    (cinfo->err)->msg_code = JERR_GIF_BUG, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  (dest->pub).buffer = (* (cinfo->mem)->alloc_sarray)((j_common_ptr )cinfo, 1,
    cinfo->output_width, (JDIMENSION )1);
  (dest->pub).buffer_height = 1;
  dest->hash_code = (code_int *  )(* (cinfo->mem)->alloc_small)((j_common_ptr
    )cinfo, 1, 5003 * (size_t )sizeof(code_int ));
  dest->hash_value = (hash_entry *  )(* (cinfo->mem)->alloc_large)((j_common_ptr
    )cinfo, 1, 5003 * (size_t )sizeof(hash_entry ));
  return (djpeg_dest_ptr )dest;
}


#pragma combiner("./rdtarga.i", "-g -O -I/home/scott/wrk/safec/cil/lib ")

#pragma boxalloc("malloc", nozero, sizein(0))

#pragma boxalloc("alloca", nozero, sizein(0))

#pragma boxalloc("calloc", zero, sizemul(0, 1))

#pragma boxprintf("printf", 0)

#pragma boxprintf("fprintf", 1)

#pragma boxprintf("sprintf", 1)

#pragma boxprintf("snprintf", 2)

#pragma boxpoly("memcpy")

#pragma boxexported("main")
typedef struct _tga_source_struct *  tga_source_ptr ; /*typedef*/

typedef struct _tga_source_struct {
  struct cjpeg_source_struct pub ;
  j_compress_ptr cinfo ;
  JSAMPARRAY colormap ;
  jvirt_sarray_ptr whole_image ;
  JDIMENSION current_row ;
  void ( *  read_pixel )(tga_source_ptr sinfo ) ;
  U_CHAR tga_pixel[4] ;
  int pixel_size ;
  int block_count ;
  int dup_pixel_count ;
  JDIMENSION ( *  get_pixel_rows )(j_compress_ptr cinfo , cjpeg_source_ptr sinfo
    ) ;
} tga_source_struct ; /*typedef*/

static const UINT8 c5to8bits[32] = {0, 8, 16, 24, 32, 41, 49, 57, 65, 74, 82,
  90, 98, 106, 115, 123, 131, 139, 148, 156, 164, 172, 180, 189, 197, 205, 213,
  222, 230, 238, 246, 255}; /*decdef*/

static int read_byte(tga_source_ptr sinfo )
{
  register FILE *  infile = (sinfo->pub).input_file; /*decdef*/
  register int c ; /*decdef*/
  if((c = _IO_getc(infile)) == - 1)
    ((sinfo->cinfo)->err)->msg_code = JERR_INPUT_EOF, (*
      ((sinfo->cinfo)->err)->error_exit)((j_common_ptr )sinfo->cinfo);
  return c;
}

static void read_colormap(tga_source_ptr sinfo , int cmaplen , int mapentrysize
  )
{
  int i ; /*decdef*/
  if(mapentrysize != 24)
    ((sinfo->cinfo)->err)->msg_code = JERR_TGA_BADCMAP, (*
      ((sinfo->cinfo)->err)->error_exit)((j_common_ptr )sinfo->cinfo);
  for(i = 0; i < cmaplen; i++)
  {
    ((sinfo->colormap)[2])[i] = (JSAMPLE )read_byte(sinfo);
    ((sinfo->colormap)[1])[i] = (JSAMPLE )read_byte(sinfo);
    ((sinfo->colormap)[0])[i] = (JSAMPLE )read_byte(sinfo);
  }
}

static void read_non_rle_pixel(tga_source_ptr sinfo )
{
  register FILE *  infile = (sinfo->pub).input_file; /*decdef*/
  register int i ; /*decdef*/
  for(i = 0; i < sinfo->pixel_size; i++)
  {
    (sinfo->tga_pixel)[i] = (U_CHAR )_IO_getc(infile);
  }
}

static void read_rle_pixel(tga_source_ptr sinfo )
{
  register FILE *  infile = (sinfo->pub).input_file; /*decdef*/
  register int i ; /*decdef*/
  if(sinfo->dup_pixel_count > 0)
  {
    sinfo->dup_pixel_count--;
    return;
  }
  if(-- sinfo->block_count < 0)
  {
    i = read_byte(sinfo);
    if(i & 0x80)
    {
      sinfo->dup_pixel_count = i & 0x7F;
      sinfo->block_count = 0;
    }
    else
    {
      sinfo->block_count = i & 0x7F;
    }
  }
  for(i = 0; i < sinfo->pixel_size; i++)
  {
    (sinfo->tga_pixel)[i] = (U_CHAR )_IO_getc(infile);
  }
}

static JDIMENSION get_8bit_gray_row(j_compress_ptr cinfo , cjpeg_source_ptr
  sinfo )
{
  tga_source_ptr source = (tga_source_ptr )sinfo; /*decdef*/
  register JSAMPROW ptr ; /*decdef*/
  register JDIMENSION col ; /*decdef*/
  ptr = ((source->pub).buffer)[0];
  for(col = cinfo->image_width; col > 0; col--)
  {
    (* source->read_pixel)(source);
    * ptr++ = (JSAMPLE )((int )(source->tga_pixel)[0]);
  }
  return 1;
}

static JDIMENSION get_8bit_row(j_compress_ptr cinfo , cjpeg_source_ptr sinfo )
{
  tga_source_ptr source = (tga_source_ptr )sinfo; /*decdef*/
  register int t ; /*decdef*/
  register JSAMPROW ptr ; /*decdef*/
  register JDIMENSION col ; /*decdef*/
  register JSAMPARRAY colormap = source->colormap; /*decdef*/
  ptr = ((source->pub).buffer)[0];
  for(col = cinfo->image_width; col > 0; col--)
  {
    (* source->read_pixel)(source);
    t = (int )(source->tga_pixel)[0];
    * ptr++ = (colormap[0])[t];
    * ptr++ = (colormap[1])[t];
    * ptr++ = (colormap[2])[t];
  }
  return 1;
}

static JDIMENSION get_16bit_row(j_compress_ptr cinfo , cjpeg_source_ptr sinfo )
{
  tga_source_ptr source = (tga_source_ptr )sinfo; /*decdef*/
  register int t ; /*decdef*/
  register JSAMPROW ptr ; /*decdef*/
  register JDIMENSION col ; /*decdef*/
  ptr = ((source->pub).buffer)[0];
  for(col = cinfo->image_width; col > 0; col--)
  {
    (* source->read_pixel)(source);
    t = (int )(source->tga_pixel)[0];
    t += (int )(source->tga_pixel)[1] << 8;
    ptr[2] = (JSAMPLE )c5to8bits[t & 0x1F];
    t >>= 5;
    ptr[1] = (JSAMPLE )c5to8bits[t & 0x1F];
    t >>= 5;
    ptr[0] = (JSAMPLE )c5to8bits[t & 0x1F];
    ptr += 3;
  }
  return 1;
}

static JDIMENSION get_24bit_row(j_compress_ptr cinfo , cjpeg_source_ptr sinfo )
{
  tga_source_ptr source = (tga_source_ptr )sinfo; /*decdef*/
  register JSAMPROW ptr ; /*decdef*/
  register JDIMENSION col ; /*decdef*/
  ptr = ((source->pub).buffer)[0];
  for(col = cinfo->image_width; col > 0; col--)
  {
    (* source->read_pixel)(source);
    * ptr++ = (JSAMPLE )((int )(source->tga_pixel)[2]);
    * ptr++ = (JSAMPLE )((int )(source->tga_pixel)[1]);
    * ptr++ = (JSAMPLE )((int )(source->tga_pixel)[0]);
  }
  return 1;
}

static JDIMENSION get_memory_row(j_compress_ptr cinfo , cjpeg_source_ptr sinfo )
{
  tga_source_ptr source = (tga_source_ptr )sinfo; /*decdef*/
  JDIMENSION source_row ; /*decdef*/
  source_row = cinfo->image_height - source->current_row - 1;
  (source->pub).buffer = (* (cinfo->mem)->access_virt_sarray)((j_common_ptr
    )cinfo, source->whole_image, source_row, 0);
  source->current_row++;
  return 1;
}

static JDIMENSION preload_image(j_compress_ptr cinfo , cjpeg_source_ptr sinfo )
{
  tga_source_ptr source = (tga_source_ptr )sinfo; /*decdef*/
  JDIMENSION row ; /*decdef*/
  cd_progress_ptr progress = (cd_progress_ptr )cinfo->progress; /*decdef*/
  for(row = 0; row < cinfo->image_height; row++)
  {
    if(progress != (void *  )0)
    {
      (progress->pub).pass_counter = (long )row;
      (progress->pub).pass_limit = (long )cinfo->image_height;
      (* (progress->pub).progress_monitor)((j_common_ptr )cinfo);
    }
    (source->pub).buffer = (* (cinfo->mem)->access_virt_sarray)((j_common_ptr
      )cinfo, source->whole_image, row, 1);
    (* source->get_pixel_rows)(cinfo, sinfo);
  }
  if(progress != (void *  )0)
    progress->completed_extra_passes++;
  (source->pub).get_pixel_rows = get_memory_row;
  source->current_row = 0;
  return get_memory_row(cinfo, sinfo);
}

static void start_input_tga(j_compress_ptr cinfo , cjpeg_source_ptr sinfo )
{
  tga_source_ptr source = (tga_source_ptr )sinfo; /*decdef*/
  U_CHAR targaheader[18] ; /*decdef*/
  int idlen , cmaptype , subtype , flags , interlace_type , components
    ; /*decdef*/
  unsigned int width , height , maplen ; /*decdef*/
  boolean is_bottom_up ; /*decdef*/
  if(! ((size_t )fread((void *  )targaheader, (size_t )1, (size_t )18,
    (source->pub).input_file) == (size_t )18))
    (cinfo->err)->msg_code = JERR_INPUT_EOF, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  if(targaheader[16] == 15)
    targaheader[16] = 16;
  idlen = (int )targaheader[0];
  cmaptype = (int )targaheader[1];
  subtype = (int )targaheader[2];
  maplen = (unsigned int )((int )targaheader[5]) +
    ((unsigned int )((int )targaheader[5 + 1]) << 8);
  width = (unsigned int )((int )targaheader[12]) +
    ((unsigned int )((int )targaheader[12 + 1]) << 8);
  height = (unsigned int )((int )targaheader[14]) +
    ((unsigned int )((int )targaheader[14 + 1]) << 8);
  source->pixel_size = (int )targaheader[16] >> 3;
  flags = (int )targaheader[17];
  is_bottom_up = (flags & 0x20) == 0;
  interlace_type = flags >> 6;
  if(cmaptype > 1 || source->pixel_size < 1 || source->pixel_size > 4 ||
    ((int )targaheader[16] & 7) != 0 || interlace_type != 0)
    (cinfo->err)->msg_code = JERR_TGA_BADPARMS, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  if(subtype > 8)
  {
    source->read_pixel = read_rle_pixel;
    source->block_count = (source->dup_pixel_count = 0);
    subtype -= 8;
  }
  else
  {
    source->read_pixel = read_non_rle_pixel;
  }
  components = 3;
  cinfo->in_color_space = JCS_RGB;
  switch(subtype)
  {
  case 1:
      ;
    if(source->pixel_size == 1 && cmaptype == 1)
      source->get_pixel_rows = get_8bit_row;
    else
      (cinfo->err)->msg_code = JERR_TGA_BADPARMS, (*
	(cinfo->err)->error_exit)((j_common_ptr )cinfo);
    (cinfo->err)->msg_code = JTRC_TGA_MAPPED, (((cinfo->err)->msg_parm).i)[0] =
      width, (((cinfo->err)->msg_parm).i)[1] = height, (*
      (cinfo->err)->emit_message)((j_common_ptr )cinfo, 1);
    break;
  case 2:
      ;
    switch(source->pixel_size)
    {
    case 2:
	;
      source->get_pixel_rows = get_16bit_row;
      break;
    case 3:
	;
      source->get_pixel_rows = get_24bit_row;
      break;
    case 4:
	;
      source->get_pixel_rows = get_24bit_row;
      break;
    default :
	;
      (cinfo->err)->msg_code = JERR_TGA_BADPARMS, (*
	(cinfo->err)->error_exit)((j_common_ptr )cinfo);
      break;
    }
    (cinfo->err)->msg_code = JTRC_TGA, (((cinfo->err)->msg_parm).i)[0] = width,
      (((cinfo->err)->msg_parm).i)[1] = height, (*
      (cinfo->err)->emit_message)((j_common_ptr )cinfo, 1);
    break;
  case 3:
      ;
    components = 1;
    cinfo->in_color_space = JCS_GRAYSCALE;
    if(source->pixel_size == 1)
      source->get_pixel_rows = get_8bit_gray_row;
    else
      (cinfo->err)->msg_code = JERR_TGA_BADPARMS, (*
	(cinfo->err)->error_exit)((j_common_ptr )cinfo);
    (cinfo->err)->msg_code = JTRC_TGA_GRAY, (((cinfo->err)->msg_parm).i)[0] =
      width, (((cinfo->err)->msg_parm).i)[1] = height, (*
      (cinfo->err)->emit_message)((j_common_ptr )cinfo, 1);
    break;
  default :
      ;
    (cinfo->err)->msg_code = JERR_TGA_BADPARMS, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
    break;
  }
  if(is_bottom_up)
  {
    source->whole_image = (* (cinfo->mem)->request_virt_sarray)((j_common_ptr
      )cinfo, 1, (JDIMENSION )width * components, (JDIMENSION )height,
      (JDIMENSION )1);
    if(cinfo->progress != (void *  )0)
    {
      cd_progress_ptr progress = (cd_progress_ptr )cinfo->progress; /*decdef*/
      progress->total_extra_passes++;
    }
    (source->pub).buffer_height = 1;
    (source->pub).get_pixel_rows = preload_image;
  }
  else
  {
    source->whole_image = (void *  )0;
    (source->pub).buffer = (* (cinfo->mem)->alloc_sarray)((j_common_ptr )cinfo,
      1, (JDIMENSION )width * components, (JDIMENSION )1);
    (source->pub).buffer_height = 1;
    (source->pub).get_pixel_rows = source->get_pixel_rows;
  }
  while(idlen--)
    (void )read_byte(source);
  if(maplen > 0)
  {
    if(maplen > 256 || (unsigned int )((int )targaheader[3]) +
      ((unsigned int )((int )targaheader[3 + 1]) << 8) != 0)
      (cinfo->err)->msg_code = JERR_TGA_BADCMAP, (*
	(cinfo->err)->error_exit)((j_common_ptr )cinfo);
    source->colormap = (* (cinfo->mem)->alloc_sarray)((j_common_ptr )cinfo, 1,
      (JDIMENSION )maplen, (JDIMENSION )3);
    read_colormap(source, (int )maplen, (int )targaheader[7]);
  }
  else
  {
    if(cmaptype)
      (cinfo->err)->msg_code = JERR_TGA_BADPARMS, (*
	(cinfo->err)->error_exit)((j_common_ptr )cinfo);
    source->colormap = (void *  )0;
  }
  cinfo->input_components = components;
  cinfo->data_precision = 8;
  cinfo->image_width = width;
  cinfo->image_height = height;
}

static void finish_input_tga(j_compress_ptr cinfo , cjpeg_source_ptr sinfo )
{
}

cjpeg_source_ptr jinit_read_targa(j_compress_ptr cinfo )
{
  tga_source_ptr source ; /*decdef*/
  source = (tga_source_ptr )(* (cinfo->mem)->alloc_small)((j_common_ptr )cinfo,
    1, (size_t )sizeof(tga_source_struct ));
  source->cinfo = cinfo;
  (source->pub).start_input = start_input_tga;
  (source->pub).finish_input = finish_input_tga;
  return (cjpeg_source_ptr )source;
}


#pragma combiner("./wrtarga.i", "-g -O -I/home/scott/wrk/safec/cil/lib ")

#pragma boxalloc("malloc", nozero, sizein(0))

#pragma boxalloc("alloca", nozero, sizein(0))

#pragma boxalloc("calloc", zero, sizemul(0, 1))

#pragma boxprintf("printf", 0)

#pragma boxprintf("fprintf", 1)

#pragma boxprintf("sprintf", 1)

#pragma boxprintf("snprintf", 2)

#pragma boxpoly("memcpy")

#pragma boxexported("main")
typedef struct  {
  struct djpeg_dest_struct pub ;
  char *  iobuffer ;
  JDIMENSION buffer_width ;
} tga_dest_struct ; /*typedef*/

typedef tga_dest_struct *  tga_dest_ptr ; /*typedef*/

static void write_header(j_decompress_ptr cinfo , djpeg_dest_ptr dinfo ,
  int num_colors )
{
  char targaheader[18] ; /*decdef*/
  memset((void *  )targaheader, 0, (size_t )((size_t )sizeof(targaheader)));
  if(num_colors > 0)
  {
    targaheader[1] = 1;
    targaheader[5] = (char )(num_colors & 0xFF);
    targaheader[6] = (char )(num_colors >> 8);
    targaheader[7] = 24;
  }
  targaheader[12] = (char )(cinfo->output_width & 0xFF);
  targaheader[13] = (char )(cinfo->output_width >> 8);
  targaheader[14] = (char )(cinfo->output_height & 0xFF);
  targaheader[15] = (char )(cinfo->output_height >> 8);
  targaheader[17] = 0x20;
  if(cinfo->out_color_space == JCS_GRAYSCALE)
  {
    targaheader[2] = 3;
    targaheader[16] = 8;
  }
  else
  {
    if(num_colors > 0)
    {
      targaheader[2] = 1;
      targaheader[16] = 8;
    }
    else
    {
      targaheader[2] = 2;
      targaheader[16] = 24;
    }
  }
  if((size_t )fwrite((const void *  )targaheader, (size_t )1, (size_t )18,
    dinfo->output_file) != (size_t )18)
    (cinfo->err)->msg_code = JERR_FILE_WRITE, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
}

static void put_pixel_rows__1(j_decompress_ptr cinfo , djpeg_dest_ptr dinfo ,
  JDIMENSION rows_supplied )
{
  tga_dest_ptr dest = (tga_dest_ptr )dinfo; /*decdef*/
  register JSAMPROW inptr ; /*decdef*/
  register char *  outptr ; /*decdef*/
  register JDIMENSION col ; /*decdef*/
  inptr = ((dest->pub).buffer)[0];
  outptr = dest->iobuffer;
  for(col = cinfo->output_width; col > 0; col--)
  {
    outptr[0] = (char )((int )inptr[2]);
    outptr[1] = (char )((int )inptr[1]);
    outptr[2] = (char )((int )inptr[0]);
    inptr += 3, outptr += 3;
  }
  (void )((size_t )fwrite((const void *  )dest->iobuffer, (size_t )1, (size_t
    )dest->buffer_width, (dest->pub).output_file));
}

static void put_gray_rows(j_decompress_ptr cinfo , djpeg_dest_ptr dinfo ,
  JDIMENSION rows_supplied )
{
  tga_dest_ptr dest = (tga_dest_ptr )dinfo; /*decdef*/
  register JSAMPROW inptr ; /*decdef*/
  register char *  outptr ; /*decdef*/
  register JDIMENSION col ; /*decdef*/
  inptr = ((dest->pub).buffer)[0];
  outptr = dest->iobuffer;
  for(col = cinfo->output_width; col > 0; col--)
  {
    * outptr++ = (char )((int )(* inptr++));
  }
  (void )((size_t )fwrite((const void *  )dest->iobuffer, (size_t )1, (size_t
    )dest->buffer_width, (dest->pub).output_file));
}

static void put_demapped_gray__0(j_decompress_ptr cinfo , djpeg_dest_ptr dinfo ,
  JDIMENSION rows_supplied )
{
  tga_dest_ptr dest = (tga_dest_ptr )dinfo; /*decdef*/
  register JSAMPROW inptr ; /*decdef*/
  register char *  outptr ; /*decdef*/
  register JSAMPROW color_map0 = (cinfo->colormap)[0]; /*decdef*/
  register JDIMENSION col ; /*decdef*/
  inptr = ((dest->pub).buffer)[0];
  outptr = dest->iobuffer;
  for(col = cinfo->output_width; col > 0; col--)
  {
    * outptr++ = (char )((int )color_map0[(int )(* inptr++)]);
  }
  (void )((size_t )fwrite((const void *  )dest->iobuffer, (size_t )1, (size_t
    )dest->buffer_width, (dest->pub).output_file));
}

static void start_output_tga(j_decompress_ptr cinfo , djpeg_dest_ptr dinfo )
{
  tga_dest_ptr dest = (tga_dest_ptr )dinfo; /*decdef*/
  int num_colors , i ; /*decdef*/
  FILE *  outfile ; /*decdef*/
  if(cinfo->out_color_space == JCS_GRAYSCALE)
  {
    write_header(cinfo, dinfo, 0);
    if(cinfo->quantize_colors)
      (dest->pub).put_pixel_rows = put_demapped_gray__0;
    else
      (dest->pub).put_pixel_rows = put_gray_rows;
  }
  else
  {
    if(cinfo->out_color_space == JCS_RGB)
    {
      if(cinfo->quantize_colors)
      {
	num_colors = cinfo->actual_number_of_colors;
	if(num_colors > 256)
	  (cinfo->err)->msg_code = JERR_TOO_MANY_COLORS,
	    (((cinfo->err)->msg_parm).i)[0] = num_colors, (*
	    (cinfo->err)->error_exit)((j_common_ptr )cinfo);
	write_header(cinfo, dinfo, num_colors);
	outfile = (dest->pub).output_file;
	for(i = 0; i < num_colors; i++)
	{
	  _IO_putc((int )((cinfo->colormap)[2])[i], outfile);
	  _IO_putc((int )((cinfo->colormap)[1])[i], outfile);
	  _IO_putc((int )((cinfo->colormap)[0])[i], outfile);
	}
	(dest->pub).put_pixel_rows = put_gray_rows;
      }
      else
      {
	write_header(cinfo, dinfo, 0);
	(dest->pub).put_pixel_rows = put_pixel_rows__1;
      }
    }
    else
    {
      (cinfo->err)->msg_code = JERR_TGA_COLORSPACE, (*
	(cinfo->err)->error_exit)((j_common_ptr )cinfo);
    }
  }
}

static void finish_output_tga(j_decompress_ptr cinfo , djpeg_dest_ptr dinfo )
{
  fflush(dinfo->output_file);
  if(ferror(dinfo->output_file))
    (cinfo->err)->msg_code = JERR_FILE_WRITE, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
}

djpeg_dest_ptr jinit_write_targa(j_decompress_ptr cinfo )
{
  tga_dest_ptr dest ; /*decdef*/
  dest = (tga_dest_ptr )(* (cinfo->mem)->alloc_small)((j_common_ptr )cinfo, 1,
    (size_t )sizeof(tga_dest_struct ));
  (dest->pub).start_output = start_output_tga;
  (dest->pub).finish_output = finish_output_tga;
  jpeg_calc_output_dimensions(cinfo);
  dest->buffer_width = cinfo->output_width * cinfo->output_components;
  dest->iobuffer = (char *  )(* (cinfo->mem)->alloc_small)((j_common_ptr )cinfo,
    1, (size_t )(dest->buffer_width * (size_t )sizeof(char )));
  (dest->pub).buffer = (* (cinfo->mem)->alloc_sarray)((j_common_ptr )cinfo, 1,
    dest->buffer_width, (JDIMENSION )1);
  (dest->pub).buffer_height = 1;
  return (djpeg_dest_ptr )dest;
}


#pragma combiner("./rdbmp.i", "-g -O -I/home/scott/wrk/safec/cil/lib ")

#pragma boxalloc("malloc", nozero, sizein(0))

#pragma boxalloc("alloca", nozero, sizein(0))

#pragma boxalloc("calloc", zero, sizemul(0, 1))

#pragma boxprintf("printf", 0)

#pragma boxprintf("fprintf", 1)

#pragma boxprintf("sprintf", 1)

#pragma boxprintf("snprintf", 2)

#pragma boxpoly("memcpy")

#pragma boxexported("main")
typedef struct _bmp_source_struct *  bmp_source_ptr ; /*typedef*/

typedef struct _bmp_source_struct {
  struct cjpeg_source_struct pub ;
  j_compress_ptr cinfo ;
  JSAMPARRAY colormap ;
  jvirt_sarray_ptr whole_image ;
  JDIMENSION source_row ;
  JDIMENSION row_width ;
  int bits_per_pixel ;
} bmp_source_struct ; /*typedef*/

static int read_byte__0(bmp_source_ptr sinfo )
{
  register FILE *  infile = (sinfo->pub).input_file; /*decdef*/
  register int c ; /*decdef*/
  if((c = _IO_getc(infile)) == - 1)
    ((sinfo->cinfo)->err)->msg_code = JERR_INPUT_EOF, (*
      ((sinfo->cinfo)->err)->error_exit)((j_common_ptr )sinfo->cinfo);
  return c;
}

static void read_colormap__0(bmp_source_ptr sinfo , int cmaplen ,
  int mapentrysize )
{
  int i ; /*decdef*/
  switch(mapentrysize)
  {
  case 3:
      ;
    for(i = 0; i < cmaplen; i++)
    {
      ((sinfo->colormap)[2])[i] = (JSAMPLE )read_byte__0(sinfo);
      ((sinfo->colormap)[1])[i] = (JSAMPLE )read_byte__0(sinfo);
      ((sinfo->colormap)[0])[i] = (JSAMPLE )read_byte__0(sinfo);
    }
    break;
  case 4:
      ;
    for(i = 0; i < cmaplen; i++)
    {
      ((sinfo->colormap)[2])[i] = (JSAMPLE )read_byte__0(sinfo);
      ((sinfo->colormap)[1])[i] = (JSAMPLE )read_byte__0(sinfo);
      ((sinfo->colormap)[0])[i] = (JSAMPLE )read_byte__0(sinfo);
      (void )read_byte__0(sinfo);
    }
    break;
  default :
      ;
    ((sinfo->cinfo)->err)->msg_code = JERR_BMP_BADCMAP, (*
      ((sinfo->cinfo)->err)->error_exit)((j_common_ptr )sinfo->cinfo);
    break;
  }
}

static JDIMENSION get_8bit_row__0(j_compress_ptr cinfo , cjpeg_source_ptr sinfo
  )
{
  bmp_source_ptr source = (bmp_source_ptr )sinfo; /*decdef*/
  register JSAMPARRAY colormap = source->colormap; /*decdef*/
  JSAMPARRAY image_ptr ; /*decdef*/
  register int t ; /*decdef*/
  register JSAMPROW inptr , outptr ; /*decdef*/
  register JDIMENSION col ; /*decdef*/
  source->source_row--;
  image_ptr = (* (cinfo->mem)->access_virt_sarray)((j_common_ptr )cinfo,
    source->whole_image, source->source_row, 0);
  inptr = image_ptr[0];
  outptr = ((source->pub).buffer)[0];
  for(col = cinfo->image_width; col > 0; col--)
  {
    t = (int )(* inptr++);
    * outptr++ = (colormap[0])[t];
    * outptr++ = (colormap[1])[t];
    * outptr++ = (colormap[2])[t];
  }
  return 1;
}

static JDIMENSION get_24bit_row__0(j_compress_ptr cinfo , cjpeg_source_ptr sinfo
  )
{
  bmp_source_ptr source = (bmp_source_ptr )sinfo; /*decdef*/
  JSAMPARRAY image_ptr ; /*decdef*/
  register JSAMPROW inptr , outptr ; /*decdef*/
  register JDIMENSION col ; /*decdef*/
  source->source_row--;
  image_ptr = (* (cinfo->mem)->access_virt_sarray)((j_common_ptr )cinfo,
    source->whole_image, source->source_row, 0);
  inptr = image_ptr[0];
  outptr = ((source->pub).buffer)[0];
  for(col = cinfo->image_width; col > 0; col--)
  {
    outptr[2] = * inptr++;
    outptr[1] = * inptr++;
    outptr[0] = * inptr++;
    outptr += 3;
  }
  return 1;
}

static JDIMENSION preload_image__0(j_compress_ptr cinfo , cjpeg_source_ptr sinfo
  )
{
  bmp_source_ptr source = (bmp_source_ptr )sinfo; /*decdef*/
  register FILE *  infile = (source->pub).input_file; /*decdef*/
  register int c ; /*decdef*/
  register JSAMPROW out_ptr ; /*decdef*/
  JSAMPARRAY image_ptr ; /*decdef*/
  JDIMENSION row , col ; /*decdef*/
  cd_progress_ptr progress = (cd_progress_ptr )cinfo->progress; /*decdef*/
  for(row = 0; row < cinfo->image_height; row++)
  {
    if(progress != (void *  )0)
    {
      (progress->pub).pass_counter = (long )row;
      (progress->pub).pass_limit = (long )cinfo->image_height;
      (* (progress->pub).progress_monitor)((j_common_ptr )cinfo);
    }
    image_ptr = (* (cinfo->mem)->access_virt_sarray)((j_common_ptr )cinfo,
      source->whole_image, row, 1);
    out_ptr = image_ptr[0];
    for(col = source->row_width; col > 0; col--)
    {
      if((c = _IO_getc(infile)) == - 1)
	(cinfo->err)->msg_code = JERR_INPUT_EOF, (*
	  (cinfo->err)->error_exit)((j_common_ptr )cinfo);
      * out_ptr++ = (JSAMPLE )c;
    }
  }
  if(progress != (void *  )0)
    progress->completed_extra_passes++;
  switch(source->bits_per_pixel)
  {
  case 8:
      ;
    (source->pub).get_pixel_rows = get_8bit_row__0;
    break;
  case 24:
      ;
    (source->pub).get_pixel_rows = get_24bit_row__0;
    break;
  default :
      ;
    (cinfo->err)->msg_code = JERR_BMP_BADDEPTH, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  }
  source->source_row = cinfo->image_height;
  return (* (source->pub).get_pixel_rows)(cinfo, sinfo);
}

static void start_input_bmp(j_compress_ptr cinfo , cjpeg_source_ptr sinfo )
{
  bmp_source_ptr source = (bmp_source_ptr )sinfo; /*decdef*/
  U_CHAR bmpfileheader[14] ; /*decdef*/
  U_CHAR bmpinfoheader[64] ; /*decdef*/
  INT32 headerSize ; /*decdef*/
  INT32 biWidth = 0; /*decdef*/
  INT32 biHeight = 0; /*decdef*/
  unsigned int biPlanes ; /*decdef*/
  INT32 biCompression ; /*decdef*/
  INT32 biXPelsPerMeter , biYPelsPerMeter ; /*decdef*/
  INT32 biClrUsed = 0; /*decdef*/
  int mapentrysize = 0; /*decdef*/
  JDIMENSION row_width ; /*decdef*/
  if(! ((size_t )fread((void *  )bmpfileheader, (size_t )1, (size_t )14,
    (source->pub).input_file) == (size_t )14))
    (cinfo->err)->msg_code = JERR_INPUT_EOF, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  if((unsigned int )((int )bmpfileheader[0]) +
    ((unsigned int )((int )bmpfileheader[0 + 1]) << 8) != 0x4D42)
    (cinfo->err)->msg_code = JERR_BMP_NOT, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  if(! ((size_t )fread((void *  )bmpinfoheader, (size_t )1, (size_t )4,
    (source->pub).input_file) == (size_t )4))
    (cinfo->err)->msg_code = JERR_INPUT_EOF, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  headerSize = (INT32 )((INT32 )((int )bmpinfoheader[0]) + ((INT32
    )((int )bmpinfoheader[0 + 1]) << 8) + ((INT32 )((int )bmpinfoheader[0 + 2])
    << 16) + ((INT32 )((int )bmpinfoheader[0 + 3]) << 24));
  if(headerSize < 12 || headerSize > 64)
    (cinfo->err)->msg_code = JERR_BMP_BADHEADER, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  if(! ((size_t )fread((void *  )(bmpinfoheader + 4), (size_t )1, (size_t
    )(headerSize - 4), (source->pub).input_file) == (size_t )(headerSize - 4)))
    (cinfo->err)->msg_code = JERR_INPUT_EOF, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  switch((int )headerSize)
  {
  case 12:
      ;
    biWidth = (INT32 )((unsigned int )((int )bmpinfoheader[4]) +
      ((unsigned int )((int )bmpinfoheader[4 + 1]) << 8));
    biHeight = (INT32 )((unsigned int )((int )bmpinfoheader[6]) +
      ((unsigned int )((int )bmpinfoheader[6 + 1]) << 8));
    biPlanes = (unsigned int )((int )bmpinfoheader[8]) +
      ((unsigned int )((int )bmpinfoheader[8 + 1]) << 8);
    source->bits_per_pixel = (int )((unsigned int )((int )bmpinfoheader[10]) +
      ((unsigned int )((int )bmpinfoheader[10 + 1]) << 8));
    switch(source->bits_per_pixel)
    {
    case 8:
	;
      mapentrysize = 3;
      (cinfo->err)->msg_code = JTRC_BMP_OS2_MAPPED,
	(((cinfo->err)->msg_parm).i)[0] = (int )biWidth,
	(((cinfo->err)->msg_parm).i)[1] = (int )biHeight, (*
	(cinfo->err)->emit_message)((j_common_ptr )cinfo, 1);
      break;
    case 24:
	;
      (cinfo->err)->msg_code = JTRC_BMP_OS2, (((cinfo->err)->msg_parm).i)[0] =
	(int )biWidth, (((cinfo->err)->msg_parm).i)[1] = (int )biHeight, (*
	(cinfo->err)->emit_message)((j_common_ptr )cinfo, 1);
      break;
    default :
	;
      (cinfo->err)->msg_code = JERR_BMP_BADDEPTH, (*
	(cinfo->err)->error_exit)((j_common_ptr )cinfo);
      break;
    }
    if(biPlanes != 1)
      (cinfo->err)->msg_code = JERR_BMP_BADPLANES, (*
	(cinfo->err)->error_exit)((j_common_ptr )cinfo);
    break;
  case 40:
      ;
  case 64:
      ;
    biWidth = (INT32 )((int )bmpinfoheader[4]) + ((INT32 )((int )bmpinfoheader[4
      + 1]) << 8) + ((INT32 )((int )bmpinfoheader[4 + 2]) << 16) + ((INT32
      )((int )bmpinfoheader[4 + 3]) << 24);
    biHeight = (INT32 )((int )bmpinfoheader[8]) + ((INT32
      )((int )bmpinfoheader[8 + 1]) << 8) + ((INT32 )((int )bmpinfoheader[8 +
      2]) << 16) + ((INT32 )((int )bmpinfoheader[8 + 3]) << 24);
    biPlanes = (unsigned int )((int )bmpinfoheader[12]) +
      ((unsigned int )((int )bmpinfoheader[12 + 1]) << 8);
    source->bits_per_pixel = (int )((unsigned int )((int )bmpinfoheader[14]) +
      ((unsigned int )((int )bmpinfoheader[14 + 1]) << 8));
    biCompression = (INT32 )((int )bmpinfoheader[16]) + ((INT32
      )((int )bmpinfoheader[16 + 1]) << 8) + ((INT32 )((int )bmpinfoheader[16 +
      2]) << 16) + ((INT32 )((int )bmpinfoheader[16 + 3]) << 24);
    biXPelsPerMeter = (INT32 )((int )bmpinfoheader[24]) + ((INT32
      )((int )bmpinfoheader[24 + 1]) << 8) + ((INT32 )((int )bmpinfoheader[24 +
      2]) << 16) + ((INT32 )((int )bmpinfoheader[24 + 3]) << 24);
    biYPelsPerMeter = (INT32 )((int )bmpinfoheader[28]) + ((INT32
      )((int )bmpinfoheader[28 + 1]) << 8) + ((INT32 )((int )bmpinfoheader[28 +
      2]) << 16) + ((INT32 )((int )bmpinfoheader[28 + 3]) << 24);
    biClrUsed = (INT32 )((int )bmpinfoheader[32]) + ((INT32
      )((int )bmpinfoheader[32 + 1]) << 8) + ((INT32 )((int )bmpinfoheader[32 +
      2]) << 16) + ((INT32 )((int )bmpinfoheader[32 + 3]) << 24);
    switch(source->bits_per_pixel)
    {
    case 8:
	;
      mapentrysize = 4;
      (cinfo->err)->msg_code = JTRC_BMP_MAPPED, (((cinfo->err)->msg_parm).i)[0]
	= (int )biWidth, (((cinfo->err)->msg_parm).i)[1] = (int )biHeight, (*
	(cinfo->err)->emit_message)((j_common_ptr )cinfo, 1);
      break;
    case 24:
	;
      (cinfo->err)->msg_code = JTRC_BMP, (((cinfo->err)->msg_parm).i)[0] =
	(int )biWidth, (((cinfo->err)->msg_parm).i)[1] = (int )biHeight, (*
	(cinfo->err)->emit_message)((j_common_ptr )cinfo, 1);
      break;
    default :
	;
      (cinfo->err)->msg_code = JERR_BMP_BADDEPTH, (*
	(cinfo->err)->error_exit)((j_common_ptr )cinfo);
      break;
    }
    if(biPlanes != 1)
      (cinfo->err)->msg_code = JERR_BMP_BADPLANES, (*
	(cinfo->err)->error_exit)((j_common_ptr )cinfo);
    if(biCompression != 0)
      (cinfo->err)->msg_code = JERR_BMP_COMPRESSED, (*
	(cinfo->err)->error_exit)((j_common_ptr )cinfo);
    if(biXPelsPerMeter > 0 && biYPelsPerMeter > 0)
    {
      cinfo->X_density = (UINT16 )(biXPelsPerMeter / 100);
      cinfo->Y_density = (UINT16 )(biYPelsPerMeter / 100);
      cinfo->density_unit = 2;
    }
    break;
  default :
      ;
    (cinfo->err)->msg_code = JERR_BMP_BADHEADER, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
    break;
  }
  if(mapentrysize > 0)
  {
    if(biClrUsed <= 0)
      biClrUsed = 256;
    else
    {
      if(biClrUsed > 256)
	(cinfo->err)->msg_code = JERR_BMP_BADCMAP, (*
	  (cinfo->err)->error_exit)((j_common_ptr )cinfo);
    }
    source->colormap = (* (cinfo->mem)->alloc_sarray)((j_common_ptr )cinfo, 1,
      (JDIMENSION )biClrUsed, (JDIMENSION )3);
    read_colormap__0(source, (int )biClrUsed, mapentrysize);
  }
  if(source->bits_per_pixel == 24)
    row_width = (JDIMENSION )(biWidth * 3);
  else
    row_width = (JDIMENSION )biWidth;
  while((row_width & 3) != 0)
    row_width++;
  source->row_width = row_width;
  source->whole_image = (* (cinfo->mem)->request_virt_sarray)((j_common_ptr
    )cinfo, 1, row_width, (JDIMENSION )biHeight, (JDIMENSION )1);
  (source->pub).get_pixel_rows = preload_image__0;
  if(cinfo->progress != (void *  )0)
  {
    cd_progress_ptr progress = (cd_progress_ptr )cinfo->progress; /*decdef*/
    progress->total_extra_passes++;
  }
  (source->pub).buffer = (* (cinfo->mem)->alloc_sarray)((j_common_ptr )cinfo, 1,
    (JDIMENSION )(biWidth * 3), (JDIMENSION )1);
  (source->pub).buffer_height = 1;
  cinfo->in_color_space = JCS_RGB;
  cinfo->input_components = 3;
  cinfo->data_precision = 8;
  cinfo->image_width = (JDIMENSION )biWidth;
  cinfo->image_height = (JDIMENSION )biHeight;
}

static void finish_input_bmp(j_compress_ptr cinfo , cjpeg_source_ptr sinfo )
{
}

cjpeg_source_ptr jinit_read_bmp(j_compress_ptr cinfo )
{
  bmp_source_ptr source ; /*decdef*/
  source = (bmp_source_ptr )(* (cinfo->mem)->alloc_small)((j_common_ptr )cinfo,
    1, (size_t )sizeof(bmp_source_struct ));
  source->cinfo = cinfo;
  (source->pub).start_input = start_input_bmp;
  (source->pub).finish_input = finish_input_bmp;
  return (cjpeg_source_ptr )source;
}


#pragma combiner("./wrbmp.i", "-g -O -I/home/scott/wrk/safec/cil/lib ")

#pragma boxalloc("malloc", nozero, sizein(0))

#pragma boxalloc("alloca", nozero, sizein(0))

#pragma boxalloc("calloc", zero, sizemul(0, 1))

#pragma boxprintf("printf", 0)

#pragma boxprintf("fprintf", 1)

#pragma boxprintf("sprintf", 1)

#pragma boxprintf("snprintf", 2)

#pragma boxpoly("memcpy")

#pragma boxexported("main")
typedef struct  {
  struct djpeg_dest_struct pub ;
  boolean is_os2 ;
  jvirt_sarray_ptr whole_image ;
  JDIMENSION data_width ;
  JDIMENSION row_width ;
  int pad_bytes ;
  JDIMENSION cur_output_row ;
} bmp_dest_struct ; /*typedef*/

typedef bmp_dest_struct *  bmp_dest_ptr ; /*typedef*/

static void write_colormap(j_decompress_ptr cinfo , bmp_dest_ptr dest ,
  int map_colors , int map_entry_size ) ; /*decdef*/

static void put_pixel_rows__2(j_decompress_ptr cinfo , djpeg_dest_ptr dinfo ,
  JDIMENSION rows_supplied )
{
  bmp_dest_ptr dest = (bmp_dest_ptr )dinfo; /*decdef*/
  JSAMPARRAY image_ptr ; /*decdef*/
  register JSAMPROW inptr , outptr ; /*decdef*/
  register JDIMENSION col ; /*decdef*/
  int pad ; /*decdef*/
  image_ptr = (* (cinfo->mem)->access_virt_sarray)((j_common_ptr )cinfo,
    dest->whole_image, dest->cur_output_row, 1);
  dest->cur_output_row++;
  inptr = ((dest->pub).buffer)[0];
  outptr = image_ptr[0];
  for(col = cinfo->output_width; col > 0; col--)
  {
    outptr[2] = * inptr++;
    outptr[1] = * inptr++;
    outptr[0] = * inptr++;
    outptr += 3;
  }
  pad = dest->pad_bytes;
  while(-- pad >= 0)
    * outptr++ = 0;
}

static void put_gray_rows__0(j_decompress_ptr cinfo , djpeg_dest_ptr dinfo ,
  JDIMENSION rows_supplied )
{
  bmp_dest_ptr dest = (bmp_dest_ptr )dinfo; /*decdef*/
  JSAMPARRAY image_ptr ; /*decdef*/
  register JSAMPROW inptr , outptr ; /*decdef*/
  register JDIMENSION col ; /*decdef*/
  int pad ; /*decdef*/
  image_ptr = (* (cinfo->mem)->access_virt_sarray)((j_common_ptr )cinfo,
    dest->whole_image, dest->cur_output_row, 1);
  dest->cur_output_row++;
  inptr = ((dest->pub).buffer)[0];
  outptr = image_ptr[0];
  for(col = cinfo->output_width; col > 0; col--)
  {
    * outptr++ = * inptr++;
  }
  pad = dest->pad_bytes;
  while(-- pad >= 0)
    * outptr++ = 0;
}

static void start_output_bmp(j_decompress_ptr cinfo , djpeg_dest_ptr dinfo )
{
}

static void write_bmp_header(j_decompress_ptr cinfo , bmp_dest_ptr dest )
{
  char bmpfileheader[14] ; /*decdef*/
  char bmpinfoheader[40] ; /*decdef*/
  INT32 headersize , bfSize ; /*decdef*/
  int bits_per_pixel , cmap_entries ; /*decdef*/
  if(cinfo->out_color_space == JCS_RGB)
  {
    if(cinfo->quantize_colors)
    {
      bits_per_pixel = 8;
      cmap_entries = 256;
    }
    else
    {
      bits_per_pixel = 24;
      cmap_entries = 0;
    }
  }
  else
  {
    bits_per_pixel = 8;
    cmap_entries = 256;
  }
  headersize = 14 + 40 + cmap_entries * 4;
  bfSize = headersize + (INT32 )dest->row_width * (INT32 )cinfo->output_height;
  memset((void *  )bmpfileheader, 0, (size_t )((size_t )sizeof(bmpfileheader)));
  memset((void *  )bmpinfoheader, 0, (size_t )((size_t )sizeof(bmpinfoheader)));
  bmpfileheader[0] = 0x42;
  bmpfileheader[1] = 0x4D;
  bmpfileheader[2] = (char )(bfSize & 0xFF), bmpfileheader[2 + 1] =
    (char )(bfSize >> 8 & 0xFF), bmpfileheader[2 + 2] = (char )(bfSize >> 16 &
    0xFF), bmpfileheader[2 + 3] = (char )(bfSize >> 24 & 0xFF);
  bmpfileheader[10] = (char )(headersize & 0xFF), bmpfileheader[10 + 1] =
    (char )(headersize >> 8 & 0xFF), bmpfileheader[10 + 2] = (char )(headersize
    >> 16 & 0xFF), bmpfileheader[10 + 3] = (char )(headersize >> 24 & 0xFF);
  bmpinfoheader[0] = (char )(40 & 0xFF), bmpinfoheader[0 + 1] = (char )(40 >> 8
    & 0xFF);
  bmpinfoheader[4] = (char )(cinfo->output_width & 0xFF), bmpinfoheader[4 + 1] =
    (char )(cinfo->output_width >> 8 & 0xFF), bmpinfoheader[4 + 2] =
    (char )(cinfo->output_width >> 16 & 0xFF), bmpinfoheader[4 + 3] =
    (char )(cinfo->output_width >> 24 & 0xFF);
  bmpinfoheader[8] = (char )(cinfo->output_height & 0xFF), bmpinfoheader[8 + 1]
    = (char )(cinfo->output_height >> 8 & 0xFF), bmpinfoheader[8 + 2] =
    (char )(cinfo->output_height >> 16 & 0xFF), bmpinfoheader[8 + 3] =
    (char )(cinfo->output_height >> 24 & 0xFF);
  bmpinfoheader[12] = (char )(1 & 0xFF), bmpinfoheader[12 + 1] = (char )(1 >> 8
    & 0xFF);
  bmpinfoheader[14] = (char )(bits_per_pixel & 0xFF), bmpinfoheader[14 + 1] =
    (char )(bits_per_pixel >> 8 & 0xFF);
  if(cinfo->density_unit == 2)
  {
    bmpinfoheader[24] = (char )((INT32 )(cinfo->X_density * 100) & 0xFF),
      bmpinfoheader[24 + 1] = (char )((INT32 )(cinfo->X_density * 100) >> 8 &
      0xFF), bmpinfoheader[24 + 2] = (char )((INT32 )(cinfo->X_density * 100) >>
      16 & 0xFF), bmpinfoheader[24 + 3] = (char )((INT32 )(cinfo->X_density *
      100) >> 24 & 0xFF);
    bmpinfoheader[28] = (char )((INT32 )(cinfo->Y_density * 100) & 0xFF),
      bmpinfoheader[28 + 1] = (char )((INT32 )(cinfo->Y_density * 100) >> 8 &
      0xFF), bmpinfoheader[28 + 2] = (char )((INT32 )(cinfo->Y_density * 100) >>
      16 & 0xFF), bmpinfoheader[28 + 3] = (char )((INT32 )(cinfo->Y_density *
      100) >> 24 & 0xFF);
  }
  bmpinfoheader[32] = (char )(cmap_entries & 0xFF), bmpinfoheader[32 + 1] =
    (char )(cmap_entries >> 8 & 0xFF);
  if((size_t )fwrite((const void *  )bmpfileheader, (size_t )1, (size_t )14,
    (dest->pub).output_file) != (size_t )14)
    (cinfo->err)->msg_code = JERR_FILE_WRITE, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  if((size_t )fwrite((const void *  )bmpinfoheader, (size_t )1, (size_t )40,
    (dest->pub).output_file) != (size_t )40)
    (cinfo->err)->msg_code = JERR_FILE_WRITE, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  if(cmap_entries > 0)
    write_colormap(cinfo, dest, cmap_entries, 4);
}

static void write_os2_header(j_decompress_ptr cinfo , bmp_dest_ptr dest )
{
  char bmpfileheader[14] ; /*decdef*/
  char bmpcoreheader[12] ; /*decdef*/
  INT32 headersize , bfSize ; /*decdef*/
  int bits_per_pixel , cmap_entries ; /*decdef*/
  if(cinfo->out_color_space == JCS_RGB)
  {
    if(cinfo->quantize_colors)
    {
      bits_per_pixel = 8;
      cmap_entries = 256;
    }
    else
    {
      bits_per_pixel = 24;
      cmap_entries = 0;
    }
  }
  else
  {
    bits_per_pixel = 8;
    cmap_entries = 256;
  }
  headersize = 14 + 12 + cmap_entries * 3;
  bfSize = headersize + (INT32 )dest->row_width * (INT32 )cinfo->output_height;
  memset((void *  )bmpfileheader, 0, (size_t )((size_t )sizeof(bmpfileheader)));
  memset((void *  )bmpcoreheader, 0, (size_t )((size_t )sizeof(bmpcoreheader)));
  bmpfileheader[0] = 0x42;
  bmpfileheader[1] = 0x4D;
  bmpfileheader[2] = (char )(bfSize & 0xFF), bmpfileheader[2 + 1] =
    (char )(bfSize >> 8 & 0xFF), bmpfileheader[2 + 2] = (char )(bfSize >> 16 &
    0xFF), bmpfileheader[2 + 3] = (char )(bfSize >> 24 & 0xFF);
  bmpfileheader[10] = (char )(headersize & 0xFF), bmpfileheader[10 + 1] =
    (char )(headersize >> 8 & 0xFF), bmpfileheader[10 + 2] = (char )(headersize
    >> 16 & 0xFF), bmpfileheader[10 + 3] = (char )(headersize >> 24 & 0xFF);
  bmpcoreheader[0] = (char )(12 & 0xFF), bmpcoreheader[0 + 1] = (char )(12 >> 8
    & 0xFF);
  bmpcoreheader[4] = (char )(cinfo->output_width & 0xFF), bmpcoreheader[4 + 1] =
    (char )(cinfo->output_width >> 8 & 0xFF);
  bmpcoreheader[6] = (char )(cinfo->output_height & 0xFF), bmpcoreheader[6 + 1]
    = (char )(cinfo->output_height >> 8 & 0xFF);
  bmpcoreheader[8] = (char )(1 & 0xFF), bmpcoreheader[8 + 1] = (char )(1 >> 8 &
    0xFF);
  bmpcoreheader[10] = (char )(bits_per_pixel & 0xFF), bmpcoreheader[10 + 1] =
    (char )(bits_per_pixel >> 8 & 0xFF);
  if((size_t )fwrite((const void *  )bmpfileheader, (size_t )1, (size_t )14,
    (dest->pub).output_file) != (size_t )14)
    (cinfo->err)->msg_code = JERR_FILE_WRITE, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  if((size_t )fwrite((const void *  )bmpcoreheader, (size_t )1, (size_t )12,
    (dest->pub).output_file) != (size_t )12)
    (cinfo->err)->msg_code = JERR_FILE_WRITE, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  if(cmap_entries > 0)
    write_colormap(cinfo, dest, cmap_entries, 3);
}

static void write_colormap(j_decompress_ptr cinfo , bmp_dest_ptr dest ,
  int map_colors , int map_entry_size )
{
  JSAMPARRAY colormap = cinfo->colormap; /*decdef*/
  int num_colors = cinfo->actual_number_of_colors; /*decdef*/
  FILE *  outfile = (dest->pub).output_file; /*decdef*/
  int i ; /*decdef*/
  if(colormap != (void *  )0)
  {
    if(cinfo->out_color_components == 3)
    {
      for(i = 0; i < num_colors; i++)
      {
	_IO_putc((int )(colormap[2])[i], outfile);
	_IO_putc((int )(colormap[1])[i], outfile);
	_IO_putc((int )(colormap[0])[i], outfile);
	if(map_entry_size == 4)
	  _IO_putc(0, outfile);
      }
    }
    else
    {
      for(i = 0; i < num_colors; i++)
      {
	_IO_putc((int )(colormap[0])[i], outfile);
	_IO_putc((int )(colormap[0])[i], outfile);
	_IO_putc((int )(colormap[0])[i], outfile);
	if(map_entry_size == 4)
	  _IO_putc(0, outfile);
      }
    }
  }
  else
  {
    for(i = 0; i < 256; i++)
    {
      _IO_putc(i, outfile);
      _IO_putc(i, outfile);
      _IO_putc(i, outfile);
      if(map_entry_size == 4)
	_IO_putc(0, outfile);
    }
  }
  if(i > map_colors)
    (cinfo->err)->msg_code = JERR_TOO_MANY_COLORS,
      (((cinfo->err)->msg_parm).i)[0] = i, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  for(; i < map_colors; i++)
  {
    _IO_putc(0, outfile);
    _IO_putc(0, outfile);
    _IO_putc(0, outfile);
    if(map_entry_size == 4)
      _IO_putc(0, outfile);
  }
}

static void finish_output_bmp(j_decompress_ptr cinfo , djpeg_dest_ptr dinfo )
{
  bmp_dest_ptr dest = (bmp_dest_ptr )dinfo; /*decdef*/
  register FILE *  outfile = (dest->pub).output_file; /*decdef*/
  JSAMPARRAY image_ptr ; /*decdef*/
  register JSAMPROW data_ptr ; /*decdef*/
  JDIMENSION row ; /*decdef*/
  register JDIMENSION col ; /*decdef*/
  cd_progress_ptr progress = (cd_progress_ptr )cinfo->progress; /*decdef*/
  if(dest->is_os2)
    write_os2_header(cinfo, dest);
  else
    write_bmp_header(cinfo, dest);
  for(row = cinfo->output_height; row > 0; row--)
  {
    if(progress != (void *  )0)
    {
      (progress->pub).pass_counter = (long )(cinfo->output_height - row);
      (progress->pub).pass_limit = (long )cinfo->output_height;
      (* (progress->pub).progress_monitor)((j_common_ptr )cinfo);
    }
    image_ptr = (* (cinfo->mem)->access_virt_sarray)((j_common_ptr )cinfo,
      dest->whole_image, row - 1, 0);
    data_ptr = image_ptr[0];
    for(col = dest->row_width; col > 0; col--)
    {
      _IO_putc((int )(* data_ptr), outfile);
      data_ptr++;
    }
  }
  if(progress != (void *  )0)
    progress->completed_extra_passes++;
  fflush(outfile);
  if(ferror(outfile))
    (cinfo->err)->msg_code = JERR_FILE_WRITE, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
}

djpeg_dest_ptr jinit_write_bmp(j_decompress_ptr cinfo , boolean is_os2 )
{
  bmp_dest_ptr dest ; /*decdef*/
  JDIMENSION row_width ; /*decdef*/
  dest = (bmp_dest_ptr )(* (cinfo->mem)->alloc_small)((j_common_ptr )cinfo, 1,
    (size_t )sizeof(bmp_dest_struct ));
  (dest->pub).start_output = start_output_bmp;
  (dest->pub).finish_output = finish_output_bmp;
  dest->is_os2 = is_os2;
  if(cinfo->out_color_space == JCS_GRAYSCALE)
  {
    (dest->pub).put_pixel_rows = put_gray_rows__0;
  }
  else
  {
    if(cinfo->out_color_space == JCS_RGB)
    {
      if(cinfo->quantize_colors)
	(dest->pub).put_pixel_rows = put_gray_rows__0;
      else
	(dest->pub).put_pixel_rows = put_pixel_rows__2;
    }
    else
    {
      (cinfo->err)->msg_code = JERR_BMP_COLORSPACE, (*
	(cinfo->err)->error_exit)((j_common_ptr )cinfo);
    }
  }
  jpeg_calc_output_dimensions(cinfo);
  row_width = cinfo->output_width * cinfo->output_components;
  dest->data_width = row_width;
  while((row_width & 3) != 0)
    row_width++;
  dest->row_width = row_width;
  dest->pad_bytes = (int )(row_width - dest->data_width);
  dest->whole_image = (* (cinfo->mem)->request_virt_sarray)((j_common_ptr
    )cinfo, 1, row_width, cinfo->output_height, (JDIMENSION )1);
  dest->cur_output_row = 0;
  if(cinfo->progress != (void *  )0)
  {
    cd_progress_ptr progress = (cd_progress_ptr )cinfo->progress; /*decdef*/
    progress->total_extra_passes++;
  }
  (dest->pub).buffer = (* (cinfo->mem)->alloc_sarray)((j_common_ptr )cinfo, 1,
    row_width, (JDIMENSION )1);
  (dest->pub).buffer_height = 1;
  return (djpeg_dest_ptr )dest;
}


#pragma combiner("./jcapi.i", "-g -O -I/home/scott/wrk/safec/cil/lib ")

#pragma boxalloc("malloc", nozero, sizein(0))

#pragma boxalloc("alloca", nozero, sizein(0))

#pragma boxalloc("calloc", zero, sizemul(0, 1))

#pragma boxprintf("printf", 0)

#pragma boxprintf("fprintf", 1)

#pragma boxprintf("sprintf", 1)

#pragma boxprintf("snprintf", 2)

#pragma boxpoly("memcpy")

#pragma boxexported("main")
void jpeg_create_compress(j_compress_ptr cinfo )
{
  int i ; /*decdef*/
  {
    struct jpeg_error_mgr *  err = cinfo->err; /*decdef*/
    memset((void *  )cinfo, 0, (size_t )((size_t )sizeof(* cinfo)));
    cinfo->err = err;
  }
  cinfo->is_decompressor = 0;
  jinit_memory_mgr((j_common_ptr )cinfo);
  cinfo->progress = (void *  )0;
  cinfo->dest = (void *  )0;
  cinfo->comp_info = (void *  )0;
  for(i = 0; i < 4; i++)
    (cinfo->quant_tbl_ptrs)[i] = (void *  )0;
  for(i = 0; i < 4; i++)
  {
    (cinfo->dc_huff_tbl_ptrs)[i] = (void *  )0;
    (cinfo->ac_huff_tbl_ptrs)[i] = (void *  )0;
  }
  cinfo->input_gamma = 1.0;
  cinfo->global_state = 100;
}

void jpeg_destroy_compress(j_compress_ptr cinfo )
{
  jpeg_destroy((j_common_ptr )cinfo);
}

void jpeg_suppress_tables(j_compress_ptr cinfo , boolean suppress )
{
  int i ; /*decdef*/
  JQUANT_TBL *  qtbl ; /*decdef*/
  JHUFF_TBL *  htbl ; /*decdef*/
  for(i = 0; i < 4; i++)
  {
    if((qtbl = (cinfo->quant_tbl_ptrs)[i]) != (void *  )0)
      qtbl->sent_table = suppress;
  }
  for(i = 0; i < 4; i++)
  {
    if((htbl = (cinfo->dc_huff_tbl_ptrs)[i]) != (void *  )0)
      htbl->sent_table = suppress;
    if((htbl = (cinfo->ac_huff_tbl_ptrs)[i]) != (void *  )0)
      htbl->sent_table = suppress;
  }
}

void jpeg_start_compress(j_compress_ptr cinfo , boolean write_all_tables )
{
  if(cinfo->global_state != 100)
    (cinfo->err)->msg_code = JERR_BAD_STATE, (((cinfo->err)->msg_parm).i)[0] =
      cinfo->global_state, (* (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  if(write_all_tables)
    jpeg_suppress_tables(cinfo, 0);
  (* (cinfo->err)->reset_error_mgr)((j_common_ptr )cinfo);
  (* (cinfo->dest)->init_destination)(cinfo);
  jinit_master_compress(cinfo);
  (* (cinfo->master)->prepare_for_pass)(cinfo);
  cinfo->next_scanline = 0;
  cinfo->global_state = cinfo->raw_data_in ? 102 : 101;
}

JDIMENSION jpeg_write_scanlines(j_compress_ptr cinfo , JSAMPARRAY scanlines ,
  JDIMENSION num_lines )
{
  JDIMENSION row_ctr , rows_left ; /*decdef*/
  if(cinfo->global_state != 101)
    (cinfo->err)->msg_code = JERR_BAD_STATE, (((cinfo->err)->msg_parm).i)[0] =
      cinfo->global_state, (* (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  if(cinfo->next_scanline >= cinfo->image_height)
    (cinfo->err)->msg_code = JWRN_TOO_MUCH_DATA, (*
      (cinfo->err)->emit_message)((j_common_ptr )cinfo, - 1);
  if(cinfo->progress != (void *  )0)
  {
    (cinfo->progress)->pass_counter = (long )cinfo->next_scanline;
    (cinfo->progress)->pass_limit = (long )cinfo->image_height;
    (* (cinfo->progress)->progress_monitor)((j_common_ptr )cinfo);
  }
  if((cinfo->master)->call_pass_startup)
    (* (cinfo->master)->pass_startup)(cinfo);
  rows_left = cinfo->image_height - cinfo->next_scanline;
  if(num_lines > rows_left)
    num_lines = rows_left;
  row_ctr = 0;
  (* (cinfo->main)->process_data)(cinfo, scanlines, & row_ctr, num_lines);
  cinfo->next_scanline += row_ctr;
  return row_ctr;
}

JDIMENSION jpeg_write_raw_data(j_compress_ptr cinfo , JSAMPIMAGE data ,
  JDIMENSION num_lines )
{
  JDIMENSION mcu_ctr , lines_per_MCU_row ; /*decdef*/
  if(cinfo->global_state != 102)
    (cinfo->err)->msg_code = JERR_BAD_STATE, (((cinfo->err)->msg_parm).i)[0] =
      cinfo->global_state, (* (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  if(cinfo->next_scanline >= cinfo->image_height)
  {
    (cinfo->err)->msg_code = JWRN_TOO_MUCH_DATA, (*
      (cinfo->err)->emit_message)((j_common_ptr )cinfo, - 1);
    return 0;
  }
  if(cinfo->progress != (void *  )0)
  {
    (cinfo->progress)->pass_counter = (long )cinfo->next_scanline;
    (cinfo->progress)->pass_limit = (long )cinfo->image_height;
    (* (cinfo->progress)->progress_monitor)((j_common_ptr )cinfo);
  }
  if((cinfo->master)->call_pass_startup)
    (* (cinfo->master)->pass_startup)(cinfo);
  lines_per_MCU_row = cinfo->max_v_samp_factor * 8;
  if(num_lines < lines_per_MCU_row)
    (cinfo->err)->msg_code = JERR_BUFFER_SIZE, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  mcu_ctr = 0;
  (* (cinfo->coef)->compress_data)(cinfo, data, & mcu_ctr);
  if(mcu_ctr != cinfo->MCUs_per_row)
    (cinfo->err)->msg_code = JERR_CANT_SUSPEND, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  cinfo->next_scanline += lines_per_MCU_row;
  return lines_per_MCU_row;
}

void jpeg_finish_compress(j_compress_ptr cinfo )
{
  JDIMENSION iMCU_row , mcu_ctr ; /*decdef*/
  if(cinfo->global_state != 101 && cinfo->global_state != 102)
    (cinfo->err)->msg_code = JERR_BAD_STATE, (((cinfo->err)->msg_parm).i)[0] =
      cinfo->global_state, (* (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  if(cinfo->next_scanline < cinfo->image_height)
    (cinfo->err)->msg_code = JERR_TOO_LITTLE_DATA, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  (* (cinfo->master)->finish_pass)(cinfo);
  while(! (cinfo->master)->is_last_pass)
  {
    (* (cinfo->master)->prepare_for_pass)(cinfo);
    for(iMCU_row = 0; iMCU_row < cinfo->total_iMCU_rows; iMCU_row++)
    {
      if(cinfo->progress != (void *  )0)
      {
	(cinfo->progress)->pass_counter = (long )iMCU_row;
	(cinfo->progress)->pass_limit = (long )cinfo->total_iMCU_rows;
	(* (cinfo->progress)->progress_monitor)((j_common_ptr )cinfo);
      }
      mcu_ctr = 0;
      (* (cinfo->coef)->compress_data)(cinfo, (JSAMPIMAGE )((void *  )0), &
	mcu_ctr);
      if(mcu_ctr != cinfo->MCUs_per_row)
	(cinfo->err)->msg_code = JERR_CANT_SUSPEND, (*
	  (cinfo->err)->error_exit)((j_common_ptr )cinfo);
    }
    (* (cinfo->master)->finish_pass)(cinfo);
  }
  (* (cinfo->marker)->write_file_trailer)(cinfo);
  (* (cinfo->dest)->term_destination)(cinfo);
  jpeg_abort((j_common_ptr )cinfo);
}

void jpeg_write_marker(j_compress_ptr cinfo , int marker , const JOCTET * 
  dataptr , unsigned int datalen )
{
  if(cinfo->next_scanline != 0 || cinfo->global_state != 101 &&
    cinfo->global_state != 102)
    (cinfo->err)->msg_code = JERR_BAD_STATE, (((cinfo->err)->msg_parm).i)[0] =
      cinfo->global_state, (* (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  (* (cinfo->marker)->write_any_marker)(cinfo, marker, dataptr, datalen);
}

void jpeg_write_tables(j_compress_ptr cinfo )
{
  if(cinfo->global_state != 100)
    (cinfo->err)->msg_code = JERR_BAD_STATE, (((cinfo->err)->msg_parm).i)[0] =
      cinfo->global_state, (* (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  (* (cinfo->err)->reset_error_mgr)((j_common_ptr )cinfo);
  (* (cinfo->dest)->init_destination)(cinfo);
  jinit_marker_writer(cinfo);
  (* (cinfo->marker)->write_tables_only)(cinfo);
  (* (cinfo->dest)->term_destination)(cinfo);
  jpeg_abort((j_common_ptr )cinfo);
}

void jpeg_abort_compress(j_compress_ptr cinfo )
{
  jpeg_abort((j_common_ptr )cinfo);
}


#pragma combiner("./jcparam.i", "-g -O -I/home/scott/wrk/safec/cil/lib ")

#pragma boxalloc("malloc", nozero, sizein(0))

#pragma boxalloc("alloca", nozero, sizein(0))

#pragma boxalloc("calloc", zero, sizemul(0, 1))

#pragma boxprintf("printf", 0)

#pragma boxprintf("fprintf", 1)

#pragma boxprintf("sprintf", 1)

#pragma boxprintf("snprintf", 2)

#pragma boxpoly("memcpy")

#pragma boxexported("main")
void jpeg_add_quant_table(j_compress_ptr cinfo , int which_tbl , const
  unsigned int *  basic_table , int scale_factor , boolean force_baseline )
{
  JQUANT_TBL *  *  qtblptr = & (cinfo->quant_tbl_ptrs)[which_tbl]; /*decdef*/
  int i ; /*decdef*/
  long temp ; /*decdef*/
  if(cinfo->global_state != 100)
    (cinfo->err)->msg_code = JERR_BAD_STATE, (((cinfo->err)->msg_parm).i)[0] =
      cinfo->global_state, (* (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  if(* qtblptr == (void *  )0)
    * qtblptr = jpeg_alloc_quant_table((j_common_ptr )cinfo);
  for(i = 0; i < 64; i++)
  {
    temp = ((long )basic_table[i] * scale_factor + 50L) / 100L;
    if(temp <= 0L)
      temp = 1L;
    if(temp > 32767L)
      temp = 32767L;
    if(force_baseline && temp > 255L)
      temp = 255L;
    ((* qtblptr)->quantval)[i] = (UINT16 )temp;
  }
  (* qtblptr)->sent_table = 0;
}

void jpeg_set_linear_quality(j_compress_ptr cinfo , int scale_factor , boolean
  force_baseline )
{
  static const unsigned int std_luminance_quant_tbl[64] = {16, 11, 12, 14, 12,
    10, 16, 14, 13, 14, 18, 17, 16, 19, 24, 40, 26, 24, 22, 22, 24, 49, 35, 37,
    29, 40, 58, 51, 61, 60, 57, 51, 56, 55, 64, 72, 92, 78, 64, 68, 87, 69, 55,
    56, 80, 109, 81, 87, 95, 98, 103, 104, 103, 62, 77, 113, 121, 112, 100, 120,
    92, 101, 103, 99}; /*decdef*/
  static const unsigned int std_chrominance_quant_tbl[64] = {17, 18, 18, 24, 21,
    24, 47, 26, 26, 47, 99, 66, 56, 66, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99,
    99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99,
    99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99,
    99, 99}; /*decdef*/
  jpeg_add_quant_table(cinfo, 0, std_luminance_quant_tbl, scale_factor,
    force_baseline);
  jpeg_add_quant_table(cinfo, 1, std_chrominance_quant_tbl, scale_factor,
    force_baseline);
}

int jpeg_quality_scaling(int quality )
{
  if(quality <= 0)
    quality = 1;
  if(quality > 100)
    quality = 100;
  if(quality < 50)
    quality = 5000 / quality;
  else
    quality = 200 - quality * 2;
  return quality;
}

void jpeg_set_quality(j_compress_ptr cinfo , int quality , boolean
  force_baseline )
{
  quality = jpeg_quality_scaling(quality);
  jpeg_set_linear_quality(cinfo, quality, force_baseline);
}

static void add_huff_table(j_compress_ptr cinfo , JHUFF_TBL *  *  htblptr ,
  const UINT8 *  bits , const UINT8 *  val )
{
  if(* htblptr == (void *  )0)
    * htblptr = jpeg_alloc_huff_table((j_common_ptr )cinfo);
  memcpy((void *  )(* htblptr)->bits, (const void *  )bits, (size_t )((size_t
    )sizeof((* htblptr)->bits)));
  memcpy((void *  )(* htblptr)->huffval, (const void *  )val, (size_t )((size_t
    )sizeof((* htblptr)->huffval)));
  (* htblptr)->sent_table = 0;
}

static void std_huff_tables(j_compress_ptr cinfo )
{
  static const UINT8 bits_dc_luminance[17] = {0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0,
    0, 0, 0, 0, 0, 0}; /*decdef*/
  static const UINT8 val_dc_luminance[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
    11}; /*decdef*/
  static const UINT8 bits_dc_chrominance[17] = {0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 0, 0, 0, 0, 0}; /*decdef*/
  static const UINT8 val_dc_chrominance[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
    11}; /*decdef*/
  static const UINT8 bits_ac_luminance[17] = {0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5,
    4, 4, 0, 0, 1, 0x7d}; /*decdef*/
  static const UINT8 val_ac_luminance[] = {0x01, 0x02, 0x03, 0x00, 0x04, 0x11,
    0x05, 0x12, 0x21, 0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07, 0x22, 0x71,
    0x14, 0x32, 0x81, 0x91, 0xa1, 0x08, 0x23, 0x42, 0xb1, 0xc1, 0x15, 0x52,
    0xd1, 0xf0, 0x24, 0x33, 0x62, 0x72, 0x82, 0x09, 0x0a, 0x16, 0x17, 0x18,
    0x19, 0x1a, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x34, 0x35, 0x36, 0x37,
    0x38, 0x39, 0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x53,
    0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x63, 0x64, 0x65, 0x66, 0x67,
    0x68, 0x69, 0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x83,
    0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x92, 0x93, 0x94, 0x95, 0x96,
    0x97, 0x98, 0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9,
    0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3,
    0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6,
    0xd7, 0xd8, 0xd9, 0xda, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8,
    0xe9, 0xea, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9,
    0xfa}; /*decdef*/
  static const UINT8 bits_ac_chrominance[17] = {0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5,
    4, 4, 0, 1, 2, 0x77}; /*decdef*/
  static const UINT8 val_ac_chrominance[] = {0x00, 0x01, 0x02, 0x03, 0x11, 0x04,
    0x05, 0x21, 0x31, 0x06, 0x12, 0x41, 0x51, 0x07, 0x61, 0x71, 0x13, 0x22,
    0x32, 0x81, 0x08, 0x14, 0x42, 0x91, 0xa1, 0xb1, 0xc1, 0x09, 0x23, 0x33,
    0x52, 0xf0, 0x15, 0x62, 0x72, 0xd1, 0x0a, 0x16, 0x24, 0x34, 0xe1, 0x25,
    0xf1, 0x17, 0x18, 0x19, 0x1a, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x35, 0x36,
    0x37, 0x38, 0x39, 0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a,
    0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x63, 0x64, 0x65, 0x66,
    0x67, 0x68, 0x69, 0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a,
    0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x92, 0x93, 0x94,
    0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,
    0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba,
    0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4,
    0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7,
    0xe8, 0xe9, 0xea, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9,
    0xfa}; /*decdef*/
  add_huff_table(cinfo, & (cinfo->dc_huff_tbl_ptrs)[0], bits_dc_luminance,
    val_dc_luminance);
  add_huff_table(cinfo, & (cinfo->ac_huff_tbl_ptrs)[0], bits_ac_luminance,
    val_ac_luminance);
  add_huff_table(cinfo, & (cinfo->dc_huff_tbl_ptrs)[1], bits_dc_chrominance,
    val_dc_chrominance);
  add_huff_table(cinfo, & (cinfo->ac_huff_tbl_ptrs)[1], bits_ac_chrominance,
    val_ac_chrominance);
}

void jpeg_set_defaults(j_compress_ptr cinfo )
{
  int i ; /*decdef*/
  if(cinfo->global_state != 100)
    (cinfo->err)->msg_code = JERR_BAD_STATE, (((cinfo->err)->msg_parm).i)[0] =
      cinfo->global_state, (* (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  if(cinfo->comp_info == (void *  )0)
    cinfo->comp_info = (jpeg_component_info *  )(*
      (cinfo->mem)->alloc_small)((j_common_ptr )cinfo, 0, 10 * (size_t
      )sizeof(jpeg_component_info ));
  cinfo->data_precision = 8;
  jpeg_set_quality(cinfo, 75, 1);
  std_huff_tables(cinfo);
  for(i = 0; i < 16; i++)
  {
    (cinfo->arith_dc_L)[i] = 0;
    (cinfo->arith_dc_U)[i] = 1;
    (cinfo->arith_ac_K)[i] = 5;
  }
  cinfo->raw_data_in = 0;
  cinfo->arith_code = 0;
  cinfo->interleave = 1;
  cinfo->optimize_coding = 0;
  if(cinfo->data_precision > 8)
    cinfo->optimize_coding = 1;
  cinfo->CCIR601_sampling = 0;
  cinfo->smoothing_factor = 0;
  cinfo->dct_method = JDCT_ISLOW;
  cinfo->restart_interval = 0;
  cinfo->restart_in_rows = 0;
  cinfo->density_unit = 0;
  cinfo->X_density = 1;
  cinfo->Y_density = 1;
  jpeg_default_colorspace(cinfo);
}

void jpeg_default_colorspace(j_compress_ptr cinfo )
{
  switch(cinfo->in_color_space)
  {
  case JCS_GRAYSCALE:
      ;
    jpeg_set_colorspace(cinfo, JCS_GRAYSCALE);
    break;
  case JCS_RGB:
      ;
    jpeg_set_colorspace(cinfo, JCS_YCbCr);
    break;
  case JCS_YCbCr:
      ;
    jpeg_set_colorspace(cinfo, JCS_YCbCr);
    break;
  case JCS_CMYK:
      ;
    jpeg_set_colorspace(cinfo, JCS_CMYK);
    break;
  case JCS_YCCK:
      ;
    jpeg_set_colorspace(cinfo, JCS_YCCK);
    break;
  case JCS_UNKNOWN:
      ;
    jpeg_set_colorspace(cinfo, JCS_UNKNOWN);
    break;
  default :
      ;
    (cinfo->err)->msg_code = JERR_BAD_IN_COLORSPACE, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  }
}

void jpeg_set_colorspace(j_compress_ptr cinfo , J_COLOR_SPACE colorspace )
{
  jpeg_component_info *  compptr ; /*decdef*/
  int ci ; /*decdef*/
  if(cinfo->global_state != 100)
    (cinfo->err)->msg_code = JERR_BAD_STATE, (((cinfo->err)->msg_parm).i)[0] =
      cinfo->global_state, (* (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  cinfo->jpeg_color_space = colorspace;
  cinfo->write_JFIF_header = 0;
  cinfo->write_Adobe_marker = 0;
  switch(colorspace)
  {
  case JCS_GRAYSCALE:
      ;
    cinfo->write_JFIF_header = 1;
    cinfo->num_components = 1;
    compptr = & (cinfo->comp_info)[0], compptr->component_index = 0,
      compptr->component_id = 1, compptr->h_samp_factor = 1,
      compptr->v_samp_factor = 1, compptr->quant_tbl_no = 0, compptr->dc_tbl_no
      = 0, compptr->ac_tbl_no = 0;
    break;
  case JCS_RGB:
      ;
    cinfo->write_Adobe_marker = 1;
    cinfo->num_components = 3;
    compptr = & (cinfo->comp_info)[0], compptr->component_index = 0,
      compptr->component_id = 'R', compptr->h_samp_factor = 1,
      compptr->v_samp_factor = 1, compptr->quant_tbl_no = 0, compptr->dc_tbl_no
      = 0, compptr->ac_tbl_no = 0;
    compptr = & (cinfo->comp_info)[1], compptr->component_index = 1,
      compptr->component_id = 'G', compptr->h_samp_factor = 1,
      compptr->v_samp_factor = 1, compptr->quant_tbl_no = 0, compptr->dc_tbl_no
      = 0, compptr->ac_tbl_no = 0;
    compptr = & (cinfo->comp_info)[2], compptr->component_index = 2,
      compptr->component_id = 'B', compptr->h_samp_factor = 1,
      compptr->v_samp_factor = 1, compptr->quant_tbl_no = 0, compptr->dc_tbl_no
      = 0, compptr->ac_tbl_no = 0;
    break;
  case JCS_YCbCr:
      ;
    cinfo->write_JFIF_header = 1;
    cinfo->num_components = 3;
    compptr = & (cinfo->comp_info)[0], compptr->component_index = 0,
      compptr->component_id = 1, compptr->h_samp_factor = 2,
      compptr->v_samp_factor = 2, compptr->quant_tbl_no = 0, compptr->dc_tbl_no
      = 0, compptr->ac_tbl_no = 0;
    compptr = & (cinfo->comp_info)[1], compptr->component_index = 1,
      compptr->component_id = 2, compptr->h_samp_factor = 1,
      compptr->v_samp_factor = 1, compptr->quant_tbl_no = 1, compptr->dc_tbl_no
      = 1, compptr->ac_tbl_no = 1;
    compptr = & (cinfo->comp_info)[2], compptr->component_index = 2,
      compptr->component_id = 3, compptr->h_samp_factor = 1,
      compptr->v_samp_factor = 1, compptr->quant_tbl_no = 1, compptr->dc_tbl_no
      = 1, compptr->ac_tbl_no = 1;
    break;
  case JCS_CMYK:
      ;
    cinfo->write_Adobe_marker = 1;
    cinfo->num_components = 4;
    compptr = & (cinfo->comp_info)[0], compptr->component_index = 0,
      compptr->component_id = 'C', compptr->h_samp_factor = 1,
      compptr->v_samp_factor = 1, compptr->quant_tbl_no = 0, compptr->dc_tbl_no
      = 0, compptr->ac_tbl_no = 0;
    compptr = & (cinfo->comp_info)[1], compptr->component_index = 1,
      compptr->component_id = 'M', compptr->h_samp_factor = 1,
      compptr->v_samp_factor = 1, compptr->quant_tbl_no = 0, compptr->dc_tbl_no
      = 0, compptr->ac_tbl_no = 0;
    compptr = & (cinfo->comp_info)[2], compptr->component_index = 2,
      compptr->component_id = 'Y', compptr->h_samp_factor = 1,
      compptr->v_samp_factor = 1, compptr->quant_tbl_no = 0, compptr->dc_tbl_no
      = 0, compptr->ac_tbl_no = 0;
    compptr = & (cinfo->comp_info)[3], compptr->component_index = 3,
      compptr->component_id = 'K', compptr->h_samp_factor = 1,
      compptr->v_samp_factor = 1, compptr->quant_tbl_no = 0, compptr->dc_tbl_no
      = 0, compptr->ac_tbl_no = 0;
    break;
  case JCS_YCCK:
      ;
    cinfo->write_Adobe_marker = 1;
    cinfo->num_components = 4;
    compptr = & (cinfo->comp_info)[0], compptr->component_index = 0,
      compptr->component_id = 1, compptr->h_samp_factor = 2,
      compptr->v_samp_factor = 2, compptr->quant_tbl_no = 0, compptr->dc_tbl_no
      = 0, compptr->ac_tbl_no = 0;
    compptr = & (cinfo->comp_info)[1], compptr->component_index = 1,
      compptr->component_id = 2, compptr->h_samp_factor = 1,
      compptr->v_samp_factor = 1, compptr->quant_tbl_no = 1, compptr->dc_tbl_no
      = 1, compptr->ac_tbl_no = 1;
    compptr = & (cinfo->comp_info)[2], compptr->component_index = 2,
      compptr->component_id = 3, compptr->h_samp_factor = 1,
      compptr->v_samp_factor = 1, compptr->quant_tbl_no = 1, compptr->dc_tbl_no
      = 1, compptr->ac_tbl_no = 1;
    compptr = & (cinfo->comp_info)[3], compptr->component_index = 3,
      compptr->component_id = 4, compptr->h_samp_factor = 2,
      compptr->v_samp_factor = 2, compptr->quant_tbl_no = 0, compptr->dc_tbl_no
      = 0, compptr->ac_tbl_no = 0;
    break;
  case JCS_UNKNOWN:
      ;
    cinfo->num_components = cinfo->input_components;
    if(cinfo->num_components < 1 || cinfo->num_components > 10)
      (cinfo->err)->msg_code = JERR_COMPONENT_COUNT,
	(((cinfo->err)->msg_parm).i)[0] = cinfo->num_components,
	(((cinfo->err)->msg_parm).i)[1] = 10, (*
	(cinfo->err)->error_exit)((j_common_ptr )cinfo);
    for(ci = 0; ci < cinfo->num_components; ci++)
    {
      compptr = & (cinfo->comp_info)[ci], compptr->component_index = ci,
	compptr->component_id = ci, compptr->h_samp_factor = 1,
	compptr->v_samp_factor = 1, compptr->quant_tbl_no = 0,
	compptr->dc_tbl_no = 0, compptr->ac_tbl_no = 0;
    }
    break;
  default :
      ;
    (cinfo->err)->msg_code = JERR_BAD_J_COLORSPACE, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  }
}


#pragma combiner("./jdatadst.i", "-g -O -I/home/scott/wrk/safec/cil/lib ")

#pragma boxalloc("malloc", nozero, sizein(0))

#pragma boxalloc("alloca", nozero, sizein(0))

#pragma boxalloc("calloc", zero, sizemul(0, 1))

#pragma boxprintf("printf", 0)

#pragma boxprintf("fprintf", 1)

#pragma boxprintf("sprintf", 1)

#pragma boxprintf("snprintf", 2)

#pragma boxpoly("memcpy")

#pragma boxexported("main")
typedef struct  {
  struct jpeg_destination_mgr pub ;
  FILE *  outfile ;
  JOCTET *  buffer ;
} my_destination_mgr ; /*typedef*/

typedef my_destination_mgr *  my_dest_ptr ; /*typedef*/

static void init_destination(j_compress_ptr cinfo )
{
  my_dest_ptr dest = (my_dest_ptr )cinfo->dest; /*decdef*/
  dest->buffer = (JOCTET *  )(* (cinfo->mem)->alloc_small)((j_common_ptr )cinfo,
    1, 4096 * (size_t )sizeof(JOCTET ));
  (dest->pub).next_output_byte = dest->buffer;
  (dest->pub).free_in_buffer = 4096;
}

static boolean empty_output_buffer(j_compress_ptr cinfo )
{
  my_dest_ptr dest = (my_dest_ptr )cinfo->dest; /*decdef*/
  if((size_t )fwrite((const void *  )dest->buffer, (size_t )1, (size_t )4096,
    dest->outfile) != (size_t )4096)
    (cinfo->err)->msg_code = JERR_FILE_WRITE, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  (dest->pub).next_output_byte = dest->buffer;
  (dest->pub).free_in_buffer = 4096;
  return 1;
}

static void term_destination(j_compress_ptr cinfo )
{
  my_dest_ptr dest = (my_dest_ptr )cinfo->dest; /*decdef*/
  size_t datacount = 4096 - (dest->pub).free_in_buffer; /*decdef*/
  if(datacount > 0)
  {
    if((size_t )fwrite((const void *  )dest->buffer, (size_t )1, (size_t
      )datacount, dest->outfile) != datacount)
      (cinfo->err)->msg_code = JERR_FILE_WRITE, (*
	(cinfo->err)->error_exit)((j_common_ptr )cinfo);
  }
  fflush(dest->outfile);
  if(ferror(dest->outfile))
    (cinfo->err)->msg_code = JERR_FILE_WRITE, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
}

void jpeg_stdio_dest(j_compress_ptr cinfo , FILE *  outfile )
{
  my_dest_ptr dest ; /*decdef*/
  if(cinfo->dest == (void *  )0)
  {
    cinfo->dest = (struct jpeg_destination_mgr *  )(*
      (cinfo->mem)->alloc_small)((j_common_ptr )cinfo, 0, (size_t
      )sizeof(my_destination_mgr ));
  }
  dest = (my_dest_ptr )cinfo->dest;
  (dest->pub).init_destination = init_destination;
  (dest->pub).empty_output_buffer = empty_output_buffer;
  (dest->pub).term_destination = term_destination;
  dest->outfile = outfile;
}


#pragma combiner("./jcmaster.i", "-g -O -I/home/scott/wrk/safec/cil/lib ")

#pragma boxalloc("malloc", nozero, sizein(0))

#pragma boxalloc("alloca", nozero, sizein(0))

#pragma boxalloc("calloc", zero, sizemul(0, 1))

#pragma boxprintf("printf", 0)

#pragma boxprintf("fprintf", 1)

#pragma boxprintf("sprintf", 1)

#pragma boxprintf("snprintf", 2)

#pragma boxpoly("memcpy")

#pragma boxexported("main")
typedef struct  {
  struct jpeg_comp_master pub ;
  int pass_number ;
} my_comp_master ; /*typedef*/

typedef my_comp_master *  my_master_ptr ; /*typedef*/

static void initial_setup(j_compress_ptr cinfo )
{
  int ci ; /*decdef*/
  jpeg_component_info *  compptr ; /*decdef*/
  long samplesperrow ; /*decdef*/
  JDIMENSION jd_samplesperrow ; /*decdef*/
  if(cinfo->image_height <= 0 || cinfo->image_width <= 0 ||
    cinfo->num_components <= 0 || cinfo->input_components <= 0)
    (cinfo->err)->msg_code = JERR_EMPTY_IMAGE, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  if((long )cinfo->image_height > (long )65500L || (long )cinfo->image_width >
    (long )65500L)
    (cinfo->err)->msg_code = JERR_IMAGE_TOO_BIG, (((cinfo->err)->msg_parm).i)[0]
      = (unsigned int )65500L, (* (cinfo->err)->error_exit)((j_common_ptr
      )cinfo);
  samplesperrow = (long )cinfo->image_width * (long )cinfo->input_components;
  jd_samplesperrow = (JDIMENSION )samplesperrow;
  if((long )jd_samplesperrow != samplesperrow)
    (cinfo->err)->msg_code = JERR_WIDTH_OVERFLOW, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  if(cinfo->data_precision != 8)
    (cinfo->err)->msg_code = JERR_BAD_PRECISION, (((cinfo->err)->msg_parm).i)[0]
      = cinfo->data_precision, (* (cinfo->err)->error_exit)((j_common_ptr
      )cinfo);
  if(cinfo->num_components > 10)
    (cinfo->err)->msg_code = JERR_COMPONENT_COUNT,
      (((cinfo->err)->msg_parm).i)[0] = cinfo->num_components,
      (((cinfo->err)->msg_parm).i)[1] = 10, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  cinfo->max_h_samp_factor = 1;
  cinfo->max_v_samp_factor = 1;
  for(ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components; ci++,
    compptr++)
  {
    if(compptr->h_samp_factor <= 0 || compptr->h_samp_factor > 4 ||
      compptr->v_samp_factor <= 0 || compptr->v_samp_factor > 4)
      (cinfo->err)->msg_code = JERR_BAD_SAMPLING, (*
	(cinfo->err)->error_exit)((j_common_ptr )cinfo);
    cinfo->max_h_samp_factor = cinfo->max_h_samp_factor > compptr->h_samp_factor
      ? cinfo->max_h_samp_factor : compptr->h_samp_factor;
    cinfo->max_v_samp_factor = cinfo->max_v_samp_factor > compptr->v_samp_factor
      ? cinfo->max_v_samp_factor : compptr->v_samp_factor;
  }
  for(ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components; ci++,
    compptr++)
  {
    compptr->DCT_scaled_size = 8;
    compptr->width_in_blocks = (JDIMENSION
      )jdiv_round_up((long )cinfo->image_width * (long )compptr->h_samp_factor,
      (long )(cinfo->max_h_samp_factor * 8));
    compptr->height_in_blocks = (JDIMENSION
      )jdiv_round_up((long )cinfo->image_height * (long )compptr->v_samp_factor,
      (long )(cinfo->max_v_samp_factor * 8));
    compptr->downsampled_width = (JDIMENSION
      )jdiv_round_up((long )cinfo->image_width * (long )compptr->h_samp_factor,
      (long )cinfo->max_h_samp_factor);
    compptr->downsampled_height = (JDIMENSION
      )jdiv_round_up((long )cinfo->image_height * (long )compptr->v_samp_factor,
      (long )cinfo->max_v_samp_factor);
    compptr->component_needed = 1;
  }
  cinfo->total_iMCU_rows = (JDIMENSION
    )jdiv_round_up((long )cinfo->image_height, (long )(cinfo->max_v_samp_factor
    * 8));
}

static void per_scan_setup(j_compress_ptr cinfo )
{
  int ci , mcublks , tmp ; /*decdef*/
  jpeg_component_info *  compptr ; /*decdef*/
  if(cinfo->comps_in_scan == 1)
  {
    compptr = (cinfo->cur_comp_info)[0];
    cinfo->MCUs_per_row = compptr->width_in_blocks;
    cinfo->MCU_rows_in_scan = compptr->height_in_blocks;
    compptr->MCU_width = 1;
    compptr->MCU_height = 1;
    compptr->MCU_blocks = 1;
    compptr->MCU_sample_width = 8;
    compptr->last_col_width = 1;
    compptr->last_row_height = 1;
    cinfo->blocks_in_MCU = 1;
    (cinfo->MCU_membership)[0] = 0;
  }
  else
  {
    if(cinfo->comps_in_scan <= 0 || cinfo->comps_in_scan > 4)
      (cinfo->err)->msg_code = JERR_COMPONENT_COUNT,
	(((cinfo->err)->msg_parm).i)[0] = cinfo->comps_in_scan,
	(((cinfo->err)->msg_parm).i)[1] = 4, (*
	(cinfo->err)->error_exit)((j_common_ptr )cinfo);
    cinfo->MCUs_per_row = (JDIMENSION )jdiv_round_up((long )cinfo->image_width,
      (long )(cinfo->max_h_samp_factor * 8));
    cinfo->MCU_rows_in_scan = (JDIMENSION
      )jdiv_round_up((long )cinfo->image_height,
      (long )(cinfo->max_v_samp_factor * 8));
    cinfo->blocks_in_MCU = 0;
    for(ci = 0; ci < cinfo->comps_in_scan; ci++)
    {
      compptr = (cinfo->cur_comp_info)[ci];
      compptr->MCU_width = compptr->h_samp_factor;
      compptr->MCU_height = compptr->v_samp_factor;
      compptr->MCU_blocks = compptr->MCU_width * compptr->MCU_height;
      compptr->MCU_sample_width = compptr->MCU_width * 8;
      tmp = (int )(compptr->width_in_blocks % compptr->MCU_width);
      if(tmp == 0)
	tmp = compptr->MCU_width;
      compptr->last_col_width = tmp;
      tmp = (int )(compptr->height_in_blocks % compptr->MCU_height);
      if(tmp == 0)
	tmp = compptr->MCU_height;
      compptr->last_row_height = tmp;
      mcublks = compptr->MCU_blocks;
      if(cinfo->blocks_in_MCU + mcublks > 10)
	(cinfo->err)->msg_code = JERR_BAD_MCU_SIZE, (*
	  (cinfo->err)->error_exit)((j_common_ptr )cinfo);
      while(mcublks-- > 0)
      {
	(cinfo->MCU_membership)[cinfo->blocks_in_MCU++] = ci;
      }
    }
  }
  if(cinfo->restart_in_rows > 0)
  {
    long nominal = (long )cinfo->restart_in_rows *
      (long )cinfo->MCUs_per_row; /*decdef*/
    cinfo->restart_interval = (unsigned int )(nominal < 65535L ? nominal
      : 65535L);
  }
}

static void master_selection(j_compress_ptr cinfo )
{
  my_master_ptr master = (my_master_ptr )cinfo->master; /*decdef*/
  initial_setup(cinfo);
  master->pass_number = 0;
  if(! cinfo->raw_data_in)
  {
    jinit_color_converter(cinfo);
    jinit_downsampler(cinfo);
    jinit_c_prep_controller(cinfo, 0);
  }
  jinit_forward_dct(cinfo);
  if(cinfo->arith_code)
  {
    (cinfo->err)->msg_code = JERR_ARITH_NOTIMPL, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  }
  else
    jinit_huff_encoder(cinfo);
  jinit_c_coef_controller(cinfo, cinfo->optimize_coding);
  jinit_c_main_controller(cinfo, 0);
  jinit_marker_writer(cinfo);
  (* (cinfo->mem)->realize_virt_arrays)((j_common_ptr )cinfo);
  (* (cinfo->marker)->write_file_header)(cinfo);
}

static void prepare_for_pass(j_compress_ptr cinfo )
{
  my_master_ptr master = (my_master_ptr )cinfo->master; /*decdef*/
  int ci ; /*decdef*/
  int npasses ; /*decdef*/
  if(cinfo->num_components > 4)
    (cinfo->err)->msg_code = JERR_COMPONENT_COUNT,
      (((cinfo->err)->msg_parm).i)[0] = cinfo->num_components,
      (((cinfo->err)->msg_parm).i)[1] = 4, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  cinfo->comps_in_scan = cinfo->num_components;
  for(ci = 0; ci < cinfo->num_components; ci++)
  {
    (cinfo->cur_comp_info)[ci] = & (cinfo->comp_info)[ci];
  }
  per_scan_setup(cinfo);
  if(! cinfo->optimize_coding)
  {
    npasses = 1;
    (master->pub).call_pass_startup = 1;
    (master->pub).is_last_pass = 1;
    if(! cinfo->raw_data_in)
    {
      (* (cinfo->cconvert)->start_pass)(cinfo);
      (* (cinfo->downsample)->start_pass)(cinfo);
      (* (cinfo->prep)->start_pass)(cinfo, JBUF_PASS_THRU);
    }
    (* (cinfo->fdct)->start_pass)(cinfo);
    (* (cinfo->entropy)->start_pass)(cinfo, 0);
    (* (cinfo->coef)->start_pass)(cinfo, JBUF_PASS_THRU);
    (* (cinfo->main)->start_pass)(cinfo, JBUF_PASS_THRU);
  }
  else
  {
    npasses = 2;
    switch(master->pass_number)
    {
    case 0:
	;
      (master->pub).call_pass_startup = 0;
      (master->pub).is_last_pass = 0;
      if(! cinfo->raw_data_in)
      {
	(* (cinfo->cconvert)->start_pass)(cinfo);
	(* (cinfo->downsample)->start_pass)(cinfo);
	(* (cinfo->prep)->start_pass)(cinfo, JBUF_PASS_THRU);
      }
      (* (cinfo->fdct)->start_pass)(cinfo);
      (* (cinfo->entropy)->start_pass)(cinfo, 1);
      (* (cinfo->coef)->start_pass)(cinfo, JBUF_SAVE_AND_PASS);
      (* (cinfo->main)->start_pass)(cinfo, JBUF_PASS_THRU);
      break;
    case 1:
	;
      (master->pub).is_last_pass = 1;
      (* (cinfo->entropy)->start_pass)(cinfo, 0);
      (* (cinfo->coef)->start_pass)(cinfo, JBUF_CRANK_DEST);
      (* (cinfo->marker)->write_frame_header)(cinfo);
      (* (cinfo->marker)->write_scan_header)(cinfo);
      break;
    }
  }
  if(cinfo->progress != (void *  )0)
  {
    (cinfo->progress)->completed_passes = master->pass_number;
    (cinfo->progress)->total_passes = npasses;
  }
  master->pass_number++;
}

static void pass_startup(j_compress_ptr cinfo )
{
  (cinfo->master)->call_pass_startup = 0;
  (* (cinfo->marker)->write_frame_header)(cinfo);
  (* (cinfo->marker)->write_scan_header)(cinfo);
}

static void finish_pass_master(j_compress_ptr cinfo )
{
  (* (cinfo->entropy)->finish_pass)(cinfo);
}

void jinit_master_compress(j_compress_ptr cinfo )
{
  my_master_ptr master ; /*decdef*/
  master = (my_master_ptr )(* (cinfo->mem)->alloc_small)((j_common_ptr )cinfo,
    1, (size_t )sizeof(my_comp_master ));
  cinfo->master = (struct jpeg_comp_master *  )master;
  (master->pub).prepare_for_pass = prepare_for_pass;
  (master->pub).pass_startup = pass_startup;
  (master->pub).finish_pass = finish_pass_master;
  master_selection(cinfo);
}


#pragma combiner("./jcmarker.i", "-g -O -I/home/scott/wrk/safec/cil/lib ")

#pragma boxalloc("malloc", nozero, sizein(0))

#pragma boxalloc("alloca", nozero, sizein(0))

#pragma boxalloc("calloc", zero, sizemul(0, 1))

#pragma boxprintf("printf", 0)

#pragma boxprintf("fprintf", 1)

#pragma boxprintf("sprintf", 1)

#pragma boxprintf("snprintf", 2)

#pragma boxpoly("memcpy")

#pragma boxexported("main")
typedef enum  {
  M_SOF0 = 0xc0,
  M_SOF1 = 0xc1,
  M_SOF2 = 0xc2,
  M_SOF3 = 0xc3,
  M_SOF5 = 0xc5,
  M_SOF6 = 0xc6,
  M_SOF7 = 0xc7,
  M_JPG = 0xc8,
  M_SOF9 = 0xc9,
  M_SOF10 = 0xca,
  M_SOF11 = 0xcb,
  M_SOF13 = 0xcd,
  M_SOF14 = 0xce,
  M_SOF15 = 0xcf,
  M_DHT = 0xc4,
  M_DAC = 0xcc,
  M_RST0 = 0xd0,
  M_RST1 = 0xd1,
  M_RST2 = 0xd2,
  M_RST3 = 0xd3,
  M_RST4 = 0xd4,
  M_RST5 = 0xd5,
  M_RST6 = 0xd6,
  M_RST7 = 0xd7,
  M_SOI = 0xd8,
  M_EOI = 0xd9,
  M_SOS = 0xda,
  M_DQT = 0xdb,
  M_DNL = 0xdc,
  M_DRI = 0xdd,
  M_DHP = 0xde,
  M_EXP = 0xdf,
  M_APP0 = 0xe0,
  M_APP1 = 0xe1,
  M_APP2 = 0xe2,
  M_APP3 = 0xe3,
  M_APP4 = 0xe4,
  M_APP5 = 0xe5,
  M_APP6 = 0xe6,
  M_APP7 = 0xe7,
  M_APP8 = 0xe8,
  M_APP9 = 0xe9,
  M_APP10 = 0xea,
  M_APP11 = 0xeb,
  M_APP12 = 0xec,
  M_APP13 = 0xed,
  M_APP14 = 0xee,
  M_APP15 = 0xef,
  M_JPG0 = 0xf0,
  M_JPG13 = 0xfd,
  M_COM = 0xfe,
  M_TEM = 0x01,
  M_ERROR = 0x100
} JPEG_MARKER ; /*typedef*/

static void emit_byte(j_compress_ptr cinfo , int val )
{
  struct jpeg_destination_mgr *  dest = cinfo->dest; /*decdef*/
  * dest->next_output_byte++ = (JOCTET )val;
  if(-- dest->free_in_buffer == 0)
  {
    if(! (* dest->empty_output_buffer)(cinfo))
      (cinfo->err)->msg_code = JERR_CANT_SUSPEND, (*
	(cinfo->err)->error_exit)((j_common_ptr )cinfo);
  }
}

static void emit_marker(j_compress_ptr cinfo , JPEG_MARKER mark )
{
  emit_byte(cinfo, 0xFF);
  emit_byte(cinfo, (int )mark);
}

static void emit_2bytes(j_compress_ptr cinfo , int value )
{
  emit_byte(cinfo, value >> 8 & 0xFF);
  emit_byte(cinfo, value & 0xFF);
}

static int emit_dqt(j_compress_ptr cinfo , int index )
{
  JQUANT_TBL *  qtbl = (cinfo->quant_tbl_ptrs)[index]; /*decdef*/
  int prec ; /*decdef*/
  int i ; /*decdef*/
  if(qtbl == (void *  )0)
    (cinfo->err)->msg_code = JERR_NO_QUANT_TABLE,
      (((cinfo->err)->msg_parm).i)[0] = index, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  prec = 0;
  for(i = 0; i < 64; i++)
  {
    if((qtbl->quantval)[i] > 255)
      prec = 1;
  }
  if(! qtbl->sent_table)
  {
    emit_marker(cinfo, M_DQT);
    emit_2bytes(cinfo, prec ? 64 * 2 + 1 + 2 : 64 + 1 + 2);
    emit_byte(cinfo, index + (prec << 4));
    for(i = 0; i < 64; i++)
    {
      if(prec)
	emit_byte(cinfo, (qtbl->quantval)[i] >> 8);
      emit_byte(cinfo, (qtbl->quantval)[i] & 0xFF);
    }
    qtbl->sent_table = 1;
  }
  return prec;
}

static void emit_dht(j_compress_ptr cinfo , int index , boolean is_ac )
{
  JHUFF_TBL *  htbl ; /*decdef*/
  int length , i ; /*decdef*/
  if(is_ac)
  {
    htbl = (cinfo->ac_huff_tbl_ptrs)[index];
    index += 0x10;
  }
  else
  {
    htbl = (cinfo->dc_huff_tbl_ptrs)[index];
  }
  if(htbl == (void *  )0)
    (cinfo->err)->msg_code = JERR_NO_HUFF_TABLE, (((cinfo->err)->msg_parm).i)[0]
      = index, (* (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  if(! htbl->sent_table)
  {
    emit_marker(cinfo, M_DHT);
    length = 0;
    for(i = 1; i <= 16; i++)
      length += (htbl->bits)[i];
    emit_2bytes(cinfo, length + 2 + 1 + 16);
    emit_byte(cinfo, index);
    for(i = 1; i <= 16; i++)
      emit_byte(cinfo, (htbl->bits)[i]);
    for(i = 0; i < length; i++)
      emit_byte(cinfo, (htbl->huffval)[i]);
    htbl->sent_table = 1;
  }
}

static void emit_dac(j_compress_ptr cinfo )
{
}

static void emit_dri(j_compress_ptr cinfo )
{
  emit_marker(cinfo, M_DRI);
  emit_2bytes(cinfo, 4);
  emit_2bytes(cinfo, (int )cinfo->restart_interval);
}

static void emit_sof(j_compress_ptr cinfo , JPEG_MARKER code )
{
  int ci ; /*decdef*/
  jpeg_component_info *  compptr ; /*decdef*/
  emit_marker(cinfo, code);
  emit_2bytes(cinfo, 3 * cinfo->num_components + 2 + 5 + 1);
  if((long )cinfo->image_height > 65535L || (long )cinfo->image_width > 65535L)
    (cinfo->err)->msg_code = JERR_IMAGE_TOO_BIG, (((cinfo->err)->msg_parm).i)[0]
      = (unsigned int )65535, (* (cinfo->err)->error_exit)((j_common_ptr
      )cinfo);
  emit_byte(cinfo, cinfo->data_precision);
  emit_2bytes(cinfo, (int )cinfo->image_height);
  emit_2bytes(cinfo, (int )cinfo->image_width);
  emit_byte(cinfo, cinfo->num_components);
  for(ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components; ci++,
    compptr++)
  {
    emit_byte(cinfo, compptr->component_id);
    emit_byte(cinfo, (compptr->h_samp_factor << 4) + compptr->v_samp_factor);
    emit_byte(cinfo, compptr->quant_tbl_no);
  }
}

static void emit_sos(j_compress_ptr cinfo )
{
  int i ; /*decdef*/
  jpeg_component_info *  compptr ; /*decdef*/
  emit_marker(cinfo, M_SOS);
  emit_2bytes(cinfo, 2 * cinfo->comps_in_scan + 2 + 1 + 3);
  emit_byte(cinfo, cinfo->comps_in_scan);
  for(i = 0; i < cinfo->comps_in_scan; i++)
  {
    compptr = (cinfo->cur_comp_info)[i];
    emit_byte(cinfo, compptr->component_id);
    emit_byte(cinfo, (compptr->dc_tbl_no << 4) + compptr->ac_tbl_no);
  }
  emit_byte(cinfo, 0);
  emit_byte(cinfo, 64 - 1);
  emit_byte(cinfo, 0);
}

static void emit_jfif_app0(j_compress_ptr cinfo )
{
  emit_marker(cinfo, M_APP0);
  emit_2bytes(cinfo, 2 + 4 + 1 + 2 + 1 + 2 + 2 + 1 + 1);
  emit_byte(cinfo, 0x4A);
  emit_byte(cinfo, 0x46);
  emit_byte(cinfo, 0x49);
  emit_byte(cinfo, 0x46);
  emit_byte(cinfo, 0);
  emit_byte(cinfo, 1);
  emit_byte(cinfo, 1);
  emit_byte(cinfo, cinfo->density_unit);
  emit_2bytes(cinfo, (int )cinfo->X_density);
  emit_2bytes(cinfo, (int )cinfo->Y_density);
  emit_byte(cinfo, 0);
  emit_byte(cinfo, 0);
}

static void emit_adobe_app14(j_compress_ptr cinfo )
{
  emit_marker(cinfo, M_APP14);
  emit_2bytes(cinfo, 2 + 5 + 2 + 2 + 2 + 1);
  emit_byte(cinfo, 0x41);
  emit_byte(cinfo, 0x64);
  emit_byte(cinfo, 0x6F);
  emit_byte(cinfo, 0x62);
  emit_byte(cinfo, 0x65);
  emit_2bytes(cinfo, 100);
  emit_2bytes(cinfo, 0);
  emit_2bytes(cinfo, 0);
  switch(cinfo->jpeg_color_space)
  {
  case JCS_YCbCr:
      ;
    emit_byte(cinfo, 1);
    break;
  case JCS_YCCK:
      ;
    emit_byte(cinfo, 2);
    break;
  default :
      ;
    emit_byte(cinfo, 0);
    break;
  }
}

static void write_any_marker(j_compress_ptr cinfo , int marker , const JOCTET * 
  dataptr , unsigned int datalen )
{
  if(datalen <= (unsigned int )65533)
  {
    emit_marker(cinfo, (JPEG_MARKER )marker);
    emit_2bytes(cinfo, (int )(datalen + 2));
    while(datalen--)
    {
      emit_byte(cinfo, * dataptr);
      dataptr++;
    }
  }
}

static void write_file_header(j_compress_ptr cinfo )
{
  emit_marker(cinfo, M_SOI);
  if(cinfo->write_JFIF_header)
    emit_jfif_app0(cinfo);
  if(cinfo->write_Adobe_marker)
    emit_adobe_app14(cinfo);
}

static void write_frame_header(j_compress_ptr cinfo )
{
  int ci , prec ; /*decdef*/
  boolean is_baseline ; /*decdef*/
  jpeg_component_info *  compptr ; /*decdef*/
  prec = 0;
  for(ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components; ci++,
    compptr++)
  {
    prec += emit_dqt(cinfo, compptr->quant_tbl_no);
  }
  is_baseline = 1;
  if(cinfo->arith_code || cinfo->data_precision != 8)
    is_baseline = 0;
  for(ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components; ci++,
    compptr++)
  {
    if(compptr->dc_tbl_no > 1 || compptr->ac_tbl_no > 1)
      is_baseline = 0;
  }
  if(prec && is_baseline)
  {
    is_baseline = 0;
    (cinfo->err)->msg_code = JTRC_16BIT_TABLES, (*
      (cinfo->err)->emit_message)((j_common_ptr )cinfo, 0);
  }
  if(cinfo->arith_code)
    emit_sof(cinfo, M_SOF9);
  else
  {
    if(is_baseline)
      emit_sof(cinfo, M_SOF0);
    else
      emit_sof(cinfo, M_SOF1);
  }
}

static void write_scan_header(j_compress_ptr cinfo )
{
  int i ; /*decdef*/
  jpeg_component_info *  compptr ; /*decdef*/
  if(cinfo->arith_code)
  {
    emit_dac(cinfo);
  }
  else
  {
    for(i = 0; i < cinfo->comps_in_scan; i++)
    {
      compptr = (cinfo->cur_comp_info)[i];
      emit_dht(cinfo, compptr->dc_tbl_no, 0);
      emit_dht(cinfo, compptr->ac_tbl_no, 1);
    }
  }
  if(cinfo->restart_interval)
    emit_dri(cinfo);
  emit_sos(cinfo);
}

static void write_file_trailer(j_compress_ptr cinfo )
{
  emit_marker(cinfo, M_EOI);
}

static void write_tables_only(j_compress_ptr cinfo )
{
  int i ; /*decdef*/
  emit_marker(cinfo, M_SOI);
  for(i = 0; i < 4; i++)
  {
    if((cinfo->quant_tbl_ptrs)[i] != (void *  )0)
      (void )emit_dqt(cinfo, i);
  }
  if(! cinfo->arith_code)
  {
    for(i = 0; i < 4; i++)
    {
      if((cinfo->dc_huff_tbl_ptrs)[i] != (void *  )0)
	emit_dht(cinfo, i, 0);
      if((cinfo->ac_huff_tbl_ptrs)[i] != (void *  )0)
	emit_dht(cinfo, i, 1);
    }
  }
  emit_marker(cinfo, M_EOI);
}

void jinit_marker_writer(j_compress_ptr cinfo )
{
  cinfo->marker = (struct jpeg_marker_writer *  )(*
    (cinfo->mem)->alloc_small)((j_common_ptr )cinfo, 1, (size_t
    )sizeof(struct jpeg_marker_writer ));
  (cinfo->marker)->write_any_marker = write_any_marker;
  (cinfo->marker)->write_file_header = write_file_header;
  (cinfo->marker)->write_frame_header = write_frame_header;
  (cinfo->marker)->write_scan_header = write_scan_header;
  (cinfo->marker)->write_file_trailer = write_file_trailer;
  (cinfo->marker)->write_tables_only = write_tables_only;
}


#pragma combiner("./jcmainct.i", "-g -O -I/home/scott/wrk/safec/cil/lib ")

#pragma boxalloc("malloc", nozero, sizein(0))

#pragma boxalloc("alloca", nozero, sizein(0))

#pragma boxalloc("calloc", zero, sizemul(0, 1))

#pragma boxprintf("printf", 0)

#pragma boxprintf("fprintf", 1)

#pragma boxprintf("sprintf", 1)

#pragma boxprintf("snprintf", 2)

#pragma boxpoly("memcpy")

#pragma boxexported("main")
typedef struct  {
  struct jpeg_c_main_controller pub ;
  JDIMENSION cur_mcu_row ;
  JDIMENSION rowgroup_ctr ;
  JDIMENSION mcu_ctr ;
  boolean suspended ;
  J_BUF_MODE pass_mode ;
  JSAMPARRAY buffer[10] ;
} my_main_controller ; /*typedef*/

typedef my_main_controller *  my_main_ptr ; /*typedef*/

static void process_data_simple_main(j_compress_ptr cinfo , JSAMPARRAY input_buf
  , JDIMENSION *  in_row_ctr , JDIMENSION in_rows_avail ) ; /*decdef*/

static void start_pass_main(j_compress_ptr cinfo , J_BUF_MODE pass_mode )
{
  my_main_ptr main = (my_main_ptr )cinfo->main; /*decdef*/
  if(cinfo->raw_data_in)
    return;
  main->cur_mcu_row = 0;
  main->rowgroup_ctr = 0;
  main->mcu_ctr = 0;
  main->suspended = 0;
  main->pass_mode = pass_mode;
  switch(pass_mode)
  {
  case JBUF_PASS_THRU:
      ;
    (main->pub).process_data = process_data_simple_main;
    break;
  default :
      ;
    (cinfo->err)->msg_code = JERR_BAD_BUFFER_MODE, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
    break;
  }
}

static void process_data_simple_main(j_compress_ptr cinfo , JSAMPARRAY input_buf
  , JDIMENSION *  in_row_ctr , JDIMENSION in_rows_avail )
{
  my_main_ptr main = (my_main_ptr )cinfo->main; /*decdef*/
  while(main->cur_mcu_row < cinfo->total_iMCU_rows)
  {
    if(main->rowgroup_ctr < 8)
      (* (cinfo->prep)->pre_process_data)(cinfo, input_buf, in_row_ctr,
	in_rows_avail, main->buffer, & main->rowgroup_ctr, (JDIMENSION )8);
    if(main->rowgroup_ctr != 8)
      return;
    (* (cinfo->coef)->compress_data)(cinfo, main->buffer, & main->mcu_ctr);
    if(main->mcu_ctr < cinfo->MCUs_per_row)
    {
      if(! main->suspended)
      {
	(* in_row_ctr)--;
	main->suspended = 1;
      }
      return;
    }
    if(main->suspended)
    {
      (* in_row_ctr)++;
      main->suspended = 0;
    }
    main->mcu_ctr = 0;
    main->rowgroup_ctr = 0;
    main->cur_mcu_row++;
  }
}

void jinit_c_main_controller(j_compress_ptr cinfo , boolean need_full_buffer )
{
  my_main_ptr main ; /*decdef*/
  int ci ; /*decdef*/
  jpeg_component_info *  compptr ; /*decdef*/
  main = (my_main_ptr )(* (cinfo->mem)->alloc_small)((j_common_ptr )cinfo, 1,
    (size_t )sizeof(my_main_controller ));
  cinfo->main = (struct jpeg_c_main_controller *  )main;
  (main->pub).start_pass = start_pass_main;
  if(cinfo->raw_data_in)
    return;
  if(need_full_buffer)
  {
    (cinfo->err)->msg_code = JERR_BAD_BUFFER_MODE, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  }
  else
  {
    for(ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components; ci++,
      compptr++)
    {
      (main->buffer)[ci] = (* (cinfo->mem)->alloc_sarray)((j_common_ptr )cinfo,
	1, compptr->width_in_blocks * 8, (JDIMENSION )(compptr->v_samp_factor *
	8));
    }
  }
}


#pragma combiner("./jcprepct.i", "-g -O -I/home/scott/wrk/safec/cil/lib ")

#pragma boxalloc("malloc", nozero, sizein(0))

#pragma boxalloc("alloca", nozero, sizein(0))

#pragma boxalloc("calloc", zero, sizemul(0, 1))

#pragma boxprintf("printf", 0)

#pragma boxprintf("fprintf", 1)

#pragma boxprintf("sprintf", 1)

#pragma boxprintf("snprintf", 2)

#pragma boxpoly("memcpy")

#pragma boxexported("main")
typedef struct  {
  struct jpeg_c_prep_controller pub ;
  JSAMPARRAY color_buf[10] ;
  JDIMENSION rows_to_go ;
  int next_buf_row ;
  int this_row_group ;
  int next_buf_stop ;
} my_prep_controller ; /*typedef*/

typedef my_prep_controller *  my_prep_ptr ; /*typedef*/

static void start_pass_prep(j_compress_ptr cinfo , J_BUF_MODE pass_mode )
{
  my_prep_ptr prep = (my_prep_ptr )cinfo->prep; /*decdef*/
  if(pass_mode != JBUF_PASS_THRU)
    (cinfo->err)->msg_code = JERR_BAD_BUFFER_MODE, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  prep->rows_to_go = cinfo->image_height;
  prep->next_buf_row = 0;
  prep->this_row_group = 0;
  prep->next_buf_stop = 2 * cinfo->max_v_samp_factor;
}

static void expand_bottom_edge(JSAMPARRAY image_data , JDIMENSION num_cols ,
  int input_rows , int output_rows )
{
  register int row ; /*decdef*/
  for(row = input_rows; row < output_rows; row++)
  {
    jcopy_sample_rows(image_data, input_rows - 1, image_data, row, 1, num_cols);
  }
}

static void pre_process_data(j_compress_ptr cinfo , JSAMPARRAY input_buf ,
  JDIMENSION *  in_row_ctr , JDIMENSION in_rows_avail , JSAMPIMAGE output_buf ,
  JDIMENSION *  out_row_group_ctr , JDIMENSION out_row_groups_avail )
{
  my_prep_ptr prep = (my_prep_ptr )cinfo->prep; /*decdef*/
  int numrows , ci ; /*decdef*/
  JDIMENSION inrows ; /*decdef*/
  jpeg_component_info *  compptr ; /*decdef*/
  while(* in_row_ctr < in_rows_avail && * out_row_group_ctr <
    out_row_groups_avail)
  {
    inrows = in_rows_avail - * in_row_ctr;
    numrows = cinfo->max_v_samp_factor - prep->next_buf_row;
    numrows = (int )((JDIMENSION )numrows < inrows ? (JDIMENSION )numrows
      : inrows);
    (* (cinfo->cconvert)->color_convert)(cinfo, input_buf + * in_row_ctr,
      prep->color_buf, (JDIMENSION )prep->next_buf_row, numrows);
    * in_row_ctr += numrows;
    prep->next_buf_row += numrows;
    prep->rows_to_go -= numrows;
    if(prep->rows_to_go == 0 && prep->next_buf_row < cinfo->max_v_samp_factor)
    {
      for(ci = 0; ci < cinfo->num_components; ci++)
      {
	expand_bottom_edge((prep->color_buf)[ci], cinfo->image_width,
	  prep->next_buf_row, cinfo->max_v_samp_factor);
      }
      prep->next_buf_row = cinfo->max_v_samp_factor;
    }
    if(prep->next_buf_row == cinfo->max_v_samp_factor)
    {
      (* (cinfo->downsample)->downsample)(cinfo, prep->color_buf, (JDIMENSION
	)0, output_buf, * out_row_group_ctr);
      prep->next_buf_row = 0;
      (* out_row_group_ctr)++;
    }
    if(prep->rows_to_go == 0 && * out_row_group_ctr < out_row_groups_avail)
    {
      for(ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components; ci++,
	compptr++)
      {
	expand_bottom_edge(output_buf[ci], compptr->width_in_blocks * 8,
	  (int )(* out_row_group_ctr * compptr->v_samp_factor),
	  (int )(out_row_groups_avail * compptr->v_samp_factor));
      }
      * out_row_group_ctr = out_row_groups_avail;
      break;
    }
  }
}

static void pre_process_context(j_compress_ptr cinfo , JSAMPARRAY input_buf ,
  JDIMENSION *  in_row_ctr , JDIMENSION in_rows_avail , JSAMPIMAGE output_buf ,
  JDIMENSION *  out_row_group_ctr , JDIMENSION out_row_groups_avail )
{
  my_prep_ptr prep = (my_prep_ptr )cinfo->prep; /*decdef*/
  int numrows , ci ; /*decdef*/
  int buf_height = cinfo->max_v_samp_factor * 3; /*decdef*/
  JDIMENSION inrows ; /*decdef*/
  jpeg_component_info *  compptr ; /*decdef*/
  while(* out_row_group_ctr < out_row_groups_avail)
  {
    if(* in_row_ctr < in_rows_avail)
    {
      inrows = in_rows_avail - * in_row_ctr;
      numrows = prep->next_buf_stop - prep->next_buf_row;
      numrows = (int )((JDIMENSION )numrows < inrows ? (JDIMENSION )numrows
	: inrows);
      (* (cinfo->cconvert)->color_convert)(cinfo, input_buf + * in_row_ctr,
	prep->color_buf, (JDIMENSION )prep->next_buf_row, numrows);
      if(prep->rows_to_go == cinfo->image_height)
      {
	for(ci = 0; ci < cinfo->num_components; ci++)
	{
	  int row ; /*decdef*/
	  for(row = 1; row <= cinfo->max_v_samp_factor; row++)
	  {
	    jcopy_sample_rows((prep->color_buf)[ci], 0, (prep->color_buf)[ci], -
	      row, 1, cinfo->image_width);
	  }
	}
      }
      * in_row_ctr += numrows;
      prep->next_buf_row += numrows;
      prep->rows_to_go -= numrows;
    }
    else
    {
      if(prep->rows_to_go != 0)
	break;
    }
    if(prep->rows_to_go == 0 && prep->next_buf_row < prep->next_buf_stop)
    {
      for(ci = 0; ci < cinfo->num_components; ci++)
      {
	expand_bottom_edge((prep->color_buf)[ci], cinfo->image_width,
	  prep->next_buf_row, prep->next_buf_stop);
      }
      prep->next_buf_row = prep->next_buf_stop;
    }
    if(prep->next_buf_row == prep->next_buf_stop)
    {
      (* (cinfo->downsample)->downsample)(cinfo, prep->color_buf, (JDIMENSION
	)prep->this_row_group, output_buf, * out_row_group_ctr);
      (* out_row_group_ctr)++;
      prep->this_row_group += cinfo->max_v_samp_factor;
      if(prep->this_row_group >= buf_height)
	prep->this_row_group = 0;
      if(prep->next_buf_row >= buf_height)
	prep->next_buf_row = 0;
      prep->next_buf_stop = prep->next_buf_row + cinfo->max_v_samp_factor;
    }
    if(prep->rows_to_go == 0 && * out_row_group_ctr < out_row_groups_avail)
    {
      for(ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components; ci++,
	compptr++)
      {
	expand_bottom_edge(output_buf[ci], compptr->width_in_blocks * 8,
	  (int )(* out_row_group_ctr * compptr->v_samp_factor),
	  (int )(out_row_groups_avail * compptr->v_samp_factor));
      }
      * out_row_group_ctr = out_row_groups_avail;
      break;
    }
  }
}

static void create_context_buffer(j_compress_ptr cinfo )
{
  my_prep_ptr prep = (my_prep_ptr )cinfo->prep; /*decdef*/
  int rgroup_height = cinfo->max_v_samp_factor; /*decdef*/
  int ci , i ; /*decdef*/
  jpeg_component_info *  compptr ; /*decdef*/
  JSAMPARRAY true_buffer , fake_buffer ; /*decdef*/
  fake_buffer = (JSAMPARRAY )(* (cinfo->mem)->alloc_small)((j_common_ptr )cinfo,
    1, cinfo->num_components * 5 * rgroup_height * (size_t )sizeof(*
    fake_buffer));
  for(ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components; ci++,
    compptr++)
  {
    true_buffer = (* (cinfo->mem)->alloc_sarray)((j_common_ptr )cinfo, 1,
      (JDIMENSION )((long )compptr->width_in_blocks * 8 *
      cinfo->max_h_samp_factor / compptr->h_samp_factor), (JDIMENSION )(3 *
      rgroup_height));
    memcpy((void *  )(fake_buffer + rgroup_height), (const void *  )true_buffer,
      (size_t )(3 * rgroup_height * (size_t )sizeof(* fake_buffer)));
    for(i = 0; i < rgroup_height; i++)
    {
      fake_buffer[i] = true_buffer[2 * rgroup_height + i];
      fake_buffer[4 * rgroup_height + i] = true_buffer[i];
    }
    (prep->color_buf)[ci] = fake_buffer + rgroup_height;
    fake_buffer += 5 * rgroup_height;
  }
}

void jinit_c_prep_controller(j_compress_ptr cinfo , boolean need_full_buffer )
{
  my_prep_ptr prep ; /*decdef*/
  int ci ; /*decdef*/
  jpeg_component_info *  compptr ; /*decdef*/
  if(need_full_buffer)
    (cinfo->err)->msg_code = JERR_BAD_BUFFER_MODE, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  prep = (my_prep_ptr )(* (cinfo->mem)->alloc_small)((j_common_ptr )cinfo, 1,
    (size_t )sizeof(my_prep_controller ));
  cinfo->prep = (struct jpeg_c_prep_controller *  )prep;
  (prep->pub).start_pass = start_pass_prep;
  if((cinfo->downsample)->need_context_rows)
  {
    (prep->pub).pre_process_data = pre_process_context;
    create_context_buffer(cinfo);
  }
  else
  {
    (prep->pub).pre_process_data = pre_process_data;
    for(ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components; ci++,
      compptr++)
    {
      (prep->color_buf)[ci] = (* (cinfo->mem)->alloc_sarray)((j_common_ptr
	)cinfo, 1, (JDIMENSION )((long )compptr->width_in_blocks * 8 *
	cinfo->max_h_samp_factor / compptr->h_samp_factor), (JDIMENSION
	)cinfo->max_v_samp_factor);
    }
  }
}


#pragma combiner("./jccoefct.i", "-g -O -I/home/scott/wrk/safec/cil/lib ")

#pragma boxalloc("malloc", nozero, sizein(0))

#pragma boxalloc("alloca", nozero, sizein(0))

#pragma boxalloc("calloc", zero, sizemul(0, 1))

#pragma boxprintf("printf", 0)

#pragma boxprintf("fprintf", 1)

#pragma boxprintf("sprintf", 1)

#pragma boxprintf("snprintf", 2)

#pragma boxpoly("memcpy")

#pragma boxexported("main")
typedef struct  {
  struct jpeg_c_coef_controller pub ;
  JDIMENSION MCU_row_num ;
  JBLOCKROW MCU_buffer[10] ;
  jvirt_barray_ptr whole_image[10] ;
} my_coef_controller ; /*typedef*/

typedef my_coef_controller *  my_coef_ptr ; /*typedef*/

static void compress_data(j_compress_ptr cinfo , JSAMPIMAGE input_buf ,
  JDIMENSION *  in_mcu_ctr ) ; /*decdef*/
static void compress_first_pass(j_compress_ptr cinfo , JSAMPIMAGE input_buf ,
  JDIMENSION *  in_mcu_ctr ) ; /*decdef*/
static void compress_output(j_compress_ptr cinfo , JSAMPIMAGE input_buf ,
  JDIMENSION *  in_mcu_ctr ) ; /*decdef*/

static void start_pass_coef(j_compress_ptr cinfo , J_BUF_MODE pass_mode )
{
  my_coef_ptr coef = (my_coef_ptr )cinfo->coef; /*decdef*/
  coef->MCU_row_num = 0;
  switch(pass_mode)
  {
  case JBUF_PASS_THRU:
      ;
    if((coef->whole_image)[0] != (void *  )0)
      (cinfo->err)->msg_code = JERR_BAD_BUFFER_MODE, (*
	(cinfo->err)->error_exit)((j_common_ptr )cinfo);
    (coef->pub).compress_data = compress_data;
    break;
  case JBUF_SAVE_AND_PASS:
      ;
    if((coef->whole_image)[0] == (void *  )0)
      (cinfo->err)->msg_code = JERR_BAD_BUFFER_MODE, (*
	(cinfo->err)->error_exit)((j_common_ptr )cinfo);
    (coef->pub).compress_data = compress_first_pass;
    break;
  case JBUF_CRANK_DEST:
      ;
    if((coef->whole_image)[0] == (void *  )0)
      (cinfo->err)->msg_code = JERR_BAD_BUFFER_MODE, (*
	(cinfo->err)->error_exit)((j_common_ptr )cinfo);
    (coef->pub).compress_data = compress_output;
    break;
  default :
      ;
    (cinfo->err)->msg_code = JERR_BAD_BUFFER_MODE, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
    break;
  }
}

static void compress_data(j_compress_ptr cinfo , JSAMPIMAGE input_buf ,
  JDIMENSION *  in_mcu_ctr )
{
  my_coef_ptr coef = (my_coef_ptr )cinfo->coef; /*decdef*/
  JDIMENSION MCU_col_num ; /*decdef*/
  JDIMENSION last_MCU_col = cinfo->MCUs_per_row - 1; /*decdef*/
  JDIMENSION last_MCU_row = cinfo->MCU_rows_in_scan - 1; /*decdef*/
  int blkn , bi , ci , yindex , blockcnt ; /*decdef*/
  JDIMENSION ypos , xpos ; /*decdef*/
  jpeg_component_info *  compptr ; /*decdef*/
  for(MCU_col_num = * in_mcu_ctr; MCU_col_num <= last_MCU_col; MCU_col_num++)
  {
    blkn = 0;
    for(ci = 0; ci < cinfo->comps_in_scan; ci++)
    {
      compptr = (cinfo->cur_comp_info)[ci];
      blockcnt = MCU_col_num < last_MCU_col ? compptr->MCU_width
	: compptr->last_col_width;
      xpos = MCU_col_num * compptr->MCU_sample_width;
      ypos = 0;
      for(yindex = 0; yindex < compptr->MCU_height; yindex++)
      {
	if(coef->MCU_row_num < last_MCU_row || yindex <
	  compptr->last_row_height)
	{
	  (* (cinfo->fdct)->forward_DCT)(cinfo, compptr, input_buf[ci],
	    (coef->MCU_buffer)[blkn], ypos, xpos, (JDIMENSION )blockcnt);
	  if(blockcnt < compptr->MCU_width)
	  {
	    jzero_far((void *  )(coef->MCU_buffer)[blkn + blockcnt],
	      (compptr->MCU_width - blockcnt) * (size_t )sizeof(JBLOCK ));
	    for(bi = blockcnt; bi < compptr->MCU_width; bi++)
	    {
	      (((coef->MCU_buffer)[blkn + bi])[0])[0] =
		(((coef->MCU_buffer)[blkn + bi - 1])[0])[0];
	    }
	  }
	}
	else
	{
	  jzero_far((void *  )(coef->MCU_buffer)[blkn], compptr->MCU_width *
	    (size_t )sizeof(JBLOCK ));
	  for(bi = 0; bi < compptr->MCU_width; bi++)
	  {
	    (((coef->MCU_buffer)[blkn + bi])[0])[0] = (((coef->MCU_buffer)[blkn
	      - 1])[0])[0];
	  }
	}
	blkn += compptr->MCU_width;
	ypos += 8;
      }
    }
    if(! (* (cinfo->entropy)->encode_mcu)(cinfo, coef->MCU_buffer))
      break;
  }
  if(MCU_col_num > last_MCU_col)
    coef->MCU_row_num++;
  * in_mcu_ctr = MCU_col_num;
}

static void compress_first_pass(j_compress_ptr cinfo , JSAMPIMAGE input_buf ,
  JDIMENSION *  in_mcu_ctr )
{
  my_coef_ptr coef = (my_coef_ptr )cinfo->coef; /*decdef*/
  JDIMENSION last_MCU_row = cinfo->total_iMCU_rows - 1; /*decdef*/
  JDIMENSION blocks_across , MCUs_across , MCUindex ; /*decdef*/
  int bi , ci , h_samp_factor , block_row , block_rows , ndummy ; /*decdef*/
  JCOEF lastDC ; /*decdef*/
  jpeg_component_info *  compptr ; /*decdef*/
  JBLOCKARRAY buffer ; /*decdef*/
  JBLOCKROW thisblockrow , lastblockrow ; /*decdef*/
  for(ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components; ci++,
    compptr++)
  {
    buffer = (* (cinfo->mem)->access_virt_barray)((j_common_ptr )cinfo,
      (coef->whole_image)[ci], coef->MCU_row_num * compptr->v_samp_factor, 1);
    if(coef->MCU_row_num < last_MCU_row)
      block_rows = compptr->v_samp_factor;
    else
    {
      block_rows = (int )(compptr->height_in_blocks % compptr->v_samp_factor);
      if(block_rows == 0)
	block_rows = compptr->v_samp_factor;
    }
    blocks_across = compptr->width_in_blocks;
    h_samp_factor = compptr->h_samp_factor;
    ndummy = (int )(blocks_across % h_samp_factor);
    if(ndummy > 0)
      ndummy = h_samp_factor - ndummy;
    for(block_row = 0; block_row < block_rows; block_row++)
    {
      thisblockrow = buffer[block_row];
      (* (cinfo->fdct)->forward_DCT)(cinfo, compptr, input_buf[ci],
	thisblockrow, (JDIMENSION )(block_row * 8), (JDIMENSION )0,
	blocks_across);
      if(ndummy > 0)
      {
	thisblockrow += blocks_across;
	jzero_far((void *  )thisblockrow, ndummy * (size_t )sizeof(JBLOCK ));
	lastDC = (thisblockrow[- 1])[0];
	for(bi = 0; bi < ndummy; bi++)
	{
	  (thisblockrow[bi])[0] = lastDC;
	}
      }
    }
    if(coef->MCU_row_num == last_MCU_row)
    {
      blocks_across += ndummy;
      MCUs_across = blocks_across / h_samp_factor;
      for(block_row = block_rows; block_row < compptr->v_samp_factor;
	block_row++)
      {
	thisblockrow = buffer[block_row];
	lastblockrow = buffer[block_row - 1];
	jzero_far((void *  )thisblockrow, (size_t )(blocks_across * (size_t
	  )sizeof(JBLOCK )));
	for(MCUindex = 0; MCUindex < MCUs_across; MCUindex++)
	{
	  lastDC = (lastblockrow[h_samp_factor - 1])[0];
	  for(bi = 0; bi < h_samp_factor; bi++)
	  {
	    (thisblockrow[bi])[0] = lastDC;
	  }
	  thisblockrow += h_samp_factor;
	  lastblockrow += h_samp_factor;
	}
      }
    }
  }
  compress_output(cinfo, input_buf, in_mcu_ctr);
}

static void compress_output(j_compress_ptr cinfo , JSAMPIMAGE input_buf ,
  JDIMENSION *  in_mcu_ctr )
{
  my_coef_ptr coef = (my_coef_ptr )cinfo->coef; /*decdef*/
  JDIMENSION MCU_col_num ; /*decdef*/
  int blkn , ci , xindex , yindex , yoffset , num_MCU_rows ; /*decdef*/
  JDIMENSION remaining_rows , start_col ; /*decdef*/
  JBLOCKARRAY buffer[4] ; /*decdef*/
  JBLOCKROW buffer_ptr ; /*decdef*/
  jpeg_component_info *  compptr ; /*decdef*/
  for(ci = 0; ci < cinfo->comps_in_scan; ci++)
  {
    compptr = (cinfo->cur_comp_info)[ci];
    buffer[ci] = (* (cinfo->mem)->access_virt_barray)((j_common_ptr )cinfo,
      (coef->whole_image)[compptr->component_index], coef->MCU_row_num *
      compptr->v_samp_factor, 0);
  }
  if(cinfo->comps_in_scan == 1)
  {
    compptr = (cinfo->cur_comp_info)[0];
    num_MCU_rows = compptr->v_samp_factor;
    remaining_rows = cinfo->MCU_rows_in_scan - coef->MCU_row_num *
      compptr->v_samp_factor;
    if(remaining_rows < (JDIMENSION )num_MCU_rows)
      num_MCU_rows = (int )remaining_rows;
  }
  else
  {
    num_MCU_rows = 1;
  }
  for(yoffset = 0; yoffset < num_MCU_rows; yoffset++)
  {
    for(MCU_col_num = 0; MCU_col_num < cinfo->MCUs_per_row; MCU_col_num++)
    {
      blkn = 0;
      for(ci = 0; ci < cinfo->comps_in_scan; ci++)
      {
	compptr = (cinfo->cur_comp_info)[ci];
	start_col = MCU_col_num * compptr->MCU_width;
	for(yindex = 0; yindex < compptr->MCU_height; yindex++)
	{
	  buffer_ptr = (buffer[ci])[yindex + yoffset] + start_col;
	  for(xindex = 0; xindex < compptr->MCU_width; xindex++)
	  {
	    (coef->MCU_buffer)[blkn++] = buffer_ptr++;
	  }
	}
      }
      if(! (* (cinfo->entropy)->encode_mcu)(cinfo, coef->MCU_buffer))
      {
	(cinfo->err)->msg_code = JERR_CANT_SUSPEND, (*
	  (cinfo->err)->error_exit)((j_common_ptr )cinfo);
      }
    }
  }
  coef->MCU_row_num++;
  * in_mcu_ctr = cinfo->MCUs_per_row;
}

void jinit_c_coef_controller(j_compress_ptr cinfo , boolean need_full_buffer )
{
  my_coef_ptr coef ; /*decdef*/
  int ci , i ; /*decdef*/
  jpeg_component_info *  compptr ; /*decdef*/
  JBLOCKROW buffer ; /*decdef*/
  coef = (my_coef_ptr )(* (cinfo->mem)->alloc_small)((j_common_ptr )cinfo, 1,
    (size_t )sizeof(my_coef_controller ));
  cinfo->coef = (struct jpeg_c_coef_controller *  )coef;
  (coef->pub).start_pass = start_pass_coef;
  if(need_full_buffer)
  {
    for(ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components; ci++,
      compptr++)
    {
      (coef->whole_image)[ci] = (*
	(cinfo->mem)->request_virt_barray)((j_common_ptr )cinfo, 1, (JDIMENSION
	)jround_up((long )compptr->width_in_blocks,
	(long )compptr->h_samp_factor), compptr->height_in_blocks, (JDIMENSION
	)compptr->v_samp_factor);
    }
  }
  else
  {
    buffer = (JBLOCKROW )(* (cinfo->mem)->alloc_large)((j_common_ptr )cinfo, 1,
      10 * (size_t )sizeof(JBLOCK ));
    for(i = 0; i < 10; i++)
    {
      (coef->MCU_buffer)[i] = buffer + i;
    }
    (coef->whole_image)[0] = (void *  )0;
  }
}


#pragma combiner("./jccolor.i", "-g -O -I/home/scott/wrk/safec/cil/lib ")

#pragma boxalloc("malloc", nozero, sizein(0))

#pragma boxalloc("alloca", nozero, sizein(0))

#pragma boxalloc("calloc", zero, sizemul(0, 1))

#pragma boxprintf("printf", 0)

#pragma boxprintf("fprintf", 1)

#pragma boxprintf("sprintf", 1)

#pragma boxprintf("snprintf", 2)

#pragma boxpoly("memcpy")

#pragma boxexported("main")
typedef struct  {
  struct jpeg_color_converter pub ;
  INT32 *  rgb_ycc_tab ;
} my_color_converter ; /*typedef*/

typedef my_color_converter *  my_cconvert_ptr ; /*typedef*/

static void rgb_ycc_start(j_compress_ptr cinfo )
{
  my_cconvert_ptr cconvert = (my_cconvert_ptr )cinfo->cconvert; /*decdef*/
  INT32 *  rgb_ycc_tab ; /*decdef*/
  INT32 i ; /*decdef*/
  cconvert->rgb_ycc_tab = (rgb_ycc_tab = (INT32 *  )(*
    (cinfo->mem)->alloc_small)((j_common_ptr )cinfo, 1, 8 * (255 + 1) * (size_t
    )sizeof(INT32 )));
  for(i = 0; i <= 255; i++)
  {
    rgb_ycc_tab[i + 0] = (INT32 )(0.29900 * (1L << 16) + 0.5) * i;
    rgb_ycc_tab[i + 1 * (255 + 1)] = (INT32 )(0.58700 * (1L << 16) + 0.5) * i;
    rgb_ycc_tab[i + 2 * (255 + 1)] = (INT32 )(0.11400 * (1L << 16) + 0.5) * i +
      ((INT32 )1 << 16 - 1);
    rgb_ycc_tab[i + 3 * (255 + 1)] = - (INT32 )(0.16874 * (1L << 16) + 0.5) * i;
    rgb_ycc_tab[i + 4 * (255 + 1)] = - (INT32 )(0.33126 * (1L << 16) + 0.5) * i;
    rgb_ycc_tab[i + 5 * (255 + 1)] = (INT32 )(0.50000 * (1L << 16) + 0.5) * i +
      ((INT32 )1 << 16 - 1) * (255 + 1);
    rgb_ycc_tab[i + 6 * (255 + 1)] = - (INT32 )(0.41869 * (1L << 16) + 0.5) * i;
    rgb_ycc_tab[i + 7 * (255 + 1)] = - (INT32 )(0.08131 * (1L << 16) + 0.5) * i;
  }
}

static void rgb_ycc_convert(j_compress_ptr cinfo , JSAMPARRAY input_buf ,
  JSAMPIMAGE output_buf , JDIMENSION output_row , int num_rows )
{
  my_cconvert_ptr cconvert = (my_cconvert_ptr )cinfo->cconvert; /*decdef*/
  register int r , g , b ; /*decdef*/
  register INT32 *  ctab = cconvert->rgb_ycc_tab; /*decdef*/
  register JSAMPROW inptr ; /*decdef*/
  register JSAMPROW outptr0 , outptr1 , outptr2 ; /*decdef*/
  register JDIMENSION col ; /*decdef*/
  JDIMENSION num_cols = cinfo->image_width; /*decdef*/
  while(-- num_rows >= 0)
  {
    inptr = * input_buf++;
    outptr0 = (output_buf[0])[output_row];
    outptr1 = (output_buf[1])[output_row];
    outptr2 = (output_buf[2])[output_row];
    output_row++;
    for(col = 0; col < num_cols; col++)
    {
      r = (int )inptr[0];
      g = (int )inptr[1];
      b = (int )inptr[2];
      inptr += 3;
      outptr0[col] = (JSAMPLE )(ctab[r + 0] + ctab[g + 1 * (255 + 1)] + ctab[b +
	2 * (255 + 1)] >> 16);
      outptr1[col] = (JSAMPLE )(ctab[r + 3 * (255 + 1)] + ctab[g + 4 * (255 +
	1)] + ctab[b + 5 * (255 + 1)] >> 16);
      outptr2[col] = (JSAMPLE )(ctab[r + 5 * (255 + 1)] + ctab[g + 6 * (255 +
	1)] + ctab[b + 7 * (255 + 1)] >> 16);
    }
  }
}

static void rgb_gray_convert(j_compress_ptr cinfo , JSAMPARRAY input_buf ,
  JSAMPIMAGE output_buf , JDIMENSION output_row , int num_rows )
{
  my_cconvert_ptr cconvert = (my_cconvert_ptr )cinfo->cconvert; /*decdef*/
  register int r , g , b ; /*decdef*/
  register INT32 *  ctab = cconvert->rgb_ycc_tab; /*decdef*/
  register JSAMPROW inptr ; /*decdef*/
  register JSAMPROW outptr ; /*decdef*/
  register JDIMENSION col ; /*decdef*/
  JDIMENSION num_cols = cinfo->image_width; /*decdef*/
  while(-- num_rows >= 0)
  {
    inptr = * input_buf++;
    outptr = (output_buf[0])[output_row];
    output_row++;
    for(col = 0; col < num_cols; col++)
    {
      r = (int )inptr[0];
      g = (int )inptr[1];
      b = (int )inptr[2];
      inptr += 3;
      outptr[col] = (JSAMPLE )(ctab[r + 0] + ctab[g + 1 * (255 + 1)] + ctab[b +
	2 * (255 + 1)] >> 16);
    }
  }
}

static void cmyk_ycck_convert(j_compress_ptr cinfo , JSAMPARRAY input_buf ,
  JSAMPIMAGE output_buf , JDIMENSION output_row , int num_rows )
{
  my_cconvert_ptr cconvert = (my_cconvert_ptr )cinfo->cconvert; /*decdef*/
  register int r , g , b ; /*decdef*/
  register INT32 *  ctab = cconvert->rgb_ycc_tab; /*decdef*/
  register JSAMPROW inptr ; /*decdef*/
  register JSAMPROW outptr0 , outptr1 , outptr2 , outptr3 ; /*decdef*/
  register JDIMENSION col ; /*decdef*/
  JDIMENSION num_cols = cinfo->image_width; /*decdef*/
  while(-- num_rows >= 0)
  {
    inptr = * input_buf++;
    outptr0 = (output_buf[0])[output_row];
    outptr1 = (output_buf[1])[output_row];
    outptr2 = (output_buf[2])[output_row];
    outptr3 = (output_buf[3])[output_row];
    output_row++;
    for(col = 0; col < num_cols; col++)
    {
      r = 255 - (int )inptr[0];
      g = 255 - (int )inptr[1];
      b = 255 - (int )inptr[2];
      outptr3[col] = inptr[3];
      inptr += 4;
      outptr0[col] = (JSAMPLE )(ctab[r + 0] + ctab[g + 1 * (255 + 1)] + ctab[b +
	2 * (255 + 1)] >> 16);
      outptr1[col] = (JSAMPLE )(ctab[r + 3 * (255 + 1)] + ctab[g + 4 * (255 +
	1)] + ctab[b + 5 * (255 + 1)] >> 16);
      outptr2[col] = (JSAMPLE )(ctab[r + 5 * (255 + 1)] + ctab[g + 6 * (255 +
	1)] + ctab[b + 7 * (255 + 1)] >> 16);
    }
  }
}

static void grayscale_convert(j_compress_ptr cinfo , JSAMPARRAY input_buf ,
  JSAMPIMAGE output_buf , JDIMENSION output_row , int num_rows )
{
  register JSAMPROW inptr ; /*decdef*/
  register JSAMPROW outptr ; /*decdef*/
  register JDIMENSION col ; /*decdef*/
  JDIMENSION num_cols = cinfo->image_width; /*decdef*/
  int instride = cinfo->input_components; /*decdef*/
  while(-- num_rows >= 0)
  {
    inptr = * input_buf++;
    outptr = (output_buf[0])[output_row];
    output_row++;
    for(col = 0; col < num_cols; col++)
    {
      outptr[col] = inptr[0];
      inptr += instride;
    }
  }
}

static void null_convert(j_compress_ptr cinfo , JSAMPARRAY input_buf ,
  JSAMPIMAGE output_buf , JDIMENSION output_row , int num_rows )
{
  register JSAMPROW inptr ; /*decdef*/
  register JSAMPROW outptr ; /*decdef*/
  register JDIMENSION col ; /*decdef*/
  register int ci ; /*decdef*/
  int nc = cinfo->num_components; /*decdef*/
  JDIMENSION num_cols = cinfo->image_width; /*decdef*/
  while(-- num_rows >= 0)
  {
    for(ci = 0; ci < nc; ci++)
    {
      inptr = * input_buf;
      outptr = (output_buf[ci])[output_row];
      for(col = 0; col < num_cols; col++)
      {
	outptr[col] = inptr[ci];
	inptr += nc;
      }
    }
    input_buf++;
    output_row++;
  }
}

static void null_method(j_compress_ptr cinfo )
{
}

void jinit_color_converter(j_compress_ptr cinfo )
{
  my_cconvert_ptr cconvert ; /*decdef*/
  cconvert = (my_cconvert_ptr )(* (cinfo->mem)->alloc_small)((j_common_ptr
    )cinfo, 1, (size_t )sizeof(my_color_converter ));
  cinfo->cconvert = (struct jpeg_color_converter *  )cconvert;
  (cconvert->pub).start_pass = null_method;
  switch(cinfo->in_color_space)
  {
  case JCS_GRAYSCALE:
      ;
    if(cinfo->input_components != 1)
      (cinfo->err)->msg_code = JERR_BAD_IN_COLORSPACE, (*
	(cinfo->err)->error_exit)((j_common_ptr )cinfo);
    break;
  case JCS_RGB:
      ;
  case JCS_YCbCr:
      ;
    if(cinfo->input_components != 3)
      (cinfo->err)->msg_code = JERR_BAD_IN_COLORSPACE, (*
	(cinfo->err)->error_exit)((j_common_ptr )cinfo);
    break;
  case JCS_CMYK:
      ;
  case JCS_YCCK:
      ;
    if(cinfo->input_components != 4)
      (cinfo->err)->msg_code = JERR_BAD_IN_COLORSPACE, (*
	(cinfo->err)->error_exit)((j_common_ptr )cinfo);
    break;
  default :
      ;
    if(cinfo->input_components < 1)
      (cinfo->err)->msg_code = JERR_BAD_IN_COLORSPACE, (*
	(cinfo->err)->error_exit)((j_common_ptr )cinfo);
    break;
  }
  switch(cinfo->jpeg_color_space)
  {
  case JCS_GRAYSCALE:
      ;
    if(cinfo->num_components != 1)
      (cinfo->err)->msg_code = JERR_BAD_J_COLORSPACE, (*
	(cinfo->err)->error_exit)((j_common_ptr )cinfo);
    if(cinfo->in_color_space == JCS_GRAYSCALE)
      (cconvert->pub).color_convert = grayscale_convert;
    else
    {
      if(cinfo->in_color_space == JCS_RGB)
      {
	(cconvert->pub).start_pass = rgb_ycc_start;
	(cconvert->pub).color_convert = rgb_gray_convert;
      }
      else
      {
	if(cinfo->in_color_space == JCS_YCbCr)
	  (cconvert->pub).color_convert = grayscale_convert;
	else
	  (cinfo->err)->msg_code = JERR_CONVERSION_NOTIMPL, (*
	    (cinfo->err)->error_exit)((j_common_ptr )cinfo);
      }
    }
    break;
  case JCS_RGB:
      ;
    if(cinfo->num_components != 3)
      (cinfo->err)->msg_code = JERR_BAD_J_COLORSPACE, (*
	(cinfo->err)->error_exit)((j_common_ptr )cinfo);
    if(cinfo->in_color_space == JCS_RGB && 3 == 3)
      (cconvert->pub).color_convert = null_convert;
    else
      (cinfo->err)->msg_code = JERR_CONVERSION_NOTIMPL, (*
	(cinfo->err)->error_exit)((j_common_ptr )cinfo);
    break;
  case JCS_YCbCr:
      ;
    if(cinfo->num_components != 3)
      (cinfo->err)->msg_code = JERR_BAD_J_COLORSPACE, (*
	(cinfo->err)->error_exit)((j_common_ptr )cinfo);
    if(cinfo->in_color_space == JCS_RGB)
    {
      (cconvert->pub).start_pass = rgb_ycc_start;
      (cconvert->pub).color_convert = rgb_ycc_convert;
    }
    else
    {
      if(cinfo->in_color_space == JCS_YCbCr)
	(cconvert->pub).color_convert = null_convert;
      else
	(cinfo->err)->msg_code = JERR_CONVERSION_NOTIMPL, (*
	  (cinfo->err)->error_exit)((j_common_ptr )cinfo);
    }
    break;
  case JCS_CMYK:
      ;
    if(cinfo->num_components != 4)
      (cinfo->err)->msg_code = JERR_BAD_J_COLORSPACE, (*
	(cinfo->err)->error_exit)((j_common_ptr )cinfo);
    if(cinfo->in_color_space == JCS_CMYK)
      (cconvert->pub).color_convert = null_convert;
    else
      (cinfo->err)->msg_code = JERR_CONVERSION_NOTIMPL, (*
	(cinfo->err)->error_exit)((j_common_ptr )cinfo);
    break;
  case JCS_YCCK:
      ;
    if(cinfo->num_components != 4)
      (cinfo->err)->msg_code = JERR_BAD_J_COLORSPACE, (*
	(cinfo->err)->error_exit)((j_common_ptr )cinfo);
    if(cinfo->in_color_space == JCS_CMYK)
    {
      (cconvert->pub).start_pass = rgb_ycc_start;
      (cconvert->pub).color_convert = cmyk_ycck_convert;
    }
    else
    {
      if(cinfo->in_color_space == JCS_YCCK)
	(cconvert->pub).color_convert = null_convert;
      else
	(cinfo->err)->msg_code = JERR_CONVERSION_NOTIMPL, (*
	  (cinfo->err)->error_exit)((j_common_ptr )cinfo);
    }
    break;
  default :
      ;
    if(cinfo->jpeg_color_space != cinfo->in_color_space || cinfo->num_components
      != cinfo->input_components)
      (cinfo->err)->msg_code = JERR_CONVERSION_NOTIMPL, (*
	(cinfo->err)->error_exit)((j_common_ptr )cinfo);
    (cconvert->pub).color_convert = null_convert;
    break;
  }
}


#pragma combiner("./jcsample.i", "-g -O -I/home/scott/wrk/safec/cil/lib ")

#pragma boxalloc("malloc", nozero, sizein(0))

#pragma boxalloc("alloca", nozero, sizein(0))

#pragma boxalloc("calloc", zero, sizemul(0, 1))

#pragma boxprintf("printf", 0)

#pragma boxprintf("fprintf", 1)

#pragma boxprintf("sprintf", 1)

#pragma boxprintf("snprintf", 2)

#pragma boxpoly("memcpy")

#pragma boxexported("main")
typedef void ( *  downsample1_ptr )(j_compress_ptr cinfo , jpeg_component_info
  *  compptr , JSAMPARRAY input_data , JSAMPARRAY output_data ) ; /*typedef*/

typedef struct  {
  struct jpeg_downsampler pub ;
  downsample1_ptr methods[10] ;
} my_downsampler ; /*typedef*/

typedef my_downsampler *  my_downsample_ptr ; /*typedef*/

static void start_pass_downsample(j_compress_ptr cinfo )
{
}

static void expand_right_edge(JSAMPARRAY image_data , int num_rows , JDIMENSION
  input_cols , JDIMENSION output_cols )
{
  register JSAMPROW ptr ; /*decdef*/
  register JSAMPLE pixval ; /*decdef*/
  register int count ; /*decdef*/
  int row ; /*decdef*/
  int numcols = (int )(output_cols - input_cols); /*decdef*/
  if(numcols > 0)
  {
    for(row = 0; row < num_rows; row++)
    {
      ptr = image_data[row] + input_cols;
      pixval = ptr[- 1];
      for(count = numcols; count > 0; count--)
	* ptr++ = pixval;
    }
  }
}

static void sep_downsample(j_compress_ptr cinfo , JSAMPIMAGE input_buf ,
  JDIMENSION in_row_index , JSAMPIMAGE output_buf , JDIMENSION
  out_row_group_index )
{
  my_downsample_ptr downsample = (my_downsample_ptr
    )cinfo->downsample; /*decdef*/
  int ci ; /*decdef*/
  jpeg_component_info *  compptr ; /*decdef*/
  JSAMPARRAY in_ptr , out_ptr ; /*decdef*/
  for(ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components; ci++,
    compptr++)
  {
    in_ptr = input_buf[ci] + in_row_index;
    out_ptr = output_buf[ci] + out_row_group_index * compptr->v_samp_factor;
    (* (downsample->methods)[ci])(cinfo, compptr, in_ptr, out_ptr);
  }
}


static void int_downsample(j_compress_ptr cinfo , jpeg_component_info *  compptr
  , JSAMPARRAY input_data , JSAMPARRAY output_data )
{
  int inrow , outrow , h_expand , v_expand , numpix , numpix2 , h , v
    ; /*decdef*/
  JDIMENSION outcol , outcol_h ; /*decdef*/
  JDIMENSION output_cols = compptr->width_in_blocks * 8; /*decdef*/
  JSAMPROW inptr , outptr ; /*decdef*/
  INT32 outvalue ; /*decdef*/
  h_expand = cinfo->max_h_samp_factor / compptr->h_samp_factor;
  v_expand = cinfo->max_v_samp_factor / compptr->v_samp_factor;
  numpix = h_expand * v_expand;
  numpix2 = numpix / 2;
  expand_right_edge(input_data, cinfo->max_v_samp_factor, cinfo->image_width,
    output_cols * h_expand);
  inrow = 0;
  for(outrow = 0; outrow < compptr->v_samp_factor; outrow++)
  {
    outptr = output_data[outrow];
    for(outcol = 0, outcol_h = 0; outcol < output_cols; outcol++, outcol_h +=
      h_expand)
    {
      outvalue = 0;
      for(v = 0; v < v_expand; v++)
      {
	inptr = input_data[inrow + v] + outcol_h;
	for(h = 0; h < h_expand; h++)
	{
	  outvalue += (INT32 )((int )(* inptr++));
	}
      }
      * outptr++ = (JSAMPLE )((outvalue + numpix2) / numpix);
    }
    inrow += v_expand;
  }
}

static void fullsize_downsample(j_compress_ptr cinfo , jpeg_component_info * 
  compptr , JSAMPARRAY input_data , JSAMPARRAY output_data )
{
  jcopy_sample_rows(input_data, 0, output_data, 0, cinfo->max_v_samp_factor,
    cinfo->image_width);
  expand_right_edge(output_data, cinfo->max_v_samp_factor, cinfo->image_width,
    compptr->width_in_blocks * 8);
}

static void h2v1_downsample(j_compress_ptr cinfo , jpeg_component_info * 
  compptr , JSAMPARRAY input_data , JSAMPARRAY output_data )
{
  int outrow ; /*decdef*/
  JDIMENSION outcol ; /*decdef*/
  JDIMENSION output_cols = compptr->width_in_blocks * 8; /*decdef*/
  register JSAMPROW inptr , outptr ; /*decdef*/
  register int bias ; /*decdef*/
  expand_right_edge(input_data, cinfo->max_v_samp_factor, cinfo->image_width,
    output_cols * 2);
  for(outrow = 0; outrow < compptr->v_samp_factor; outrow++)
  {
    outptr = output_data[outrow];
    inptr = input_data[outrow];
    bias = 0;
    for(outcol = 0; outcol < output_cols; outcol++)
    {
      * outptr++ = (JSAMPLE )((int )(* inptr) + (int )inptr[1] + bias >> 1);
      bias ^= 1;
      inptr += 2;
    }
  }
}

static void h2v2_downsample(j_compress_ptr cinfo , jpeg_component_info * 
  compptr , JSAMPARRAY input_data , JSAMPARRAY output_data )
{
  int inrow , outrow ; /*decdef*/
  JDIMENSION outcol ; /*decdef*/
  JDIMENSION output_cols = compptr->width_in_blocks * 8; /*decdef*/
  register JSAMPROW inptr0 , inptr1 , outptr ; /*decdef*/
  register int bias ; /*decdef*/
  expand_right_edge(input_data, cinfo->max_v_samp_factor, cinfo->image_width,
    output_cols * 2);
  inrow = 0;
  for(outrow = 0; outrow < compptr->v_samp_factor; outrow++)
  {
    outptr = output_data[outrow];
    inptr0 = input_data[inrow];
    inptr1 = input_data[inrow + 1];
    bias = 1;
    for(outcol = 0; outcol < output_cols; outcol++)
    {
      * outptr++ = (JSAMPLE )((int )(* inptr0) + (int )inptr0[1] + (int )(*
	inptr1) + (int )inptr1[1] + bias >> 2);
      bias ^= 3;
      inptr0 += 2;
      inptr1 += 2;
    }
    inrow += 2;
  }
}

static void h2v2_smooth_downsample(j_compress_ptr cinfo , jpeg_component_info * 
  compptr , JSAMPARRAY input_data , JSAMPARRAY output_data )
{
  int inrow , outrow ; /*decdef*/
  JDIMENSION colctr ; /*decdef*/
  JDIMENSION output_cols = compptr->width_in_blocks * 8; /*decdef*/
  register JSAMPROW inptr0 , inptr1 , above_ptr , below_ptr , outptr
    ; /*decdef*/
  INT32 membersum , neighsum , memberscale , neighscale ; /*decdef*/
  expand_right_edge(input_data - 1, cinfo->max_v_samp_factor + 2,
    cinfo->image_width, output_cols * 2);
  memberscale = 16384 - cinfo->smoothing_factor * 80;
  neighscale = cinfo->smoothing_factor * 16;
  inrow = 0;
  for(outrow = 0; outrow < compptr->v_samp_factor; outrow++)
  {
    outptr = output_data[outrow];
    inptr0 = input_data[inrow];
    inptr1 = input_data[inrow + 1];
    above_ptr = input_data[inrow - 1];
    below_ptr = input_data[inrow + 2];
    membersum = (int )(* inptr0) + (int )inptr0[1] + (int )(* inptr1) +
      (int )inptr1[1];
    neighsum = (int )(* above_ptr) + (int )above_ptr[1] + (int )(* below_ptr) +
      (int )below_ptr[1] + (int )(* inptr0) + (int )inptr0[2] + (int )(* inptr1)
      + (int )inptr1[2];
    neighsum += neighsum;
    neighsum += (int )(* above_ptr) + (int )above_ptr[2] + (int )(* below_ptr) +
      (int )below_ptr[2];
    membersum = membersum * memberscale + neighsum * neighscale;
    * outptr++ = (JSAMPLE )(membersum + 32768 >> 16);
    inptr0 += 2;
    inptr1 += 2;
    above_ptr += 2;
    below_ptr += 2;
    for(colctr = output_cols - 2; colctr > 0; colctr--)
    {
      membersum = (int )(* inptr0) + (int )inptr0[1] + (int )(* inptr1) +
	(int )inptr1[1];
      neighsum = (int )(* above_ptr) + (int )above_ptr[1] + (int )(* below_ptr)
	+ (int )below_ptr[1] + (int )inptr0[- 1] + (int )inptr0[2] +
	(int )inptr1[- 1] + (int )inptr1[2];
      neighsum += neighsum;
      neighsum += (int )above_ptr[- 1] + (int )above_ptr[2] + (int )below_ptr[-
	1] + (int )below_ptr[2];
      membersum = membersum * memberscale + neighsum * neighscale;
      * outptr++ = (JSAMPLE )(membersum + 32768 >> 16);
      inptr0 += 2;
      inptr1 += 2;
      above_ptr += 2;
      below_ptr += 2;
    }
    membersum = (int )(* inptr0) + (int )inptr0[1] + (int )(* inptr1) +
      (int )inptr1[1];
    neighsum = (int )(* above_ptr) + (int )above_ptr[1] + (int )(* below_ptr) +
      (int )below_ptr[1] + (int )inptr0[- 1] + (int )inptr0[1] + (int )inptr1[-
      1] + (int )inptr1[1];
    neighsum += neighsum;
    neighsum += (int )above_ptr[- 1] + (int )above_ptr[1] + (int )below_ptr[- 1]
      + (int )below_ptr[1];
    membersum = membersum * memberscale + neighsum * neighscale;
    * outptr = (JSAMPLE )(membersum + 32768 >> 16);
    inrow += 2;
  }
}

static void fullsize_smooth_downsample(j_compress_ptr cinfo ,
  jpeg_component_info *  compptr , JSAMPARRAY input_data , JSAMPARRAY
  output_data )
{
  int outrow ; /*decdef*/
  JDIMENSION colctr ; /*decdef*/
  JDIMENSION output_cols = compptr->width_in_blocks * 8; /*decdef*/
  register JSAMPROW inptr , above_ptr , below_ptr , outptr ; /*decdef*/
  INT32 membersum , neighsum , memberscale , neighscale ; /*decdef*/
  int colsum , lastcolsum , nextcolsum ; /*decdef*/
  expand_right_edge(input_data - 1, cinfo->max_v_samp_factor + 2,
    cinfo->image_width, output_cols);
  memberscale = 65536L - cinfo->smoothing_factor * 512L;
  neighscale = cinfo->smoothing_factor * 64;
  for(outrow = 0; outrow < compptr->v_samp_factor; outrow++)
  {
    outptr = output_data[outrow];
    inptr = input_data[outrow];
    above_ptr = input_data[outrow - 1];
    below_ptr = input_data[outrow + 1];
    colsum = (int )(* above_ptr++) + (int )(* below_ptr++) + (int )(* inptr);
    membersum = (int )(* inptr++);
    nextcolsum = (int )(* above_ptr) + (int )(* below_ptr) + (int )(* inptr);
    neighsum = colsum + (colsum - membersum) + nextcolsum;
    membersum = membersum * memberscale + neighsum * neighscale;
    * outptr++ = (JSAMPLE )(membersum + 32768 >> 16);
    lastcolsum = colsum;
    colsum = nextcolsum;
    for(colctr = output_cols - 2; colctr > 0; colctr--)
    {
      membersum = (int )(* inptr++);
      above_ptr++;
      below_ptr++;
      nextcolsum = (int )(* above_ptr) + (int )(* below_ptr) + (int )(* inptr);
      neighsum = lastcolsum + (colsum - membersum) + nextcolsum;
      membersum = membersum * memberscale + neighsum * neighscale;
      * outptr++ = (JSAMPLE )(membersum + 32768 >> 16);
      lastcolsum = colsum;
      colsum = nextcolsum;
    }
    membersum = (int )(* inptr);
    neighsum = lastcolsum + (colsum - membersum) + colsum;
    membersum = membersum * memberscale + neighsum * neighscale;
    * outptr = (JSAMPLE )(membersum + 32768 >> 16);
  }
}

void jinit_downsampler(j_compress_ptr cinfo )
{
  my_downsample_ptr downsample ; /*decdef*/
  int ci ; /*decdef*/
  jpeg_component_info *  compptr ; /*decdef*/
  boolean smoothok = 1; /*decdef*/
  downsample = (my_downsample_ptr )(* (cinfo->mem)->alloc_small)((j_common_ptr
    )cinfo, 1, (size_t )sizeof(my_downsampler ));
  cinfo->downsample = (struct jpeg_downsampler *  )downsample;
  (downsample->pub).start_pass = start_pass_downsample;
  (downsample->pub).downsample = sep_downsample;
  (downsample->pub).need_context_rows = 0;
  if(cinfo->CCIR601_sampling)
    (cinfo->err)->msg_code = JERR_CCIR601_NOTIMPL, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  for(ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components; ci++,
    compptr++)
  {
    if(compptr->h_samp_factor == cinfo->max_h_samp_factor &&
      compptr->v_samp_factor == cinfo->max_v_samp_factor)
    {
      if(cinfo->smoothing_factor)
      {
	(downsample->methods)[ci] = fullsize_smooth_downsample;
	(downsample->pub).need_context_rows = 1;
      }
      else
	(downsample->methods)[ci] = fullsize_downsample;
    }
    else
    {
      if(compptr->h_samp_factor * 2 == cinfo->max_h_samp_factor &&
	compptr->v_samp_factor == cinfo->max_v_samp_factor)
      {
	smoothok = 0;
	(downsample->methods)[ci] = h2v1_downsample;
      }
      else
      {
	if(compptr->h_samp_factor * 2 == cinfo->max_h_samp_factor &&
	  compptr->v_samp_factor * 2 == cinfo->max_v_samp_factor)
	{
	  if(cinfo->smoothing_factor)
	  {
	    (downsample->methods)[ci] = h2v2_smooth_downsample;
	    (downsample->pub).need_context_rows = 1;
	  }
	  else
	    (downsample->methods)[ci] = h2v2_downsample;
	}
	else
	{
	  if(cinfo->max_h_samp_factor % compptr->h_samp_factor == 0 &&
	    cinfo->max_v_samp_factor % compptr->v_samp_factor == 0)
	  {
	    smoothok = 0;
	    (downsample->methods)[ci] = int_downsample;
	  }
	  else
	    (cinfo->err)->msg_code = JERR_FRACT_SAMPLE_NOTIMPL, (*
	      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
	}
      }
    }
  }
  if(cinfo->smoothing_factor && ! smoothok)
    (cinfo->err)->msg_code = JTRC_SMOOTH_NOTIMPL, (*
      (cinfo->err)->emit_message)((j_common_ptr )cinfo, 0);
}


#pragma combiner("./jchuff.i", "-g -O -I/home/scott/wrk/safec/cil/lib ")

#pragma boxalloc("malloc", nozero, sizein(0))

#pragma boxalloc("alloca", nozero, sizein(0))

#pragma boxalloc("calloc", zero, sizemul(0, 1))

#pragma boxprintf("printf", 0)

#pragma boxprintf("fprintf", 1)

#pragma boxprintf("sprintf", 1)

#pragma boxprintf("snprintf", 2)

#pragma boxpoly("memcpy")

#pragma boxexported("main")
typedef struct  {
  unsigned int ehufco[256] ;
  char ehufsi[256] ;
} C_DERIVED_TBL ; /*typedef*/

typedef struct  {
  INT32 put_buffer ;
  int put_bits ;
  int last_dc_val[4] ;
} savable_state ; /*typedef*/

typedef struct  {
  struct jpeg_entropy_encoder pub ;
  savable_state saved ;
  unsigned int restarts_to_go ;
  int next_restart_num ;
  C_DERIVED_TBL *  dc_derived_tbls[4] ;
  C_DERIVED_TBL *  ac_derived_tbls[4] ;
  long *  dc_count_ptrs[4] ;
  long *  ac_count_ptrs[4] ;
} huff_entropy_encoder ; /*typedef*/

typedef huff_entropy_encoder *  huff_entropy_ptr ; /*typedef*/

typedef struct  {
  JOCTET *  next_output_byte ;
  size_t free_in_buffer ;
  savable_state cur ;
  j_compress_ptr cinfo ;
} working_state ; /*typedef*/

static boolean encode_mcu_huff(j_compress_ptr cinfo , JBLOCKROW *  MCU_data )
  ; /*decdef*/
static void finish_pass_huff(j_compress_ptr cinfo ) ; /*decdef*/
static boolean encode_mcu_gather(j_compress_ptr cinfo , JBLOCKROW *  MCU_data )
  ; /*decdef*/
static void finish_pass_gather(j_compress_ptr cinfo ) ; /*decdef*/
static void fix_huff_tbl(j_compress_ptr cinfo , JHUFF_TBL *  htbl ,
  C_DERIVED_TBL *  *  pdtbl ) ; /*decdef*/

static void start_pass_huff(j_compress_ptr cinfo , boolean gather_statistics )
{
  huff_entropy_ptr entropy = (huff_entropy_ptr )cinfo->entropy; /*decdef*/
  int ci , dctbl , actbl ; /*decdef*/
  jpeg_component_info *  compptr ; /*decdef*/
  if(gather_statistics)
  {
    (entropy->pub).encode_mcu = encode_mcu_gather;
    (entropy->pub).finish_pass = finish_pass_gather;
  }
  else
  {
    (entropy->pub).encode_mcu = encode_mcu_huff;
    (entropy->pub).finish_pass = finish_pass_huff;
  }
  for(ci = 0; ci < cinfo->comps_in_scan; ci++)
  {
    compptr = (cinfo->cur_comp_info)[ci];
    dctbl = compptr->dc_tbl_no;
    actbl = compptr->ac_tbl_no;
    if(dctbl < 0 || dctbl >= 4 || (cinfo->dc_huff_tbl_ptrs)[dctbl] == (void * 
      )0 && ! gather_statistics)
      (cinfo->err)->msg_code = JERR_NO_HUFF_TABLE,
	(((cinfo->err)->msg_parm).i)[0] = dctbl, (*
	(cinfo->err)->error_exit)((j_common_ptr )cinfo);
    if(actbl < 0 || actbl >= 4 || (cinfo->ac_huff_tbl_ptrs)[actbl] == (void * 
      )0 && ! gather_statistics)
      (cinfo->err)->msg_code = JERR_NO_HUFF_TABLE,
	(((cinfo->err)->msg_parm).i)[0] = actbl, (*
	(cinfo->err)->error_exit)((j_common_ptr )cinfo);
    if(gather_statistics)
    {
      if((entropy->dc_count_ptrs)[dctbl] == (void *  )0)
	(entropy->dc_count_ptrs)[dctbl] = (long *  )(*
	  (cinfo->mem)->alloc_small)((j_common_ptr )cinfo, 1, 257 * (size_t
	  )sizeof(long ));
      memset((void *  )(entropy->dc_count_ptrs)[dctbl], 0, (size_t )(257 *
	(size_t )sizeof(long )));
      if((entropy->ac_count_ptrs)[actbl] == (void *  )0)
	(entropy->ac_count_ptrs)[actbl] = (long *  )(*
	  (cinfo->mem)->alloc_small)((j_common_ptr )cinfo, 1, 257 * (size_t
	  )sizeof(long ));
      memset((void *  )(entropy->ac_count_ptrs)[actbl], 0, (size_t )(257 *
	(size_t )sizeof(long )));
    }
    else
    {
      fix_huff_tbl(cinfo, (cinfo->dc_huff_tbl_ptrs)[dctbl], &
	(entropy->dc_derived_tbls)[dctbl]);
      fix_huff_tbl(cinfo, (cinfo->ac_huff_tbl_ptrs)[actbl], &
	(entropy->ac_derived_tbls)[actbl]);
    }
    ((entropy->saved).last_dc_val)[ci] = 0;
  }
  (entropy->saved).put_buffer = 0;
  (entropy->saved).put_bits = 0;
  entropy->restarts_to_go = cinfo->restart_interval;
  entropy->next_restart_num = 0;
}

static void fix_huff_tbl(j_compress_ptr cinfo , JHUFF_TBL *  htbl ,
  C_DERIVED_TBL *  *  pdtbl )
{
  C_DERIVED_TBL *  dtbl ; /*decdef*/
  int p , i , l , lastp , si ; /*decdef*/
  char huffsize[257] ; /*decdef*/
  unsigned int huffcode[257] ; /*decdef*/
  unsigned int code ; /*decdef*/
  if(* pdtbl == (void *  )0)
    * pdtbl = (C_DERIVED_TBL *  )(* (cinfo->mem)->alloc_small)((j_common_ptr
      )cinfo, 1, (size_t )sizeof(C_DERIVED_TBL ));
  dtbl = * pdtbl;
  p = 0;
  for(l = 1; l <= 16; l++)
  {
    for(i = 1; i <= (int )(htbl->bits)[l]; i++)
      huffsize[p++] = (char )l;
  }
  huffsize[p] = 0;
  lastp = p;
  code = 0;
  si = huffsize[0];
  p = 0;
  while(huffsize[p])
  {
    while((int )huffsize[p] == si)
    {
      huffcode[p++] = code;
      code++;
    }
    code <<= 1;
    si++;
  }
  memset((void *  )dtbl->ehufsi, 0, (size_t )((size_t )sizeof(dtbl->ehufsi)));
  for(p = 0; p < lastp; p++)
  {
    (dtbl->ehufco)[(htbl->huffval)[p]] = huffcode[p];
    (dtbl->ehufsi)[(htbl->huffval)[p]] = huffsize[p];
  }
}

static boolean dump_buffer(working_state *  state )
{
  struct jpeg_destination_mgr *  dest = (state->cinfo)->dest; /*decdef*/
  if(! (* dest->empty_output_buffer)(state->cinfo))
    return 0;
  state->next_output_byte = dest->next_output_byte;
  state->free_in_buffer = dest->free_in_buffer;
  return 1;
}

static boolean emit_bits(working_state *  state , unsigned int code , int size )
{
  register INT32 put_buffer = (INT32 )code; /*decdef*/
  register int put_bits = (state->cur).put_bits; /*decdef*/
  if(size == 0)
    ((state->cinfo)->err)->msg_code = JERR_HUFF_MISSING_CODE, (*
      ((state->cinfo)->err)->error_exit)((j_common_ptr )state->cinfo);
  put_buffer &= ((INT32 )1 << size) - 1;
  put_bits += size;
  put_buffer <<= 24 - put_bits;
  put_buffer |= (state->cur).put_buffer;
  while(put_bits >= 8)
  {
    int c = (int )(put_buffer >> 16 & 0xFF); /*decdef*/
    {
      * state->next_output_byte++ = (JOCTET )c;
      if(-- state->free_in_buffer == 0)
      {
	if(! dump_buffer(state))
	{
	  return 0;
	}
      }
    }
    ;
    if(c == 0xFF)
    {
      {
	* state->next_output_byte++ = (JOCTET )0;
	if(-- state->free_in_buffer == 0)
	{
	  if(! dump_buffer(state))
	  {
	    return 0;
	  }
	}
      }
      ;
    }
    put_buffer <<= 8;
    put_bits -= 8;
  }
  (state->cur).put_buffer = put_buffer;
  (state->cur).put_bits = put_bits;
  return 1;
}

static boolean flush_bits(working_state *  state )
{
  if(! emit_bits(state, 0x7F, 7))
    return 0;
  (state->cur).put_buffer = 0;
  (state->cur).put_bits = 0;
  return 1;
}

static boolean encode_one_block(working_state *  state , JCOEFPTR block ,
  int last_dc_val , C_DERIVED_TBL *  dctbl , C_DERIVED_TBL *  actbl )
{
  register int temp , temp2 ; /*decdef*/
  register int nbits ; /*decdef*/
  register int k , r , i ; /*decdef*/
  temp = (temp2 = block[0] - last_dc_val);
  if(temp < 0)
  {
    temp = - temp;
    temp2--;
  }
  nbits = 0;
  while(temp)
  {
    nbits++;
    temp >>= 1;
  }
  if(! emit_bits(state, (dctbl->ehufco)[nbits], (dctbl->ehufsi)[nbits]))
    return 0;
  if(nbits)
  {
    if(! emit_bits(state, (unsigned int )temp2, nbits))
      return 0;
  }
  r = 0;
  for(k = 1; k < 64; k++)
  {
    if((temp = block[k]) == 0)
    {
      r++;
    }
    else
    {
      while(r > 15)
      {
	if(! emit_bits(state, (actbl->ehufco)[0xF0], (actbl->ehufsi)[0xF0]))
	  return 0;
	r -= 16;
      }
      temp2 = temp;
      if(temp < 0)
      {
	temp = - temp;
	temp2--;
      }
      nbits = 1;
      while(temp >>= 1)
	nbits++;
      i = (r << 4) + nbits;
      if(! emit_bits(state, (actbl->ehufco)[i], (actbl->ehufsi)[i]))
	return 0;
      if(! emit_bits(state, (unsigned int )temp2, nbits))
	return 0;
      r = 0;
    }
  }
  if(r > 0)
  {
    if(! emit_bits(state, (actbl->ehufco)[0], (actbl->ehufsi)[0]))
      return 0;
  }
  return 1;
}

static boolean emit_restart(working_state *  state , int restart_num )
{
  int ci ; /*decdef*/
  if(! flush_bits(state))
    return 0;
  {
    * state->next_output_byte++ = (JOCTET )0xFF;
    if(-- state->free_in_buffer == 0)
    {
      if(! dump_buffer(state))
      {
	return 0;
      }
    }
  }
  ;
  {
    * state->next_output_byte++ = (JOCTET )(0xD0 + restart_num);
    if(-- state->free_in_buffer == 0)
    {
      if(! dump_buffer(state))
      {
	return 0;
      }
    }
  }
  ;
  for(ci = 0; ci < (state->cinfo)->comps_in_scan; ci++)
    ((state->cur).last_dc_val)[ci] = 0;
  return 1;
}

static boolean encode_mcu_huff(j_compress_ptr cinfo , JBLOCKROW *  MCU_data )
{
  huff_entropy_ptr entropy = (huff_entropy_ptr )cinfo->entropy; /*decdef*/
  working_state state ; /*decdef*/
  int blkn , ci ; /*decdef*/
  jpeg_component_info *  compptr ; /*decdef*/
  state.next_output_byte = (cinfo->dest)->next_output_byte;
  state.free_in_buffer = (cinfo->dest)->free_in_buffer;
  state.cur = entropy->saved;
  state.cinfo = cinfo;
  if(cinfo->restart_interval)
  {
    if(entropy->restarts_to_go == 0)
    {
      if(! emit_restart(& state, entropy->next_restart_num))
	return 0;
    }
  }
  for(blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++)
  {
    ci = (cinfo->MCU_membership)[blkn];
    compptr = (cinfo->cur_comp_info)[ci];
    if(! encode_one_block(& state, (MCU_data[blkn])[0],
      ((state.cur).last_dc_val)[ci],
      (entropy->dc_derived_tbls)[compptr->dc_tbl_no],
      (entropy->ac_derived_tbls)[compptr->ac_tbl_no]))
      return 0;
    ((state.cur).last_dc_val)[ci] = ((MCU_data[blkn])[0])[0];
  }
  (cinfo->dest)->next_output_byte = state.next_output_byte;
  (cinfo->dest)->free_in_buffer = state.free_in_buffer;
  entropy->saved = state.cur;
  if(cinfo->restart_interval)
  {
    if(entropy->restarts_to_go == 0)
    {
      entropy->restarts_to_go = cinfo->restart_interval;
      entropy->next_restart_num++;
      entropy->next_restart_num &= 7;
    }
    entropy->restarts_to_go--;
  }
  return 1;
}

static void finish_pass_huff(j_compress_ptr cinfo )
{
  huff_entropy_ptr entropy = (huff_entropy_ptr )cinfo->entropy; /*decdef*/
  working_state state ; /*decdef*/
  state.next_output_byte = (cinfo->dest)->next_output_byte;
  state.free_in_buffer = (cinfo->dest)->free_in_buffer;
  state.cur = entropy->saved;
  state.cinfo = cinfo;
  if(! flush_bits(& state))
    (cinfo->err)->msg_code = JERR_CANT_SUSPEND, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  (cinfo->dest)->next_output_byte = state.next_output_byte;
  (cinfo->dest)->free_in_buffer = state.free_in_buffer;
  entropy->saved = state.cur;
}

static void htest_one_block(JCOEFPTR block , int last_dc_val , long dc_counts[]
  , long ac_counts[] )
{
  register int temp ; /*decdef*/
  register int nbits ; /*decdef*/
  register int k , r ; /*decdef*/
  temp = block[0] - last_dc_val;
  if(temp < 0)
    temp = - temp;
  nbits = 0;
  while(temp)
  {
    nbits++;
    temp >>= 1;
  }
  dc_counts[nbits]++;
  r = 0;
  for(k = 1; k < 64; k++)
  {
    if((temp = block[k]) == 0)
    {
      r++;
    }
    else
    {
      while(r > 15)
      {
	ac_counts[0xF0]++;
	r -= 16;
      }
      if(temp < 0)
	temp = - temp;
      nbits = 1;
      while(temp >>= 1)
	nbits++;
      ac_counts[(r << 4) + nbits]++;
      r = 0;
    }
  }
  if(r > 0)
    ac_counts[0]++;
}

static boolean encode_mcu_gather(j_compress_ptr cinfo , JBLOCKROW *  MCU_data )
{
  huff_entropy_ptr entropy = (huff_entropy_ptr )cinfo->entropy; /*decdef*/
  int blkn , ci ; /*decdef*/
  jpeg_component_info *  compptr ; /*decdef*/
  if(cinfo->restart_interval)
  {
    if(entropy->restarts_to_go == 0)
    {
      for(ci = 0; ci < cinfo->comps_in_scan; ci++)
	((entropy->saved).last_dc_val)[ci] = 0;
      entropy->restarts_to_go = cinfo->restart_interval;
    }
    entropy->restarts_to_go--;
  }
  for(blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++)
  {
    ci = (cinfo->MCU_membership)[blkn];
    compptr = (cinfo->cur_comp_info)[ci];
    htest_one_block((MCU_data[blkn])[0], ((entropy->saved).last_dc_val)[ci],
      (entropy->dc_count_ptrs)[compptr->dc_tbl_no],
      (entropy->ac_count_ptrs)[compptr->ac_tbl_no]);
    ((entropy->saved).last_dc_val)[ci] = ((MCU_data[blkn])[0])[0];
  }
  return 1;
}

static void gen_huff_coding(j_compress_ptr cinfo , JHUFF_TBL *  htbl ,
  long freq[] )
{
  UINT8 bits[32 + 1] ; /*decdef*/
  int codesize[257] ; /*decdef*/
  int others[257] ; /*decdef*/
  int c1 , c2 ; /*decdef*/
  int p , i , j ; /*decdef*/
  long v ; /*decdef*/
  memset((void *  )bits, 0, (size_t )((size_t )sizeof(bits)));
  memset((void *  )codesize, 0, (size_t )((size_t )sizeof(codesize)));
  for(i = 0; i < 257; i++)
    others[i] = - 1;
  freq[256] = 1;
  for(; ; )
  {
    c1 = - 1;
    v = 1000000000L;
    for(i = 0; i <= 256; i++)
    {
      if(freq[i] && freq[i] <= v)
      {
	v = freq[i];
	c1 = i;
      }
    }
    c2 = - 1;
    v = 1000000000L;
    for(i = 0; i <= 256; i++)
    {
      if(freq[i] && freq[i] <= v && i != c1)
      {
	v = freq[i];
	c2 = i;
      }
    }
    if(c2 < 0)
      break;
    freq[c1] += freq[c2];
    freq[c2] = 0;
    codesize[c1]++;
    while(others[c1] >= 0)
    {
      c1 = others[c1];
      codesize[c1]++;
    }
    others[c1] = c2;
    codesize[c2]++;
    while(others[c2] >= 0)
    {
      c2 = others[c2];
      codesize[c2]++;
    }
  }
  for(i = 0; i <= 256; i++)
  {
    if(codesize[i])
    {
      if(codesize[i] > 32)
	(cinfo->err)->msg_code = JERR_HUFF_CLEN_OVERFLOW, (*
	  (cinfo->err)->error_exit)((j_common_ptr )cinfo);
      bits[codesize[i]]++;
    }
  }
  for(i = 32; i > 16; i--)
  {
    while(bits[i] > 0)
    {
      j = i - 2;
      while(bits[j] == 0)
	j--;
      bits[i] -= 2;
      bits[i - 1]++;
      bits[j + 1] += 2;
      bits[j]--;
    }
  }
  while(bits[i] == 0)
    i--;
  bits[i]--;
  memcpy((void *  )htbl->bits, (const void *  )bits, (size_t )((size_t
    )sizeof(htbl->bits)));
  p = 0;
  for(i = 1; i <= 32; i++)
  {
    for(j = 0; j <= 255; j++)
    {
      if(codesize[j] == i)
      {
	(htbl->huffval)[p] = (UINT8 )j;
	p++;
      }
    }
  }
  htbl->sent_table = 0;
}

static void finish_pass_gather(j_compress_ptr cinfo )
{
  huff_entropy_ptr entropy = (huff_entropy_ptr )cinfo->entropy; /*decdef*/
  int ci , dctbl , actbl ; /*decdef*/
  jpeg_component_info *  compptr ; /*decdef*/
  JHUFF_TBL *  *  htblptr ; /*decdef*/
  boolean did_dc[4] ; /*decdef*/
  boolean did_ac[4] ; /*decdef*/
  memset((void *  )did_dc, 0, (size_t )((size_t )sizeof(did_dc)));
  memset((void *  )did_ac, 0, (size_t )((size_t )sizeof(did_ac)));
  for(ci = 0; ci < cinfo->comps_in_scan; ci++)
  {
    compptr = (cinfo->cur_comp_info)[ci];
    dctbl = compptr->dc_tbl_no;
    actbl = compptr->ac_tbl_no;
    if(! did_dc[dctbl])
    {
      htblptr = & (cinfo->dc_huff_tbl_ptrs)[dctbl];
      if(* htblptr == (void *  )0)
	* htblptr = jpeg_alloc_huff_table((j_common_ptr )cinfo);
      gen_huff_coding(cinfo, * htblptr, (entropy->dc_count_ptrs)[dctbl]);
      did_dc[dctbl] = 1;
    }
    if(! did_ac[actbl])
    {
      htblptr = & (cinfo->ac_huff_tbl_ptrs)[actbl];
      if(* htblptr == (void *  )0)
	* htblptr = jpeg_alloc_huff_table((j_common_ptr )cinfo);
      gen_huff_coding(cinfo, * htblptr, (entropy->ac_count_ptrs)[actbl]);
      did_ac[actbl] = 1;
    }
  }
}

void jinit_huff_encoder(j_compress_ptr cinfo )
{
  huff_entropy_ptr entropy ; /*decdef*/
  int i ; /*decdef*/
  entropy = (huff_entropy_ptr )(* (cinfo->mem)->alloc_small)((j_common_ptr
    )cinfo, 1, (size_t )sizeof(huff_entropy_encoder ));
  cinfo->entropy = (struct jpeg_entropy_encoder *  )entropy;
  (entropy->pub).start_pass = start_pass_huff;
  for(i = 0; i < 4; i++)
  {
    (entropy->dc_derived_tbls)[i] = ((entropy->ac_derived_tbls)[i] = (void * 
      )0);
    (entropy->dc_count_ptrs)[i] = ((entropy->ac_count_ptrs)[i] = (void *  )0);
  }
}


#pragma combiner("./jcdctmgr.i", "-g -O -I/home/scott/wrk/safec/cil/lib ")

#pragma boxalloc("malloc", nozero, sizein(0))

#pragma boxalloc("alloca", nozero, sizein(0))

#pragma boxalloc("calloc", zero, sizemul(0, 1))

#pragma boxprintf("printf", 0)

#pragma boxprintf("fprintf", 1)

#pragma boxprintf("sprintf", 1)

#pragma boxprintf("snprintf", 2)

#pragma boxpoly("memcpy")

#pragma boxexported("main")
typedef int DCTELEM ; /*typedef*/

typedef void ( *  forward_DCT_method_ptr )(DCTELEM *  data ) ; /*typedef*/

typedef void ( *  float_DCT_method_ptr )(float *  data ) ; /*typedef*/

typedef int ISLOW_MULT_TYPE ; /*typedef*/

typedef int IFAST_MULT_TYPE ; /*typedef*/

typedef float FLOAT_MULT_TYPE ; /*typedef*/

extern void jpeg_fdct_islow(DCTELEM *  data ) ; /*decdef*/
extern void jpeg_fdct_ifast(DCTELEM *  data ) ; /*decdef*/
extern void jpeg_fdct_float(float *  data ) ; /*decdef*/
extern void jpeg_idct_islow(j_decompress_ptr cinfo , jpeg_component_info * 
  compptr , JCOEFPTR coef_block , JSAMPARRAY output_buf , JDIMENSION output_col
  ) ; /*decdef*/
extern void jpeg_idct_ifast(j_decompress_ptr cinfo , jpeg_component_info * 
  compptr , JCOEFPTR coef_block , JSAMPARRAY output_buf , JDIMENSION output_col
  ) ; /*decdef*/
extern void jpeg_idct_float(j_decompress_ptr cinfo , jpeg_component_info * 
  compptr , JCOEFPTR coef_block , JSAMPARRAY output_buf , JDIMENSION output_col
  ) ; /*decdef*/
extern void jpeg_idct_4x4(j_decompress_ptr cinfo , jpeg_component_info * 
  compptr , JCOEFPTR coef_block , JSAMPARRAY output_buf , JDIMENSION output_col
  ) ; /*decdef*/
extern void jpeg_idct_2x2(j_decompress_ptr cinfo , jpeg_component_info * 
  compptr , JCOEFPTR coef_block , JSAMPARRAY output_buf , JDIMENSION output_col
  ) ; /*decdef*/
extern void jpeg_idct_1x1(j_decompress_ptr cinfo , jpeg_component_info * 
  compptr , JCOEFPTR coef_block , JSAMPARRAY output_buf , JDIMENSION output_col
  ) ; /*decdef*/

typedef struct  {
  struct jpeg_forward_dct pub ;
  forward_DCT_method_ptr do_dct ;
  DCTELEM *  divisors[4] ;
  float_DCT_method_ptr do_float_dct ;
  float *  float_divisors[4] ;
} my_fdct_controller ; /*typedef*/

typedef my_fdct_controller *  my_fdct_ptr ; /*typedef*/

static const int ZAG[64] = {0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4,
  5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49,
  56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31,
  39, 46, 53, 60, 61, 54, 47, 55, 62, 63}; /*decdef*/

static void start_pass_fdctmgr(j_compress_ptr cinfo )
{
  my_fdct_ptr fdct = (my_fdct_ptr )cinfo->fdct; /*decdef*/
  int ci , qtblno , i ; /*decdef*/
  jpeg_component_info *  compptr ; /*decdef*/
  JQUANT_TBL *  qtbl ; /*decdef*/
  DCTELEM *  dtbl ; /*decdef*/
  for(ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components; ci++,
    compptr++)
  {
    qtblno = compptr->quant_tbl_no;
    if(qtblno < 0 || qtblno >= 4 || (cinfo->quant_tbl_ptrs)[qtblno] == (void * 
      )0)
      (cinfo->err)->msg_code = JERR_NO_QUANT_TABLE,
	(((cinfo->err)->msg_parm).i)[0] = qtblno, (*
	(cinfo->err)->error_exit)((j_common_ptr )cinfo);
    qtbl = (cinfo->quant_tbl_ptrs)[qtblno];
    switch(cinfo->dct_method)
    {
    case JDCT_ISLOW:
	;
      if((fdct->divisors)[qtblno] == (void *  )0)
      {
	(fdct->divisors)[qtblno] = (DCTELEM *  )(*
	  (cinfo->mem)->alloc_small)((j_common_ptr )cinfo, 1, 64 * (size_t
	  )sizeof(DCTELEM ));
      }
      dtbl = (fdct->divisors)[qtblno];
      for(i = 0; i < 64; i++)
      {
	dtbl[i] = (DCTELEM )(qtbl->quantval)[i] << 3;
      }
      break;
    case JDCT_IFAST:
	;
      {
	static const INT16 aanscales[64] = {16384, 22725, 21407, 19266, 16384,
	  12873, 8867, 4520, 22725, 31521, 29692, 26722, 22725, 17855, 12299,
	  6270, 21407, 29692, 27969, 25172, 21407, 16819, 11585, 5906, 19266,
	  26722, 25172, 22654, 19266, 15137, 10426, 5315, 16384, 22725, 21407,
	  19266, 16384, 12873, 8867, 4520, 12873, 17855, 16819, 15137, 12873,
	  10114, 6967, 3552, 8867, 12299, 11585, 10426, 8867, 6967, 4799, 2446,
	  4520, 6270, 5906, 5315, 4520, 3552, 2446, 1247}; /*decdef*/
	if((fdct->divisors)[qtblno] == (void *  )0)
	{
	  (fdct->divisors)[qtblno] = (DCTELEM *  )(*
	    (cinfo->mem)->alloc_small)((j_common_ptr )cinfo, 1, 64 * (size_t
	    )sizeof(DCTELEM ));
	}
	dtbl = (fdct->divisors)[qtblno];
	for(i = 0; i < 64; i++)
	{
	  dtbl[i] = (DCTELEM )((INT32 )(qtbl->quantval)[i] * (INT32
	    )aanscales[ZAG[i]] + ((INT32 )1 << 14 - 3 - 1) >> 14 - 3);
	}
      }
      break;
    case JDCT_FLOAT:
	;
      {
	float *  fdtbl ; /*decdef*/
	int row , col ; /*decdef*/
	static const double aanscalefactor[8] = {1.0, 1.387039845, 1.306562965,
	  1.175875602, 1.0, 0.785694958, 0.541196100, 0.275899379}; /*decdef*/
	if((fdct->float_divisors)[qtblno] == (void *  )0)
	{
	  (fdct->float_divisors)[qtblno] = (float *  )(*
	    (cinfo->mem)->alloc_small)((j_common_ptr )cinfo, 1, 64 * (size_t
	    )sizeof(float ));
	}
	fdtbl = (fdct->float_divisors)[qtblno];
	for(i = 0; i < 64; i++)
	{
	  row = ZAG[i] >> 3;
	  col = ZAG[i] & 7;
	  fdtbl[i] = (float )(1.0 / ((double )(qtbl->quantval)[i] *
	    aanscalefactor[row] * aanscalefactor[col] * 8.0));
	}
      }
      break;
    default :
	;
      (cinfo->err)->msg_code = JERR_NOT_COMPILED, (*
	(cinfo->err)->error_exit)((j_common_ptr )cinfo);
      break;
    }
  }
}

static void forward_DCT(j_compress_ptr cinfo , jpeg_component_info *  compptr ,
  JSAMPARRAY sample_data , JBLOCKROW coef_blocks , JDIMENSION start_row ,
  JDIMENSION start_col , JDIMENSION num_blocks )
{
  my_fdct_ptr fdct = (my_fdct_ptr )cinfo->fdct; /*decdef*/
  forward_DCT_method_ptr do_dct = fdct->do_dct; /*decdef*/
  DCTELEM *  divisors = (fdct->divisors)[compptr->quant_tbl_no]; /*decdef*/
  DCTELEM workspace[64] ; /*decdef*/
  JDIMENSION bi ; /*decdef*/
  sample_data += start_row;
  for(bi = 0; bi < num_blocks; bi++, start_col += 8)
  {
    {
      register DCTELEM *  workspaceptr ; /*decdef*/
      register JSAMPROW elemptr ; /*decdef*/
      register int elemr ; /*decdef*/
      workspaceptr = workspace;
      for(elemr = 0; elemr < 8; elemr++)
      {
	elemptr = sample_data[elemr] + start_col;
	* workspaceptr++ = (int )(* elemptr++) - 128;
	* workspaceptr++ = (int )(* elemptr++) - 128;
	* workspaceptr++ = (int )(* elemptr++) - 128;
	* workspaceptr++ = (int )(* elemptr++) - 128;
	* workspaceptr++ = (int )(* elemptr++) - 128;
	* workspaceptr++ = (int )(* elemptr++) - 128;
	* workspaceptr++ = (int )(* elemptr++) - 128;
	* workspaceptr++ = (int )(* elemptr++) - 128;
      }
    }
    (* do_dct)(workspace);
    {
      register DCTELEM temp , qval ; /*decdef*/
      register int i ; /*decdef*/
      register JCOEFPTR output_ptr = coef_blocks[bi]; /*decdef*/
      for(i = 0; i < 64; i++)
      {
	qval = divisors[i];
	temp = workspace[ZAG[i]];
	if(temp < 0)
	{
	  temp = - temp;
	  temp += qval >> 1;
	  if(temp >= qval)
	    temp /= qval;
	  else
	    temp = 0;
	  temp = - temp;
	}
	else
	{
	  temp += qval >> 1;
	  if(temp >= qval)
	    temp /= qval;
	  else
	    temp = 0;
	}
	output_ptr[i] = (JCOEF )temp;
      }
    }
  }
}

static void forward_DCT_float(j_compress_ptr cinfo , jpeg_component_info * 
  compptr , JSAMPARRAY sample_data , JBLOCKROW coef_blocks , JDIMENSION
  start_row , JDIMENSION start_col , JDIMENSION num_blocks )
{
  my_fdct_ptr fdct = (my_fdct_ptr )cinfo->fdct; /*decdef*/
  float_DCT_method_ptr do_dct = fdct->do_float_dct; /*decdef*/
  float *  divisors = (fdct->float_divisors)[compptr->quant_tbl_no]; /*decdef*/
  float workspace[64] ; /*decdef*/
  JDIMENSION bi ; /*decdef*/
  sample_data += start_row;
  for(bi = 0; bi < num_blocks; bi++, start_col += 8)
  {
    {
      register float *  workspaceptr ; /*decdef*/
      register JSAMPROW elemptr ; /*decdef*/
      register int elemr ; /*decdef*/
      workspaceptr = workspace;
      for(elemr = 0; elemr < 8; elemr++)
      {
	elemptr = sample_data[elemr] + start_col;
	* workspaceptr++ = (int )(* elemptr++) - 128;
	* workspaceptr++ = (int )(* elemptr++) - 128;
	* workspaceptr++ = (int )(* elemptr++) - 128;
	* workspaceptr++ = (int )(* elemptr++) - 128;
	* workspaceptr++ = (int )(* elemptr++) - 128;
	* workspaceptr++ = (int )(* elemptr++) - 128;
	* workspaceptr++ = (int )(* elemptr++) - 128;
	* workspaceptr++ = (int )(* elemptr++) - 128;
      }
    }
    (* do_dct)(workspace);
    {
      register float temp ; /*decdef*/
      register int i ; /*decdef*/
      register JCOEFPTR output_ptr = coef_blocks[bi]; /*decdef*/
      for(i = 0; i < 64; i++)
      {
	temp = workspace[ZAG[i]] * divisors[i];
	output_ptr[i] = (JCOEF )((int )(temp + (float )16384.5) - 16384);
      }
    }
  }
}

void jinit_forward_dct(j_compress_ptr cinfo )
{
  my_fdct_ptr fdct ; /*decdef*/
  int i ; /*decdef*/
  fdct = (my_fdct_ptr )(* (cinfo->mem)->alloc_small)((j_common_ptr )cinfo, 1,
    (size_t )sizeof(my_fdct_controller ));
  cinfo->fdct = (struct jpeg_forward_dct *  )fdct;
  (fdct->pub).start_pass = start_pass_fdctmgr;
  switch(cinfo->dct_method)
  {
  case JDCT_ISLOW:
      ;
    (fdct->pub).forward_DCT = forward_DCT;
    fdct->do_dct = jpeg_fdct_islow;
    break;
  case JDCT_IFAST:
      ;
    (fdct->pub).forward_DCT = forward_DCT;
    fdct->do_dct = jpeg_fdct_ifast;
    break;
  case JDCT_FLOAT:
      ;
    (fdct->pub).forward_DCT = forward_DCT_float;
    fdct->do_float_dct = jpeg_fdct_float;
    break;
  default :
      ;
    (cinfo->err)->msg_code = JERR_NOT_COMPILED, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
    break;
  }
  for(i = 0; i < 4; i++)
  {
    (fdct->divisors)[i] = (void *  )0;
    (fdct->float_divisors)[i] = (void *  )0;
  }
}


#pragma combiner("./jfdctfst.i", "-g -O -I/home/scott/wrk/safec/cil/lib ")

#pragma boxalloc("malloc", nozero, sizein(0))

#pragma boxalloc("alloca", nozero, sizein(0))

#pragma boxalloc("calloc", zero, sizemul(0, 1))

#pragma boxprintf("printf", 0)

#pragma boxprintf("fprintf", 1)

#pragma boxprintf("sprintf", 1)

#pragma boxprintf("snprintf", 2)

#pragma boxpoly("memcpy")

#pragma boxexported("main")
void jpeg_fdct_ifast(DCTELEM *  data )
{
  DCTELEM tmp0 , tmp1 , tmp2 , tmp3 , tmp4 , tmp5 , tmp6 , tmp7 ; /*decdef*/
  DCTELEM tmp10 , tmp11 , tmp12 , tmp13 ; /*decdef*/
  DCTELEM z1 , z2 , z3 , z4 , z5 , z11 , z13 ; /*decdef*/
  DCTELEM *  dataptr ; /*decdef*/
  int ctr ; /*decdef*/
  dataptr = data;
  for(ctr = 8 - 1; ctr >= 0; ctr--)
  {
    tmp0 = dataptr[0] + dataptr[7];
    tmp7 = dataptr[0] - dataptr[7];
    tmp1 = dataptr[1] + dataptr[6];
    tmp6 = dataptr[1] - dataptr[6];
    tmp2 = dataptr[2] + dataptr[5];
    tmp5 = dataptr[2] - dataptr[5];
    tmp3 = dataptr[3] + dataptr[4];
    tmp4 = dataptr[3] - dataptr[4];
    tmp10 = tmp0 + tmp3;
    tmp13 = tmp0 - tmp3;
    tmp11 = tmp1 + tmp2;
    tmp12 = tmp1 - tmp2;
    dataptr[0] = tmp10 + tmp11;
    dataptr[4] = tmp10 - tmp11;
    z1 = (DCTELEM )((tmp12 + tmp13) * (INT32 )181 >> 8);
    dataptr[2] = tmp13 + z1;
    dataptr[6] = tmp13 - z1;
    tmp10 = tmp4 + tmp5;
    tmp11 = tmp5 + tmp6;
    tmp12 = tmp6 + tmp7;
    z5 = (DCTELEM )((tmp10 - tmp12) * (INT32 )98 >> 8);
    z2 = (DCTELEM )(tmp10 * (INT32 )139 >> 8) + z5;
    z4 = (DCTELEM )(tmp12 * (INT32 )334 >> 8) + z5;
    z3 = (DCTELEM )(tmp11 * (INT32 )181 >> 8);
    z11 = tmp7 + z3;
    z13 = tmp7 - z3;
    dataptr[5] = z13 + z2;
    dataptr[3] = z13 - z2;
    dataptr[1] = z11 + z4;
    dataptr[7] = z11 - z4;
    dataptr += 8;
  }
  dataptr = data;
  for(ctr = 8 - 1; ctr >= 0; ctr--)
  {
    tmp0 = dataptr[8 * 0] + dataptr[8 * 7];
    tmp7 = dataptr[8 * 0] - dataptr[8 * 7];
    tmp1 = dataptr[8 * 1] + dataptr[8 * 6];
    tmp6 = dataptr[8 * 1] - dataptr[8 * 6];
    tmp2 = dataptr[8 * 2] + dataptr[8 * 5];
    tmp5 = dataptr[8 * 2] - dataptr[8 * 5];
    tmp3 = dataptr[8 * 3] + dataptr[8 * 4];
    tmp4 = dataptr[8 * 3] - dataptr[8 * 4];
    tmp10 = tmp0 + tmp3;
    tmp13 = tmp0 - tmp3;
    tmp11 = tmp1 + tmp2;
    tmp12 = tmp1 - tmp2;
    dataptr[8 * 0] = tmp10 + tmp11;
    dataptr[8 * 4] = tmp10 - tmp11;
    z1 = (DCTELEM )((tmp12 + tmp13) * (INT32 )181 >> 8);
    dataptr[8 * 2] = tmp13 + z1;
    dataptr[8 * 6] = tmp13 - z1;
    tmp10 = tmp4 + tmp5;
    tmp11 = tmp5 + tmp6;
    tmp12 = tmp6 + tmp7;
    z5 = (DCTELEM )((tmp10 - tmp12) * (INT32 )98 >> 8);
    z2 = (DCTELEM )(tmp10 * (INT32 )139 >> 8) + z5;
    z4 = (DCTELEM )(tmp12 * (INT32 )334 >> 8) + z5;
    z3 = (DCTELEM )(tmp11 * (INT32 )181 >> 8);
    z11 = tmp7 + z3;
    z13 = tmp7 - z3;
    dataptr[8 * 5] = z13 + z2;
    dataptr[8 * 3] = z13 - z2;
    dataptr[8 * 1] = z11 + z4;
    dataptr[8 * 7] = z11 - z4;
    dataptr++;
  }
}


#pragma combiner("./jfdctflt.i", "-g -O -I/home/scott/wrk/safec/cil/lib ")

#pragma boxalloc("malloc", nozero, sizein(0))

#pragma boxalloc("alloca", nozero, sizein(0))

#pragma boxalloc("calloc", zero, sizemul(0, 1))

#pragma boxprintf("printf", 0)

#pragma boxprintf("fprintf", 1)

#pragma boxprintf("sprintf", 1)

#pragma boxprintf("snprintf", 2)

#pragma boxpoly("memcpy")

#pragma boxexported("main")
void jpeg_fdct_float(float *  data )
{
  float tmp0 , tmp1 , tmp2 , tmp3 , tmp4 , tmp5 , tmp6 , tmp7 ; /*decdef*/
  float tmp10 , tmp11 , tmp12 , tmp13 ; /*decdef*/
  float z1 , z2 , z3 , z4 , z5 , z11 , z13 ; /*decdef*/
  float *  dataptr ; /*decdef*/
  int ctr ; /*decdef*/
  dataptr = data;
  for(ctr = 8 - 1; ctr >= 0; ctr--)
  {
    tmp0 = dataptr[0] + dataptr[7];
    tmp7 = dataptr[0] - dataptr[7];
    tmp1 = dataptr[1] + dataptr[6];
    tmp6 = dataptr[1] - dataptr[6];
    tmp2 = dataptr[2] + dataptr[5];
    tmp5 = dataptr[2] - dataptr[5];
    tmp3 = dataptr[3] + dataptr[4];
    tmp4 = dataptr[3] - dataptr[4];
    tmp10 = tmp0 + tmp3;
    tmp13 = tmp0 - tmp3;
    tmp11 = tmp1 + tmp2;
    tmp12 = tmp1 - tmp2;
    dataptr[0] = tmp10 + tmp11;
    dataptr[4] = tmp10 - tmp11;
    z1 = (tmp12 + tmp13) * (float )0.707106781;
    dataptr[2] = tmp13 + z1;
    dataptr[6] = tmp13 - z1;
    tmp10 = tmp4 + tmp5;
    tmp11 = tmp5 + tmp6;
    tmp12 = tmp6 + tmp7;
    z5 = (tmp10 - tmp12) * (float )0.382683433;
    z2 = (float )0.541196100 * tmp10 + z5;
    z4 = (float )1.306562965 * tmp12 + z5;
    z3 = tmp11 * (float )0.707106781;
    z11 = tmp7 + z3;
    z13 = tmp7 - z3;
    dataptr[5] = z13 + z2;
    dataptr[3] = z13 - z2;
    dataptr[1] = z11 + z4;
    dataptr[7] = z11 - z4;
    dataptr += 8;
  }
  dataptr = data;
  for(ctr = 8 - 1; ctr >= 0; ctr--)
  {
    tmp0 = dataptr[8 * 0] + dataptr[8 * 7];
    tmp7 = dataptr[8 * 0] - dataptr[8 * 7];
    tmp1 = dataptr[8 * 1] + dataptr[8 * 6];
    tmp6 = dataptr[8 * 1] - dataptr[8 * 6];
    tmp2 = dataptr[8 * 2] + dataptr[8 * 5];
    tmp5 = dataptr[8 * 2] - dataptr[8 * 5];
    tmp3 = dataptr[8 * 3] + dataptr[8 * 4];
    tmp4 = dataptr[8 * 3] - dataptr[8 * 4];
    tmp10 = tmp0 + tmp3;
    tmp13 = tmp0 - tmp3;
    tmp11 = tmp1 + tmp2;
    tmp12 = tmp1 - tmp2;
    dataptr[8 * 0] = tmp10 + tmp11;
    dataptr[8 * 4] = tmp10 - tmp11;
    z1 = (tmp12 + tmp13) * (float )0.707106781;
    dataptr[8 * 2] = tmp13 + z1;
    dataptr[8 * 6] = tmp13 - z1;
    tmp10 = tmp4 + tmp5;
    tmp11 = tmp5 + tmp6;
    tmp12 = tmp6 + tmp7;
    z5 = (tmp10 - tmp12) * (float )0.382683433;
    z2 = (float )0.541196100 * tmp10 + z5;
    z4 = (float )1.306562965 * tmp12 + z5;
    z3 = tmp11 * (float )0.707106781;
    z11 = tmp7 + z3;
    z13 = tmp7 - z3;
    dataptr[8 * 5] = z13 + z2;
    dataptr[8 * 3] = z13 - z2;
    dataptr[8 * 1] = z11 + z4;
    dataptr[8 * 7] = z11 - z4;
    dataptr++;
  }
}


#pragma combiner("./jfdctint.i", "-g -O -I/home/scott/wrk/safec/cil/lib ")

#pragma boxalloc("malloc", nozero, sizein(0))

#pragma boxalloc("alloca", nozero, sizein(0))

#pragma boxalloc("calloc", zero, sizemul(0, 1))

#pragma boxprintf("printf", 0)

#pragma boxprintf("fprintf", 1)

#pragma boxprintf("sprintf", 1)

#pragma boxprintf("snprintf", 2)

#pragma boxpoly("memcpy")

#pragma boxexported("main")
void jpeg_fdct_islow(DCTELEM *  data )
{
  INT32 tmp0 , tmp1 , tmp2 , tmp3 , tmp4 , tmp5 , tmp6 , tmp7 ; /*decdef*/
  INT32 tmp10 , tmp11 , tmp12 , tmp13 ; /*decdef*/
  INT32 z1 , z2 , z3 , z4 , z5 ; /*decdef*/
  DCTELEM *  dataptr ; /*decdef*/
  int ctr ; /*decdef*/
  dataptr = data;
  for(ctr = 8 - 1; ctr >= 0; ctr--)
  {
    tmp0 = dataptr[0] + dataptr[7];
    tmp7 = dataptr[0] - dataptr[7];
    tmp1 = dataptr[1] + dataptr[6];
    tmp6 = dataptr[1] - dataptr[6];
    tmp2 = dataptr[2] + dataptr[5];
    tmp5 = dataptr[2] - dataptr[5];
    tmp3 = dataptr[3] + dataptr[4];
    tmp4 = dataptr[3] - dataptr[4];
    tmp10 = tmp0 + tmp3;
    tmp13 = tmp0 - tmp3;
    tmp11 = tmp1 + tmp2;
    tmp12 = tmp1 - tmp2;
    dataptr[0] = (DCTELEM )(tmp10 + tmp11 << 2);
    dataptr[4] = (DCTELEM )(tmp10 - tmp11 << 2);
    z1 = (tmp12 + tmp13) * (INT32 )4433;
    dataptr[2] = (DCTELEM )(z1 + tmp13 * (INT32 )6270 + ((INT32 )1 << 13 - 2 -
      1) >> 13 - 2);
    dataptr[6] = (DCTELEM )(z1 + tmp12 * - (INT32 )15137 + ((INT32 )1 << 13 - 2
      - 1) >> 13 - 2);
    z1 = tmp4 + tmp7;
    z2 = tmp5 + tmp6;
    z3 = tmp4 + tmp6;
    z4 = tmp5 + tmp7;
    z5 = (z3 + z4) * (INT32 )9633;
    tmp4 = tmp4 * (INT32 )2446;
    tmp5 = tmp5 * (INT32 )16819;
    tmp6 = tmp6 * (INT32 )25172;
    tmp7 = tmp7 * (INT32 )12299;
    z1 = z1 * - (INT32 )7373;
    z2 = z2 * - (INT32 )20995;
    z3 = z3 * - (INT32 )16069;
    z4 = z4 * - (INT32 )3196;
    z3 += z5;
    z4 += z5;
    dataptr[7] = (DCTELEM )(tmp4 + z1 + z3 + ((INT32 )1 << 13 - 2 - 1) >> 13 -
      2);
    dataptr[5] = (DCTELEM )(tmp5 + z2 + z4 + ((INT32 )1 << 13 - 2 - 1) >> 13 -
      2);
    dataptr[3] = (DCTELEM )(tmp6 + z2 + z3 + ((INT32 )1 << 13 - 2 - 1) >> 13 -
      2);
    dataptr[1] = (DCTELEM )(tmp7 + z1 + z4 + ((INT32 )1 << 13 - 2 - 1) >> 13 -
      2);
    dataptr += 8;
  }
  dataptr = data;
  for(ctr = 8 - 1; ctr >= 0; ctr--)
  {
    tmp0 = dataptr[8 * 0] + dataptr[8 * 7];
    tmp7 = dataptr[8 * 0] - dataptr[8 * 7];
    tmp1 = dataptr[8 * 1] + dataptr[8 * 6];
    tmp6 = dataptr[8 * 1] - dataptr[8 * 6];
    tmp2 = dataptr[8 * 2] + dataptr[8 * 5];
    tmp5 = dataptr[8 * 2] - dataptr[8 * 5];
    tmp3 = dataptr[8 * 3] + dataptr[8 * 4];
    tmp4 = dataptr[8 * 3] - dataptr[8 * 4];
    tmp10 = tmp0 + tmp3;
    tmp13 = tmp0 - tmp3;
    tmp11 = tmp1 + tmp2;
    tmp12 = tmp1 - tmp2;
    dataptr[8 * 0] = (DCTELEM )(tmp10 + tmp11 + ((INT32 )1 << 2 - 1) >> 2);
    dataptr[8 * 4] = (DCTELEM )(tmp10 - tmp11 + ((INT32 )1 << 2 - 1) >> 2);
    z1 = (tmp12 + tmp13) * (INT32 )4433;
    dataptr[8 * 2] = (DCTELEM )(z1 + tmp13 * (INT32 )6270 + ((INT32 )1 << 13 + 2
      - 1) >> 13 + 2);
    dataptr[8 * 6] = (DCTELEM )(z1 + tmp12 * - (INT32 )15137 + ((INT32 )1 << 13
      + 2 - 1) >> 13 + 2);
    z1 = tmp4 + tmp7;
    z2 = tmp5 + tmp6;
    z3 = tmp4 + tmp6;
    z4 = tmp5 + tmp7;
    z5 = (z3 + z4) * (INT32 )9633;
    tmp4 = tmp4 * (INT32 )2446;
    tmp5 = tmp5 * (INT32 )16819;
    tmp6 = tmp6 * (INT32 )25172;
    tmp7 = tmp7 * (INT32 )12299;
    z1 = z1 * - (INT32 )7373;
    z2 = z2 * - (INT32 )20995;
    z3 = z3 * - (INT32 )16069;
    z4 = z4 * - (INT32 )3196;
    z3 += z5;
    z4 += z5;
    dataptr[8 * 7] = (DCTELEM )(tmp4 + z1 + z3 + ((INT32 )1 << 13 + 2 - 1) >> 13
      + 2);
    dataptr[8 * 5] = (DCTELEM )(tmp5 + z2 + z4 + ((INT32 )1 << 13 + 2 - 1) >> 13
      + 2);
    dataptr[8 * 3] = (DCTELEM )(tmp6 + z2 + z3 + ((INT32 )1 << 13 + 2 - 1) >> 13
      + 2);
    dataptr[8 * 1] = (DCTELEM )(tmp7 + z1 + z4 + ((INT32 )1 << 13 + 2 - 1) >> 13
      + 2);
    dataptr++;
  }
}


#pragma combiner("./jdapi.i", "-g -O -I/home/scott/wrk/safec/cil/lib ")

#pragma boxalloc("malloc", nozero, sizein(0))

#pragma boxalloc("alloca", nozero, sizein(0))

#pragma boxalloc("calloc", zero, sizemul(0, 1))

#pragma boxprintf("printf", 0)

#pragma boxprintf("fprintf", 1)

#pragma boxprintf("sprintf", 1)

#pragma boxprintf("snprintf", 2)

#pragma boxpoly("memcpy")

#pragma boxexported("main")
void jpeg_create_decompress(j_decompress_ptr cinfo )
{
  int i ; /*decdef*/
  {
    struct jpeg_error_mgr *  err = cinfo->err; /*decdef*/
    memset((void *  )cinfo, 0, (size_t )((size_t
      )sizeof(struct jpeg_decompress_struct )));
    cinfo->err = err;
  }
  cinfo->is_decompressor = 1;
  jinit_memory_mgr((j_common_ptr )cinfo);
  cinfo->progress = (void *  )0;
  cinfo->src = (void *  )0;
  for(i = 0; i < 4; i++)
    (cinfo->quant_tbl_ptrs)[i] = (void *  )0;
  for(i = 0; i < 4; i++)
  {
    (cinfo->dc_huff_tbl_ptrs)[i] = (void *  )0;
    (cinfo->ac_huff_tbl_ptrs)[i] = (void *  )0;
  }
  cinfo->sample_range_limit = (void *  )0;
  cinfo->marker = (void *  )0;
  jinit_marker_reader(cinfo);
  cinfo->global_state = 200;
}

void jpeg_destroy_decompress(j_decompress_ptr cinfo )
{
  jpeg_destroy((j_common_ptr )cinfo);
}

void jpeg_set_marker_processor(j_decompress_ptr cinfo , int marker_code ,
  jpeg_marker_parser_method routine )
{
  if(marker_code == 0xFE)
    (cinfo->marker)->process_COM = routine;
  else
  {
    if(marker_code >= 0xE0 && marker_code <= 0xE0 + 15)
      ((cinfo->marker)->process_APPn)[marker_code - 0xE0] = routine;
    else
      (cinfo->err)->msg_code = JERR_UNKNOWN_MARKER,
	(((cinfo->err)->msg_parm).i)[0] = marker_code, (*
	(cinfo->err)->error_exit)((j_common_ptr )cinfo);
  }
}

static void default_decompress_parms(j_decompress_ptr cinfo )
{
  switch(cinfo->num_components)
  {
  case 1:
      ;
    cinfo->jpeg_color_space = JCS_GRAYSCALE;
    cinfo->out_color_space = JCS_GRAYSCALE;
    break;
  case 3:
      ;
    if(cinfo->saw_JFIF_marker)
    {
      cinfo->jpeg_color_space = JCS_YCbCr;
    }
    else
    {
      if(cinfo->saw_Adobe_marker)
      {
	switch(cinfo->Adobe_transform)
	{
	case 0:
	    ;
	  cinfo->jpeg_color_space = JCS_RGB;
	  break;
	case 1:
	    ;
	  cinfo->jpeg_color_space = JCS_YCbCr;
	  break;
	default :
	    ;
	  (cinfo->err)->msg_code = JWRN_ADOBE_XFORM,
	    (((cinfo->err)->msg_parm).i)[0] = cinfo->Adobe_transform, (*
	    (cinfo->err)->emit_message)((j_common_ptr )cinfo, - 1);
	  cinfo->jpeg_color_space = JCS_YCbCr;
	  break;
	}
      }
      else
      {
	int cid0 = ((cinfo->comp_info)[0]).component_id; /*decdef*/
	int cid1 = ((cinfo->comp_info)[1]).component_id; /*decdef*/
	int cid2 = ((cinfo->comp_info)[2]).component_id; /*decdef*/
	if(cid0 == 1 && cid1 == 2 && cid2 == 3)
	  cinfo->jpeg_color_space = JCS_YCbCr;
	else
	{
	  if(cid0 == 82 && cid1 == 71 && cid2 == 66)
	    cinfo->jpeg_color_space = JCS_RGB;
	  else
	  {
	    do
	    {
	      int *  _mp = ((cinfo->err)->msg_parm).i; /*decdef*/
	      _mp[0] = cid0;
	      _mp[1] = cid1;
	      _mp[2] = cid2;
	      (cinfo->err)->msg_code = JTRC_UNKNOWN_IDS;
	      (* (cinfo->err)->emit_message)((j_common_ptr )cinfo, 1);
	    }
	    while(0);
	    cinfo->jpeg_color_space = JCS_YCbCr;
	  }
	}
      }
    }
    cinfo->out_color_space = JCS_RGB;
    break;
  case 4:
      ;
    if(cinfo->saw_Adobe_marker)
    {
      switch(cinfo->Adobe_transform)
      {
      case 0:
	  ;
	cinfo->jpeg_color_space = JCS_CMYK;
	break;
      case 2:
	  ;
	cinfo->jpeg_color_space = JCS_YCCK;
	break;
      default :
	  ;
	(cinfo->err)->msg_code = JWRN_ADOBE_XFORM,
	  (((cinfo->err)->msg_parm).i)[0] = cinfo->Adobe_transform, (*
	  (cinfo->err)->emit_message)((j_common_ptr )cinfo, - 1);
	cinfo->jpeg_color_space = JCS_YCCK;
	break;
      }
    }
    else
    {
      cinfo->jpeg_color_space = JCS_CMYK;
    }
    cinfo->out_color_space = JCS_CMYK;
    break;
  default :
      ;
    cinfo->jpeg_color_space = JCS_UNKNOWN;
    cinfo->out_color_space = JCS_UNKNOWN;
    break;
  }
  cinfo->scale_num = 1;
  cinfo->scale_denom = 1;
  cinfo->output_gamma = 1.0;
  cinfo->raw_data_out = 0;
  cinfo->quantize_colors = 0;
  cinfo->two_pass_quantize = 1;
  cinfo->dither_mode = JDITHER_FS;
  cinfo->desired_number_of_colors = 256;
  cinfo->colormap = (void *  )0;
  cinfo->dct_method = JDCT_ISLOW;
  cinfo->do_fancy_upsampling = 1;
}

int jpeg_read_header(j_decompress_ptr cinfo , boolean require_image )
{
  int retcode ; /*decdef*/
  if(cinfo->global_state == 200)
  {
    (* (cinfo->err)->reset_error_mgr)((j_common_ptr )cinfo);
    (* (cinfo->marker)->reset_marker_reader)(cinfo);
    (* (cinfo->src)->init_source)(cinfo);
    cinfo->global_state = 201;
  }
  else
  {
    if(cinfo->global_state != 201)
    {
      (cinfo->err)->msg_code = JERR_BAD_STATE, (((cinfo->err)->msg_parm).i)[0] =
	cinfo->global_state, (* (cinfo->err)->error_exit)((j_common_ptr )cinfo);
    }
  }
  retcode = (* (cinfo->marker)->read_markers)(cinfo);
  switch(retcode)
  {
  case 0:
      ;
    default_decompress_parms(cinfo);
    cinfo->global_state = 202;
    break;
  case 1:
      ;
    if((cinfo->marker)->saw_SOF)
      (cinfo->err)->msg_code = JERR_SOF_NO_SOS, (*
	(cinfo->err)->error_exit)((j_common_ptr )cinfo);
    if(require_image)
      (cinfo->err)->msg_code = JERR_NO_IMAGE, (*
	(cinfo->err)->error_exit)((j_common_ptr )cinfo);
    cinfo->global_state = 200;
    break;
  case 2:
      ;
    break;
  }
  return retcode;
}

void jpeg_start_decompress(j_decompress_ptr cinfo )
{
  JDIMENSION chunk_ctr , last_chunk_ctr ; /*decdef*/
  if(cinfo->global_state != 202)
    (cinfo->err)->msg_code = JERR_BAD_STATE, (((cinfo->err)->msg_parm).i)[0] =
      cinfo->global_state, (* (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  jinit_master_decompress(cinfo);
  for(; ; )
  {
    (* (cinfo->master)->prepare_for_pass)(cinfo);
    if((cinfo->master)->is_last_pass)
      break;
    chunk_ctr = 0;
    while(chunk_ctr < (cinfo->main)->num_chunks)
    {
      if(cinfo->progress != (void *  )0)
      {
	(cinfo->progress)->pass_counter = (long )chunk_ctr;
	(cinfo->progress)->pass_limit = (long )(cinfo->main)->num_chunks;
	(* (cinfo->progress)->progress_monitor)((j_common_ptr )cinfo);
      }
      last_chunk_ctr = chunk_ctr;
      (* (cinfo->main)->process_data)(cinfo, (JSAMPARRAY )((void *  )0), &
	chunk_ctr, (JDIMENSION )0);
      if(chunk_ctr == last_chunk_ctr)
	(cinfo->err)->msg_code = JERR_CANT_SUSPEND, (*
	  (cinfo->err)->error_exit)((j_common_ptr )cinfo);
    }
    (* (cinfo->master)->finish_pass)(cinfo);
  }
  cinfo->output_scanline = 0;
  cinfo->global_state = cinfo->raw_data_out ? 204 : 203;
}

JDIMENSION jpeg_read_scanlines(j_decompress_ptr cinfo , JSAMPARRAY scanlines ,
  JDIMENSION max_lines )
{
  JDIMENSION row_ctr ; /*decdef*/
  if(cinfo->global_state != 203)
    (cinfo->err)->msg_code = JERR_BAD_STATE, (((cinfo->err)->msg_parm).i)[0] =
      cinfo->global_state, (* (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  if(cinfo->output_scanline >= cinfo->output_height)
    (cinfo->err)->msg_code = JWRN_TOO_MUCH_DATA, (*
      (cinfo->err)->emit_message)((j_common_ptr )cinfo, - 1);
  if(cinfo->progress != (void *  )0)
  {
    (cinfo->progress)->pass_counter = (long )cinfo->output_scanline;
    (cinfo->progress)->pass_limit = (long )cinfo->output_height;
    (* (cinfo->progress)->progress_monitor)((j_common_ptr )cinfo);
  }
  row_ctr = 0;
  (* (cinfo->main)->process_data)(cinfo, scanlines, & row_ctr, max_lines);
  cinfo->output_scanline += row_ctr;
  return row_ctr;
}

JDIMENSION jpeg_read_raw_data(j_decompress_ptr cinfo , JSAMPIMAGE data ,
  JDIMENSION max_lines )
{
  JDIMENSION lines_per_MCU_row ; /*decdef*/
  if(cinfo->global_state != 204)
    (cinfo->err)->msg_code = JERR_BAD_STATE, (((cinfo->err)->msg_parm).i)[0] =
      cinfo->global_state, (* (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  if(cinfo->output_scanline >= cinfo->output_height)
  {
    (cinfo->err)->msg_code = JWRN_TOO_MUCH_DATA, (*
      (cinfo->err)->emit_message)((j_common_ptr )cinfo, - 1);
    return 0;
  }
  if(cinfo->progress != (void *  )0)
  {
    (cinfo->progress)->pass_counter = (long )cinfo->output_scanline;
    (cinfo->progress)->pass_limit = (long )cinfo->output_height;
    (* (cinfo->progress)->progress_monitor)((j_common_ptr )cinfo);
  }
  lines_per_MCU_row = cinfo->max_v_samp_factor * cinfo->min_DCT_scaled_size;
  if(max_lines < lines_per_MCU_row)
    (cinfo->err)->msg_code = JERR_BUFFER_SIZE, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  if(! (* (cinfo->coef)->decompress_data)(cinfo, data))
    return 0;
  cinfo->output_scanline += lines_per_MCU_row;
  return lines_per_MCU_row;
}

boolean jpeg_finish_decompress(j_decompress_ptr cinfo )
{
  if(cinfo->global_state == 203 || cinfo->global_state == 204)
  {
    if(cinfo->output_scanline < cinfo->output_height)
      (cinfo->err)->msg_code = JERR_TOO_LITTLE_DATA, (*
	(cinfo->err)->error_exit)((j_common_ptr )cinfo);
    (* (cinfo->master)->finish_pass)(cinfo);
    cinfo->global_state = 205;
  }
  else
  {
    if(cinfo->global_state != 205)
    {
      (cinfo->err)->msg_code = JERR_BAD_STATE, (((cinfo->err)->msg_parm).i)[0] =
	cinfo->global_state, (* (cinfo->err)->error_exit)((j_common_ptr )cinfo);
    }
  }
  if(! (cinfo->master)->eoi_processed)
  {
    switch((* (cinfo->marker)->read_markers)(cinfo))
    {
    case 0:
	;
      (cinfo->err)->msg_code = JERR_EOI_EXPECTED, (*
	(cinfo->err)->error_exit)((j_common_ptr )cinfo);
      break;
    case 1:
	;
      break;
    case 2:
	;
      return 0;
    }
  }
  (* (cinfo->src)->term_source)(cinfo);
  jpeg_abort((j_common_ptr )cinfo);
  return 1;
}

void jpeg_abort_decompress(j_decompress_ptr cinfo )
{
  jpeg_abort((j_common_ptr )cinfo);
}


#pragma combiner("./jdatasrc.i", "-g -O -I/home/scott/wrk/safec/cil/lib ")

#pragma boxalloc("malloc", nozero, sizein(0))

#pragma boxalloc("alloca", nozero, sizein(0))

#pragma boxalloc("calloc", zero, sizemul(0, 1))

#pragma boxprintf("printf", 0)

#pragma boxprintf("fprintf", 1)

#pragma boxprintf("sprintf", 1)

#pragma boxprintf("snprintf", 2)

#pragma boxpoly("memcpy")

#pragma boxexported("main")
typedef struct  {
  struct jpeg_source_mgr pub ;
  FILE *  infile ;
  JOCTET *  buffer ;
  boolean start_of_file ;
} my_source_mgr ; /*typedef*/

typedef my_source_mgr *  my_src_ptr ; /*typedef*/

static void init_source(j_decompress_ptr cinfo )
{
  my_src_ptr src = (my_src_ptr )cinfo->src; /*decdef*/
  src->start_of_file = 1;
}

static boolean fill_input_buffer(j_decompress_ptr cinfo )
{
  my_src_ptr src = (my_src_ptr )cinfo->src; /*decdef*/
  size_t nbytes ; /*decdef*/
  nbytes = (size_t )fread((void *  )src->buffer, (size_t )1, (size_t )4096,
    src->infile);
  if(nbytes <= 0)
  {
    if(src->start_of_file)
      (cinfo->err)->msg_code = JERR_INPUT_EMPTY, (*
	(cinfo->err)->error_exit)((j_common_ptr )cinfo);
    (cinfo->err)->msg_code = JWRN_JPEG_EOF, (*
      (cinfo->err)->emit_message)((j_common_ptr )cinfo, - 1);
    (src->buffer)[0] = (JOCTET )0xFF;
    (src->buffer)[1] = (JOCTET )0xD9;
    nbytes = 2;
  }
  (src->pub).next_input_byte = src->buffer;
  (src->pub).bytes_in_buffer = nbytes;
  src->start_of_file = 0;
  return 1;
}

static void skip_input_data(j_decompress_ptr cinfo , long num_bytes )
{
  my_src_ptr src = (my_src_ptr )cinfo->src; /*decdef*/
  if(num_bytes > 0)
  {
    while(num_bytes > (long )(src->pub).bytes_in_buffer)
    {
      num_bytes -= (long )(src->pub).bytes_in_buffer;
      (void )fill_input_buffer(cinfo);
    }
    (src->pub).next_input_byte += (size_t )num_bytes;
    (src->pub).bytes_in_buffer -= (size_t )num_bytes;
  }
}

static void term_source(j_decompress_ptr cinfo )
{
}

void jpeg_stdio_src(j_decompress_ptr cinfo , FILE *  infile )
{
  my_src_ptr src ; /*decdef*/
  if(cinfo->src == (void *  )0)
  {
    cinfo->src = (struct jpeg_source_mgr *  )(*
      (cinfo->mem)->alloc_small)((j_common_ptr )cinfo, 0, (size_t
      )sizeof(my_source_mgr ));
    src = (my_src_ptr )cinfo->src;
    src->buffer = (JOCTET *  )(* (cinfo->mem)->alloc_small)((j_common_ptr
      )cinfo, 0, 4096 * (size_t )sizeof(JOCTET ));
  }
  src = (my_src_ptr )cinfo->src;
  (src->pub).init_source = init_source;
  (src->pub).fill_input_buffer = fill_input_buffer;
  (src->pub).skip_input_data = skip_input_data;
  (src->pub).resync_to_restart = jpeg_resync_to_restart;
  (src->pub).term_source = term_source;
  src->infile = infile;
  (src->pub).bytes_in_buffer = 0;
  (src->pub).next_input_byte = (void *  )0;
}


#pragma combiner("./jdmaster.i", "-g -O -I/home/scott/wrk/safec/cil/lib ")

#pragma boxalloc("malloc", nozero, sizein(0))

#pragma boxalloc("alloca", nozero, sizein(0))

#pragma boxalloc("calloc", zero, sizemul(0, 1))

#pragma boxprintf("printf", 0)

#pragma boxprintf("fprintf", 1)

#pragma boxprintf("sprintf", 1)

#pragma boxprintf("snprintf", 2)

#pragma boxpoly("memcpy")

#pragma boxexported("main")
typedef enum  {
  main_pass,
  preread_pass,
  output_pass,
  post_pass
} D_PASS_TYPE ; /*typedef*/

typedef struct  {
  struct jpeg_decomp_master pub ;
  boolean using_merged_upsample ;
  D_PASS_TYPE pass_type ;
  int pass_number ;
  int total_passes ;
  boolean need_post_pass ;
} my_decomp_master ; /*typedef*/

typedef my_decomp_master *  my_master_ptr__0 ; /*typedef*/

static boolean use_merged_upsample(j_decompress_ptr cinfo )
{
  if(cinfo->do_fancy_upsampling || cinfo->CCIR601_sampling)
    return 0;
  if(cinfo->jpeg_color_space != JCS_YCbCr || cinfo->num_components != 3 ||
    cinfo->out_color_space != JCS_RGB || cinfo->out_color_components != 3)
    return 0;
  if(((cinfo->comp_info)[0]).h_samp_factor != 2 ||
    ((cinfo->comp_info)[1]).h_samp_factor != 1 ||
    ((cinfo->comp_info)[2]).h_samp_factor != 1 ||
    ((cinfo->comp_info)[0]).v_samp_factor > 2 ||
    ((cinfo->comp_info)[1]).v_samp_factor != 1 ||
    ((cinfo->comp_info)[2]).v_samp_factor != 1)
    return 0;
  if(((cinfo->comp_info)[0]).DCT_scaled_size != cinfo->min_DCT_scaled_size ||
    ((cinfo->comp_info)[1]).DCT_scaled_size != cinfo->min_DCT_scaled_size ||
    ((cinfo->comp_info)[2]).DCT_scaled_size != cinfo->min_DCT_scaled_size)
    return 0;
  return 1;
}

void jpeg_calc_output_dimensions(j_decompress_ptr cinfo )
{
  int ci ; /*decdef*/
  jpeg_component_info *  compptr ; /*decdef*/
  cinfo->max_h_samp_factor = 1;
  cinfo->max_v_samp_factor = 1;
  for(ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components; ci++,
    compptr++)
  {
    if(compptr->h_samp_factor <= 0 || compptr->h_samp_factor > 4 ||
      compptr->v_samp_factor <= 0 || compptr->v_samp_factor > 4)
      (cinfo->err)->msg_code = JERR_BAD_SAMPLING, (*
	(cinfo->err)->error_exit)((j_common_ptr )cinfo);
    cinfo->max_h_samp_factor = cinfo->max_h_samp_factor > compptr->h_samp_factor
      ? cinfo->max_h_samp_factor : compptr->h_samp_factor;
    cinfo->max_v_samp_factor = cinfo->max_v_samp_factor > compptr->v_samp_factor
      ? cinfo->max_v_samp_factor : compptr->v_samp_factor;
  }
  if(cinfo->scale_num * 8 <= cinfo->scale_denom)
  {
    cinfo->output_width = (JDIMENSION )jdiv_round_up((long )cinfo->image_width,
      8L);
    cinfo->output_height = (JDIMENSION
      )jdiv_round_up((long )cinfo->image_height, 8L);
    cinfo->min_DCT_scaled_size = 1;
  }
  else
  {
    if(cinfo->scale_num * 4 <= cinfo->scale_denom)
    {
      cinfo->output_width = (JDIMENSION
	)jdiv_round_up((long )cinfo->image_width, 4L);
      cinfo->output_height = (JDIMENSION
	)jdiv_round_up((long )cinfo->image_height, 4L);
      cinfo->min_DCT_scaled_size = 2;
    }
    else
    {
      if(cinfo->scale_num * 2 <= cinfo->scale_denom)
      {
	cinfo->output_width = (JDIMENSION
	  )jdiv_round_up((long )cinfo->image_width, 2L);
	cinfo->output_height = (JDIMENSION
	  )jdiv_round_up((long )cinfo->image_height, 2L);
	cinfo->min_DCT_scaled_size = 4;
      }
      else
      {
	cinfo->output_width = cinfo->image_width;
	cinfo->output_height = cinfo->image_height;
	cinfo->min_DCT_scaled_size = 8;
      }
    }
  }
  for(ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components; ci++,
    compptr++)
  {
    int ssize = cinfo->min_DCT_scaled_size; /*decdef*/
    while(ssize < 8 && compptr->h_samp_factor * ssize * 2 <=
      cinfo->max_h_samp_factor * cinfo->min_DCT_scaled_size &&
      compptr->v_samp_factor * ssize * 2 <= cinfo->max_v_samp_factor *
      cinfo->min_DCT_scaled_size)
    {
      ssize = ssize * 2;
    }
    compptr->DCT_scaled_size = ssize;
  }
  switch(cinfo->out_color_space)
  {
  case JCS_GRAYSCALE:
      ;
    cinfo->out_color_components = 1;
    break;
  case JCS_RGB:
      ;
  case JCS_YCbCr:
      ;
    cinfo->out_color_components = 3;
    break;
  case JCS_CMYK:
      ;
  case JCS_YCCK:
      ;
    cinfo->out_color_components = 4;
    break;
  default :
      ;
    cinfo->out_color_components = cinfo->num_components;
    break;
  }
  cinfo->output_components = cinfo->quantize_colors ? 1
    : cinfo->out_color_components;
  if(use_merged_upsample(cinfo))
    cinfo->rec_outbuf_height = cinfo->max_v_samp_factor;
  else
    cinfo->rec_outbuf_height = 1;
  for(ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components; ci++,
    compptr++)
  {
    compptr->width_in_blocks = (JDIMENSION
      )jdiv_round_up((long )cinfo->image_width * (long )compptr->h_samp_factor,
      (long )(cinfo->max_h_samp_factor * 8));
    compptr->height_in_blocks = (JDIMENSION
      )jdiv_round_up((long )cinfo->image_height * (long )compptr->v_samp_factor,
      (long )(cinfo->max_v_samp_factor * 8));
    compptr->downsampled_width = (JDIMENSION
      )jdiv_round_up((long )cinfo->image_width * (long )(compptr->h_samp_factor
      * compptr->DCT_scaled_size), (long )(cinfo->max_h_samp_factor * 8));
    compptr->downsampled_height = (JDIMENSION
      )jdiv_round_up((long )cinfo->image_height * (long )(compptr->v_samp_factor
      * compptr->DCT_scaled_size), (long )(cinfo->max_v_samp_factor * 8));
    compptr->component_needed = 1;
  }
  cinfo->total_iMCU_rows = (JDIMENSION
    )jdiv_round_up((long )cinfo->image_height, (long )(cinfo->max_v_samp_factor
    * 8));
}

static void per_scan_setup__0(j_decompress_ptr cinfo )
{
  int ci , mcublks , tmp ; /*decdef*/
  jpeg_component_info *  compptr ; /*decdef*/
  if(cinfo->comps_in_scan == 1)
  {
    compptr = (cinfo->cur_comp_info)[0];
    cinfo->MCUs_per_row = compptr->width_in_blocks;
    cinfo->MCU_rows_in_scan = compptr->height_in_blocks;
    compptr->MCU_width = 1;
    compptr->MCU_height = 1;
    compptr->MCU_blocks = 1;
    compptr->MCU_sample_width = compptr->DCT_scaled_size;
    compptr->last_col_width = 1;
    compptr->last_row_height = 1;
    cinfo->blocks_in_MCU = 1;
    (cinfo->MCU_membership)[0] = 0;
  }
  else
  {
    if(cinfo->comps_in_scan <= 0 || cinfo->comps_in_scan > 4)
      (cinfo->err)->msg_code = JERR_COMPONENT_COUNT,
	(((cinfo->err)->msg_parm).i)[0] = cinfo->comps_in_scan,
	(((cinfo->err)->msg_parm).i)[1] = 4, (*
	(cinfo->err)->error_exit)((j_common_ptr )cinfo);
    cinfo->MCUs_per_row = (JDIMENSION )jdiv_round_up((long )cinfo->image_width,
      (long )(cinfo->max_h_samp_factor * 8));
    cinfo->MCU_rows_in_scan = (JDIMENSION
      )jdiv_round_up((long )cinfo->image_height,
      (long )(cinfo->max_v_samp_factor * 8));
    cinfo->blocks_in_MCU = 0;
    for(ci = 0; ci < cinfo->comps_in_scan; ci++)
    {
      compptr = (cinfo->cur_comp_info)[ci];
      compptr->MCU_width = compptr->h_samp_factor;
      compptr->MCU_height = compptr->v_samp_factor;
      compptr->MCU_blocks = compptr->MCU_width * compptr->MCU_height;
      compptr->MCU_sample_width = compptr->MCU_width * compptr->DCT_scaled_size;
      tmp = (int )(compptr->width_in_blocks % compptr->MCU_width);
      if(tmp == 0)
	tmp = compptr->MCU_width;
      compptr->last_col_width = tmp;
      tmp = (int )(compptr->height_in_blocks % compptr->MCU_height);
      if(tmp == 0)
	tmp = compptr->MCU_height;
      compptr->last_row_height = tmp;
      mcublks = compptr->MCU_blocks;
      if(cinfo->blocks_in_MCU + mcublks > 10)
	(cinfo->err)->msg_code = JERR_BAD_MCU_SIZE, (*
	  (cinfo->err)->error_exit)((j_common_ptr )cinfo);
      while(mcublks-- > 0)
      {
	(cinfo->MCU_membership)[cinfo->blocks_in_MCU++] = ci;
      }
    }
  }
}

static void prepare_range_limit_table(j_decompress_ptr cinfo )
{
  JSAMPLE *  table ; /*decdef*/
  int i ; /*decdef*/
  table = (JSAMPLE *  )(* (cinfo->mem)->alloc_small)((j_common_ptr )cinfo, 1, (5
    * (255 + 1) + 128) * (size_t )sizeof(JSAMPLE ));
  table += 255 + 1;
  cinfo->sample_range_limit = table;
  memset((void *  )(table - (255 + 1)), 0, (size_t )((255 + 1) * (size_t
    )sizeof(JSAMPLE )));
  for(i = 0; i <= 255; i++)
    table[i] = (JSAMPLE )i;
  table += 128;
  for(i = 128; i < 2 * (255 + 1); i++)
    table[i] = 255;
  memset((void *  )(table + 2 * (255 + 1)), 0, (size_t )((2 * (255 + 1) - 128) *
    (size_t )sizeof(JSAMPLE )));
  memcpy((void *  )(table + (4 * (255 + 1) - 128)), (const void * 
    )cinfo->sample_range_limit, (size_t )(128 * (size_t )sizeof(JSAMPLE )));
}

static void master_selection__0(j_decompress_ptr cinfo )
{
  my_master_ptr__0 master = (my_master_ptr__0 )cinfo->master; /*decdef*/
  long samplesperrow ; /*decdef*/
  JDIMENSION jd_samplesperrow ; /*decdef*/
  jpeg_calc_output_dimensions(cinfo);
  prepare_range_limit_table(cinfo);
  samplesperrow = (long )cinfo->output_width *
    (long )cinfo->out_color_components;
  jd_samplesperrow = (JDIMENSION )samplesperrow;
  if((long )jd_samplesperrow != samplesperrow)
    (cinfo->err)->msg_code = JERR_WIDTH_OVERFLOW, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  (master->pub).eoi_processed = 0;
  master->pass_number = 0;
  master->need_post_pass = 0;
  if(cinfo->comps_in_scan == cinfo->num_components)
  {
    master->pass_type = main_pass;
    master->total_passes = 1;
  }
  else
  {
    master->pass_type = preread_pass;
    master->total_passes = cinfo->num_components + 1;
  }
  master->using_merged_upsample = use_merged_upsample(cinfo);
  if(cinfo->quantize_colors)
  {
    if(cinfo->raw_data_out)
      (cinfo->err)->msg_code = JERR_NOTIMPL, (*
	(cinfo->err)->error_exit)((j_common_ptr )cinfo);
    if(cinfo->out_color_components != 3)
      cinfo->two_pass_quantize = 0;
    else
    {
      if(cinfo->colormap != (void *  )0)
	cinfo->two_pass_quantize = 1;
    }
    if(cinfo->two_pass_quantize)
    {
      if(cinfo->colormap == (void *  )0)
      {
	master->need_post_pass = 1;
	master->total_passes++;
      }
      jinit_2pass_quantizer(cinfo);
    }
    else
    {
      jinit_1pass_quantizer(cinfo);
    }
  }
  if(! cinfo->raw_data_out)
  {
    if(master->using_merged_upsample)
    {
      jinit_merged_upsampler(cinfo);
    }
    else
    {
      jinit_color_deconverter(cinfo);
      jinit_upsampler(cinfo);
    }
    jinit_d_post_controller(cinfo, master->need_post_pass);
  }
  jinit_inverse_dct(cinfo);
  if(cinfo->arith_code)
  {
    (cinfo->err)->msg_code = JERR_ARITH_NOTIMPL, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  }
  else
    jinit_huff_decoder(cinfo);
  jinit_d_coef_controller(cinfo, master->pass_type == preread_pass);
  jinit_d_main_controller(cinfo, 0);
  (* (cinfo->mem)->realize_virt_arrays)((j_common_ptr )cinfo);
}

static void prepare_for_pass__0(j_decompress_ptr cinfo )
{
  my_master_ptr__0 master = (my_master_ptr__0 )cinfo->master; /*decdef*/
  switch(master->pass_type)
  {
  case main_pass:
      ;
    per_scan_setup__0(cinfo);
    (master->pub).is_last_pass = ! master->need_post_pass;
    if(! cinfo->raw_data_out)
    {
      if(! master->using_merged_upsample)
	(* (cinfo->cconvert)->start_pass)(cinfo);
      (* (cinfo->upsample)->start_pass)(cinfo);
      if(cinfo->quantize_colors)
	(* (cinfo->cquantize)->start_pass)(cinfo, master->need_post_pass);
      (* (cinfo->post)->start_pass)(cinfo, master->need_post_pass
	? JBUF_SAVE_AND_PASS : JBUF_PASS_THRU);
    }
    (* (cinfo->idct)->start_input_pass)(cinfo);
    (* (cinfo->idct)->start_output_pass)(cinfo);
    (* (cinfo->entropy)->start_pass)(cinfo);
    (* (cinfo->coef)->start_pass)(cinfo, JBUF_PASS_THRU);
    (* (cinfo->main)->start_pass)(cinfo, JBUF_PASS_THRU);
    break;
  case preread_pass:
      ;
    per_scan_setup__0(cinfo);
    (master->pub).is_last_pass = 0;
    (* (cinfo->idct)->start_input_pass)(cinfo);
    (* (cinfo->entropy)->start_pass)(cinfo);
    (* (cinfo->coef)->start_pass)(cinfo, JBUF_SAVE_SOURCE);
    (* (cinfo->main)->start_pass)(cinfo, JBUF_CRANK_SOURCE);
    break;
  case output_pass:
      ;
    (master->pub).is_last_pass = ! master->need_post_pass;
    if(! cinfo->raw_data_out)
    {
      if(! master->using_merged_upsample)
	(* (cinfo->cconvert)->start_pass)(cinfo);
      (* (cinfo->upsample)->start_pass)(cinfo);
      if(cinfo->quantize_colors)
	(* (cinfo->cquantize)->start_pass)(cinfo, master->need_post_pass);
      (* (cinfo->post)->start_pass)(cinfo, master->need_post_pass
	? JBUF_SAVE_AND_PASS : JBUF_PASS_THRU);
    }
    (* (cinfo->idct)->start_output_pass)(cinfo);
    (* (cinfo->coef)->start_pass)(cinfo, JBUF_CRANK_DEST);
    (* (cinfo->main)->start_pass)(cinfo, JBUF_PASS_THRU);
    break;
  case post_pass:
      ;
    (master->pub).is_last_pass = 1;
    (* (cinfo->cquantize)->start_pass)(cinfo, 0);
    (* (cinfo->post)->start_pass)(cinfo, JBUF_CRANK_DEST);
    (* (cinfo->main)->start_pass)(cinfo, JBUF_CRANK_DEST);
    break;
  default :
      ;
    (cinfo->err)->msg_code = JERR_NOT_COMPILED, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  }
  if(cinfo->progress != (void *  )0)
  {
    (cinfo->progress)->completed_passes = master->pass_number;
    (cinfo->progress)->total_passes = master->total_passes;
  }
}

static void finish_pass_master__0(j_decompress_ptr cinfo )
{
  my_master_ptr__0 master = (my_master_ptr__0 )cinfo->master; /*decdef*/
  switch(master->pass_type)
  {
  case main_pass:
      ;
  case output_pass:
      ;
    if(cinfo->quantize_colors)
      (* (cinfo->cquantize)->finish_pass)(cinfo);
    master->pass_number++;
    master->pass_type = post_pass;
    break;
  case preread_pass:
      ;
    master->pass_number += cinfo->comps_in_scan;
    switch((* (cinfo->marker)->read_markers)(cinfo))
    {
    case 0:
	;
      break;
    case 1:
	;
      (master->pub).eoi_processed = 1;
      master->pass_type = output_pass;
      break;
    case 2:
	;
      (cinfo->err)->msg_code = JERR_CANT_SUSPEND, (*
	(cinfo->err)->error_exit)((j_common_ptr )cinfo);
    }
    break;
  case post_pass:
      ;
    (* (cinfo->cquantize)->finish_pass)(cinfo);
    break;
  default :
      ;
    (cinfo->err)->msg_code = JERR_NOT_COMPILED, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  }
}

void jinit_master_decompress(j_decompress_ptr cinfo )
{
  my_master_ptr__0 master ; /*decdef*/
  master = (my_master_ptr__0 )(* (cinfo->mem)->alloc_small)((j_common_ptr
    )cinfo, 1, (size_t )sizeof(my_decomp_master ));
  cinfo->master = (struct jpeg_decomp_master *  )master;
  (master->pub).prepare_for_pass = prepare_for_pass__0;
  (master->pub).finish_pass = finish_pass_master__0;
  master_selection__0(cinfo);
}


#pragma combiner("./jdmarker.i", "-g -O -I/home/scott/wrk/safec/cil/lib ")

#pragma boxalloc("malloc", nozero, sizein(0))

#pragma boxalloc("alloca", nozero, sizein(0))

#pragma boxalloc("calloc", zero, sizemul(0, 1))

#pragma boxprintf("printf", 0)

#pragma boxprintf("fprintf", 1)

#pragma boxprintf("sprintf", 1)

#pragma boxprintf("snprintf", 2)

#pragma boxpoly("memcpy")

#pragma boxexported("main")
static boolean get_soi(j_decompress_ptr cinfo )
{
  int i ; /*decdef*/
  (cinfo->err)->msg_code = JTRC_SOI, (*
    (cinfo->err)->emit_message)((j_common_ptr )cinfo, 1);
  if((cinfo->marker)->saw_SOI)
    (cinfo->err)->msg_code = JERR_SOI_DUPLICATE, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  for(i = 0; i < 16; i++)
  {
    (cinfo->arith_dc_L)[i] = 0;
    (cinfo->arith_dc_U)[i] = 1;
    (cinfo->arith_ac_K)[i] = 5;
  }
  cinfo->restart_interval = 0;
  cinfo->jpeg_color_space = JCS_UNKNOWN;
  cinfo->CCIR601_sampling = 0;
  cinfo->saw_JFIF_marker = 0;
  cinfo->density_unit = 0;
  cinfo->X_density = 1;
  cinfo->Y_density = 1;
  cinfo->saw_Adobe_marker = 0;
  cinfo->Adobe_transform = 0;
  (cinfo->marker)->saw_SOI = 1;
  return 1;
}

static boolean get_sof(j_decompress_ptr cinfo )
{
  INT32 length ; /*decdef*/
  int c , ci ; /*decdef*/
  jpeg_component_info *  compptr ; /*decdef*/
  struct jpeg_source_mgr *  datasrc = cinfo->src; /*decdef*/
  const JOCTET *  next_input_byte = datasrc->next_input_byte; /*decdef*/
  size_t bytes_in_buffer = datasrc->bytes_in_buffer; /*decdef*/
  do
  {
    if(bytes_in_buffer == 0)
    {
      if(! (* datasrc->fill_input_buffer)(cinfo))
      {
	return 0;
      }
      next_input_byte = datasrc->next_input_byte, bytes_in_buffer =
	datasrc->bytes_in_buffer;
    }
    bytes_in_buffer--;
    length = (unsigned int )(* next_input_byte++) << 8;
    if(bytes_in_buffer == 0)
    {
      if(! (* datasrc->fill_input_buffer)(cinfo))
      {
	return 0;
      }
      next_input_byte = datasrc->next_input_byte, bytes_in_buffer =
	datasrc->bytes_in_buffer;
    }
    bytes_in_buffer--;
    length += * next_input_byte++;
  }
  while(0);
  do
  {
    if(bytes_in_buffer == 0)
    {
      if(! (* datasrc->fill_input_buffer)(cinfo))
      {
	return 0;
      }
      next_input_byte = datasrc->next_input_byte, bytes_in_buffer =
	datasrc->bytes_in_buffer;
    }
    bytes_in_buffer--;
    cinfo->data_precision = * next_input_byte++;
  }
  while(0);
  do
  {
    if(bytes_in_buffer == 0)
    {
      if(! (* datasrc->fill_input_buffer)(cinfo))
      {
	return 0;
      }
      next_input_byte = datasrc->next_input_byte, bytes_in_buffer =
	datasrc->bytes_in_buffer;
    }
    bytes_in_buffer--;
    cinfo->image_height = (unsigned int )(* next_input_byte++) << 8;
    if(bytes_in_buffer == 0)
    {
      if(! (* datasrc->fill_input_buffer)(cinfo))
      {
	return 0;
      }
      next_input_byte = datasrc->next_input_byte, bytes_in_buffer =
	datasrc->bytes_in_buffer;
    }
    bytes_in_buffer--;
    cinfo->image_height += * next_input_byte++;
  }
  while(0);
  do
  {
    if(bytes_in_buffer == 0)
    {
      if(! (* datasrc->fill_input_buffer)(cinfo))
      {
	return 0;
      }
      next_input_byte = datasrc->next_input_byte, bytes_in_buffer =
	datasrc->bytes_in_buffer;
    }
    bytes_in_buffer--;
    cinfo->image_width = (unsigned int )(* next_input_byte++) << 8;
    if(bytes_in_buffer == 0)
    {
      if(! (* datasrc->fill_input_buffer)(cinfo))
      {
	return 0;
      }
      next_input_byte = datasrc->next_input_byte, bytes_in_buffer =
	datasrc->bytes_in_buffer;
    }
    bytes_in_buffer--;
    cinfo->image_width += * next_input_byte++;
  }
  while(0);
  do
  {
    if(bytes_in_buffer == 0)
    {
      if(! (* datasrc->fill_input_buffer)(cinfo))
      {
	return 0;
      }
      next_input_byte = datasrc->next_input_byte, bytes_in_buffer =
	datasrc->bytes_in_buffer;
    }
    bytes_in_buffer--;
    cinfo->num_components = * next_input_byte++;
  }
  while(0);
  length -= 8;
  do
  {
    int *  _mp = ((cinfo->err)->msg_parm).i; /*decdef*/
    _mp[0] = cinfo->unread_marker;
    _mp[1] = (int )cinfo->image_width;
    _mp[2] = (int )cinfo->image_height;
    _mp[3] = cinfo->num_components;
    (cinfo->err)->msg_code = JTRC_SOF;
    (* (cinfo->err)->emit_message)((j_common_ptr )cinfo, 1);
  }
  while(0);
  if((cinfo->marker)->saw_SOF)
    (cinfo->err)->msg_code = JERR_SOF_DUPLICATE, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  if(cinfo->image_height <= 0 || cinfo->image_width <= 0 ||
    cinfo->num_components <= 0)
    (cinfo->err)->msg_code = JERR_EMPTY_IMAGE, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  if((long )cinfo->image_height > (long )65500L || (long )cinfo->image_width >
    (long )65500L)
    (cinfo->err)->msg_code = JERR_IMAGE_TOO_BIG, (((cinfo->err)->msg_parm).i)[0]
      = (unsigned int )65500L, (* (cinfo->err)->error_exit)((j_common_ptr
      )cinfo);
  if(cinfo->data_precision != 8)
    (cinfo->err)->msg_code = JERR_BAD_PRECISION, (((cinfo->err)->msg_parm).i)[0]
      = cinfo->data_precision, (* (cinfo->err)->error_exit)((j_common_ptr
      )cinfo);
  if(cinfo->num_components > 10)
    (cinfo->err)->msg_code = JERR_COMPONENT_COUNT,
      (((cinfo->err)->msg_parm).i)[0] = cinfo->num_components,
      (((cinfo->err)->msg_parm).i)[1] = 10, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  if(length != cinfo->num_components * 3)
    (cinfo->err)->msg_code = JERR_BAD_LENGTH, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  if(cinfo->comp_info == (void *  )0)
    cinfo->comp_info = (jpeg_component_info *  )(*
      (cinfo->mem)->alloc_small)((j_common_ptr )cinfo, 1, cinfo->num_components
      * (size_t )sizeof(jpeg_component_info ));
  for(ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components; ci++,
    compptr++)
  {
    compptr->component_index = ci;
    do
    {
      if(bytes_in_buffer == 0)
      {
	if(! (* datasrc->fill_input_buffer)(cinfo))
	{
	  return 0;
	}
	next_input_byte = datasrc->next_input_byte, bytes_in_buffer =
	  datasrc->bytes_in_buffer;
      }
      bytes_in_buffer--;
      compptr->component_id = * next_input_byte++;
    }
    while(0);
    do
    {
      if(bytes_in_buffer == 0)
      {
	if(! (* datasrc->fill_input_buffer)(cinfo))
	{
	  return 0;
	}
	next_input_byte = datasrc->next_input_byte, bytes_in_buffer =
	  datasrc->bytes_in_buffer;
      }
      bytes_in_buffer--;
      c = * next_input_byte++;
    }
    while(0);
    compptr->h_samp_factor = c >> 4 & 15;
    compptr->v_samp_factor = c & 15;
    do
    {
      if(bytes_in_buffer == 0)
      {
	if(! (* datasrc->fill_input_buffer)(cinfo))
	{
	  return 0;
	}
	next_input_byte = datasrc->next_input_byte, bytes_in_buffer =
	  datasrc->bytes_in_buffer;
      }
      bytes_in_buffer--;
      compptr->quant_tbl_no = * next_input_byte++;
    }
    while(0);
    do
    {
      int *  _mp = ((cinfo->err)->msg_parm).i; /*decdef*/
      _mp[0] = compptr->component_id;
      _mp[1] = compptr->h_samp_factor;
      _mp[2] = compptr->v_samp_factor;
      _mp[3] = compptr->quant_tbl_no;
      (cinfo->err)->msg_code = JTRC_SOF_COMPONENT;
      (* (cinfo->err)->emit_message)((j_common_ptr )cinfo, 1);
    }
    while(0);
  }
  (cinfo->marker)->saw_SOF = 1;
  datasrc->next_input_byte = next_input_byte, datasrc->bytes_in_buffer =
    bytes_in_buffer;
  return 1;
}

static boolean get_sos(j_decompress_ptr cinfo )
{
  INT32 length ; /*decdef*/
  int i , ci , n , c , cc , ccc ; /*decdef*/
  jpeg_component_info *  compptr ; /*decdef*/
  struct jpeg_source_mgr *  datasrc = cinfo->src; /*decdef*/
  const JOCTET *  next_input_byte = datasrc->next_input_byte; /*decdef*/
  size_t bytes_in_buffer = datasrc->bytes_in_buffer; /*decdef*/
  if(! (cinfo->marker)->saw_SOF)
    (cinfo->err)->msg_code = JERR_SOS_NO_SOF, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  do
  {
    if(bytes_in_buffer == 0)
    {
      if(! (* datasrc->fill_input_buffer)(cinfo))
      {
	return 0;
      }
      next_input_byte = datasrc->next_input_byte, bytes_in_buffer =
	datasrc->bytes_in_buffer;
    }
    bytes_in_buffer--;
    length = (unsigned int )(* next_input_byte++) << 8;
    if(bytes_in_buffer == 0)
    {
      if(! (* datasrc->fill_input_buffer)(cinfo))
      {
	return 0;
      }
      next_input_byte = datasrc->next_input_byte, bytes_in_buffer =
	datasrc->bytes_in_buffer;
    }
    bytes_in_buffer--;
    length += * next_input_byte++;
  }
  while(0);
  do
  {
    if(bytes_in_buffer == 0)
    {
      if(! (* datasrc->fill_input_buffer)(cinfo))
      {
	return 0;
      }
      next_input_byte = datasrc->next_input_byte, bytes_in_buffer =
	datasrc->bytes_in_buffer;
    }
    bytes_in_buffer--;
    n = * next_input_byte++;
  }
  while(0);
  if(length != n * 2 + 6 || n < 1 || n > 4)
    (cinfo->err)->msg_code = JERR_BAD_LENGTH, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  (cinfo->err)->msg_code = JTRC_SOS, (((cinfo->err)->msg_parm).i)[0] = n, (*
    (cinfo->err)->emit_message)((j_common_ptr )cinfo, 1);
  cinfo->comps_in_scan = n;
  for(i = 0; i < n; i++)
  {
    do
    {
      if(bytes_in_buffer == 0)
      {
	if(! (* datasrc->fill_input_buffer)(cinfo))
	{
	  return 0;
	}
	next_input_byte = datasrc->next_input_byte, bytes_in_buffer =
	  datasrc->bytes_in_buffer;
      }
      bytes_in_buffer--;
      cc = * next_input_byte++;
    }
    while(0);
    do
    {
      if(bytes_in_buffer == 0)
      {
	if(! (* datasrc->fill_input_buffer)(cinfo))
	{
	  return 0;
	}
	next_input_byte = datasrc->next_input_byte, bytes_in_buffer =
	  datasrc->bytes_in_buffer;
      }
      bytes_in_buffer--;
      c = * next_input_byte++;
    }
    while(0);
    for(ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components; ci++,
      compptr++)
    {
      if(cc == compptr->component_id)
	goto id_found;
    }
    (cinfo->err)->msg_code = JERR_BAD_COMPONENT_ID,
      (((cinfo->err)->msg_parm).i)[0] = cc, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
    id_found:
      (cinfo->cur_comp_info)[i] = compptr;
    compptr->dc_tbl_no = c >> 4 & 15;
    compptr->ac_tbl_no = c & 15;
    do
    {
      int *  _mp = ((cinfo->err)->msg_parm).i; /*decdef*/
      _mp[0] = cc;
      _mp[1] = compptr->dc_tbl_no;
      _mp[2] = compptr->ac_tbl_no;
      (cinfo->err)->msg_code = JTRC_SOS_COMPONENT;
      (* (cinfo->err)->emit_message)((j_common_ptr )cinfo, 1);
    }
    while(0);
  }
  do
  {
    if(bytes_in_buffer == 0)
    {
      if(! (* datasrc->fill_input_buffer)(cinfo))
      {
	return 0;
      }
      next_input_byte = datasrc->next_input_byte, bytes_in_buffer =
	datasrc->bytes_in_buffer;
    }
    bytes_in_buffer--;
    c = * next_input_byte++;
  }
  while(0);
  do
  {
    if(bytes_in_buffer == 0)
    {
      if(! (* datasrc->fill_input_buffer)(cinfo))
      {
	return 0;
      }
      next_input_byte = datasrc->next_input_byte, bytes_in_buffer =
	datasrc->bytes_in_buffer;
    }
    bytes_in_buffer--;
    cc = * next_input_byte++;
  }
  while(0);
  do
  {
    if(bytes_in_buffer == 0)
    {
      if(! (* datasrc->fill_input_buffer)(cinfo))
      {
	return 0;
      }
      next_input_byte = datasrc->next_input_byte, bytes_in_buffer =
	datasrc->bytes_in_buffer;
    }
    bytes_in_buffer--;
    ccc = * next_input_byte++;
  }
  while(0);
  if(c != 0 || cc != 64 - 1 || ccc != 0)
    (cinfo->err)->msg_code = JWRN_NOT_SEQUENTIAL, (*
      (cinfo->err)->emit_message)((j_common_ptr )cinfo, - 1);
  (cinfo->marker)->next_restart_num = 0;
  datasrc->next_input_byte = next_input_byte, datasrc->bytes_in_buffer =
    bytes_in_buffer;
  return 1;
}

static boolean get_app0(j_decompress_ptr cinfo )
{
  INT32 length ; /*decdef*/
  UINT8 b[14] ; /*decdef*/
  int buffp ; /*decdef*/
  struct jpeg_source_mgr *  datasrc = cinfo->src; /*decdef*/
  const JOCTET *  next_input_byte = datasrc->next_input_byte; /*decdef*/
  size_t bytes_in_buffer = datasrc->bytes_in_buffer; /*decdef*/
  do
  {
    if(bytes_in_buffer == 0)
    {
      if(! (* datasrc->fill_input_buffer)(cinfo))
      {
	return 0;
      }
      next_input_byte = datasrc->next_input_byte, bytes_in_buffer =
	datasrc->bytes_in_buffer;
    }
    bytes_in_buffer--;
    length = (unsigned int )(* next_input_byte++) << 8;
    if(bytes_in_buffer == 0)
    {
      if(! (* datasrc->fill_input_buffer)(cinfo))
      {
	return 0;
      }
      next_input_byte = datasrc->next_input_byte, bytes_in_buffer =
	datasrc->bytes_in_buffer;
    }
    bytes_in_buffer--;
    length += * next_input_byte++;
  }
  while(0);
  length -= 2;
  if(length >= 14)
  {
    for(buffp = 0; buffp < 14; buffp++)
    {
      do
      {
	if(bytes_in_buffer == 0)
	{
	  if(! (* datasrc->fill_input_buffer)(cinfo))
	  {
	    return 0;
	  }
	  next_input_byte = datasrc->next_input_byte, bytes_in_buffer =
	    datasrc->bytes_in_buffer;
	}
	bytes_in_buffer--;
	b[buffp] = * next_input_byte++;
      }
      while(0);
    }
    length -= 14;
    if(b[0] == 0x4A && b[1] == 0x46 && b[2] == 0x49 && b[3] == 0x46 && b[4] ==
      0)
    {
      if(b[5] != 1)
	(cinfo->err)->msg_code = JERR_JFIF_MAJOR,
	  (((cinfo->err)->msg_parm).i)[0] = b[5],
	  (((cinfo->err)->msg_parm).i)[1] = b[6], (*
	  (cinfo->err)->error_exit)((j_common_ptr )cinfo);
      if(b[6] > 2)
	(cinfo->err)->msg_code = JTRC_JFIF_MINOR,
	  (((cinfo->err)->msg_parm).i)[0] = b[5],
	  (((cinfo->err)->msg_parm).i)[1] = b[6], (*
	  (cinfo->err)->emit_message)((j_common_ptr )cinfo, 1);
      cinfo->saw_JFIF_marker = 1;
      cinfo->density_unit = b[7];
      cinfo->X_density = (b[8] << 8) + b[9];
      cinfo->Y_density = (b[10] << 8) + b[11];
      do
      {
	int *  _mp = ((cinfo->err)->msg_parm).i; /*decdef*/
	_mp[0] = cinfo->X_density;
	_mp[1] = cinfo->Y_density;
	_mp[2] = cinfo->density_unit;
	(cinfo->err)->msg_code = JTRC_JFIF;
	(* (cinfo->err)->emit_message)((j_common_ptr )cinfo, 1);
      }
      while(0);
      if(b[12] | b[13])
	(cinfo->err)->msg_code = JTRC_JFIF_THUMBNAIL,
	  (((cinfo->err)->msg_parm).i)[0] = b[12],
	  (((cinfo->err)->msg_parm).i)[1] = b[13], (*
	  (cinfo->err)->emit_message)((j_common_ptr )cinfo, 1);
      if(length != (INT32 )b[12] * (INT32 )b[13] * (INT32 )3)
	(cinfo->err)->msg_code = JTRC_JFIF_BADTHUMBNAILSIZE,
	  (((cinfo->err)->msg_parm).i)[0] = (int )length, (*
	  (cinfo->err)->emit_message)((j_common_ptr )cinfo, 1);
    }
    else
    {
      (cinfo->err)->msg_code = JTRC_APP0, (((cinfo->err)->msg_parm).i)[0] =
	(int )length + 14, (* (cinfo->err)->emit_message)((j_common_ptr )cinfo,
	1);
    }
  }
  else
  {
    (cinfo->err)->msg_code = JTRC_APP0, (((cinfo->err)->msg_parm).i)[0] =
      (int )length, (* (cinfo->err)->emit_message)((j_common_ptr )cinfo, 1);
  }
  datasrc->next_input_byte = next_input_byte, datasrc->bytes_in_buffer =
    bytes_in_buffer;
  if(length > 0)
    (* (cinfo->src)->skip_input_data)(cinfo, (long )length);
  return 1;
}

static boolean get_app14(j_decompress_ptr cinfo )
{
  INT32 length ; /*decdef*/
  UINT8 b[12] ; /*decdef*/
  int buffp ; /*decdef*/
  unsigned int version , flags0 , flags1 , transform ; /*decdef*/
  struct jpeg_source_mgr *  datasrc = cinfo->src; /*decdef*/
  const JOCTET *  next_input_byte = datasrc->next_input_byte; /*decdef*/
  size_t bytes_in_buffer = datasrc->bytes_in_buffer; /*decdef*/
  do
  {
    if(bytes_in_buffer == 0)
    {
      if(! (* datasrc->fill_input_buffer)(cinfo))
      {
	return 0;
      }
      next_input_byte = datasrc->next_input_byte, bytes_in_buffer =
	datasrc->bytes_in_buffer;
    }
    bytes_in_buffer--;
    length = (unsigned int )(* next_input_byte++) << 8;
    if(bytes_in_buffer == 0)
    {
      if(! (* datasrc->fill_input_buffer)(cinfo))
      {
	return 0;
      }
      next_input_byte = datasrc->next_input_byte, bytes_in_buffer =
	datasrc->bytes_in_buffer;
    }
    bytes_in_buffer--;
    length += * next_input_byte++;
  }
  while(0);
  length -= 2;
  if(length >= 12)
  {
    for(buffp = 0; buffp < 12; buffp++)
    {
      do
      {
	if(bytes_in_buffer == 0)
	{
	  if(! (* datasrc->fill_input_buffer)(cinfo))
	  {
	    return 0;
	  }
	  next_input_byte = datasrc->next_input_byte, bytes_in_buffer =
	    datasrc->bytes_in_buffer;
	}
	bytes_in_buffer--;
	b[buffp] = * next_input_byte++;
      }
      while(0);
    }
    length -= 12;
    if(b[0] == 0x41 && b[1] == 0x64 && b[2] == 0x6F && b[3] == 0x62 && b[4] ==
      0x65)
    {
      version = (b[5] << 8) + b[6];
      flags0 = (b[7] << 8) + b[8];
      flags1 = (b[9] << 8) + b[10];
      transform = b[11];
      do
      {
	int *  _mp = ((cinfo->err)->msg_parm).i; /*decdef*/
	_mp[0] = version;
	_mp[1] = flags0;
	_mp[2] = flags1;
	_mp[3] = transform;
	(cinfo->err)->msg_code = JTRC_ADOBE;
	(* (cinfo->err)->emit_message)((j_common_ptr )cinfo, 1);
      }
      while(0);
      cinfo->saw_Adobe_marker = 1;
      cinfo->Adobe_transform = (UINT8 )transform;
    }
    else
    {
      (cinfo->err)->msg_code = JTRC_APP14, (((cinfo->err)->msg_parm).i)[0] =
	(int )length + 12, (* (cinfo->err)->emit_message)((j_common_ptr )cinfo,
	1);
    }
  }
  else
  {
    (cinfo->err)->msg_code = JTRC_APP14, (((cinfo->err)->msg_parm).i)[0] =
      (int )length, (* (cinfo->err)->emit_message)((j_common_ptr )cinfo, 1);
  }
  datasrc->next_input_byte = next_input_byte, datasrc->bytes_in_buffer =
    bytes_in_buffer;
  if(length > 0)
    (* (cinfo->src)->skip_input_data)(cinfo, (long )length);
  return 1;
}

static boolean get_dac(j_decompress_ptr cinfo )
{
  INT32 length ; /*decdef*/
  int index , val ; /*decdef*/
  struct jpeg_source_mgr *  datasrc = cinfo->src; /*decdef*/
  const JOCTET *  next_input_byte = datasrc->next_input_byte; /*decdef*/
  size_t bytes_in_buffer = datasrc->bytes_in_buffer; /*decdef*/
  do
  {
    if(bytes_in_buffer == 0)
    {
      if(! (* datasrc->fill_input_buffer)(cinfo))
      {
	return 0;
      }
      next_input_byte = datasrc->next_input_byte, bytes_in_buffer =
	datasrc->bytes_in_buffer;
    }
    bytes_in_buffer--;
    length = (unsigned int )(* next_input_byte++) << 8;
    if(bytes_in_buffer == 0)
    {
      if(! (* datasrc->fill_input_buffer)(cinfo))
      {
	return 0;
      }
      next_input_byte = datasrc->next_input_byte, bytes_in_buffer =
	datasrc->bytes_in_buffer;
    }
    bytes_in_buffer--;
    length += * next_input_byte++;
  }
  while(0);
  length -= 2;
  while(length > 0)
  {
    do
    {
      if(bytes_in_buffer == 0)
      {
	if(! (* datasrc->fill_input_buffer)(cinfo))
	{
	  return 0;
	}
	next_input_byte = datasrc->next_input_byte, bytes_in_buffer =
	  datasrc->bytes_in_buffer;
      }
      bytes_in_buffer--;
      index = * next_input_byte++;
    }
    while(0);
    do
    {
      if(bytes_in_buffer == 0)
      {
	if(! (* datasrc->fill_input_buffer)(cinfo))
	{
	  return 0;
	}
	next_input_byte = datasrc->next_input_byte, bytes_in_buffer =
	  datasrc->bytes_in_buffer;
      }
      bytes_in_buffer--;
      val = * next_input_byte++;
    }
    while(0);
    length -= 2;
    (cinfo->err)->msg_code = JTRC_DAC, (((cinfo->err)->msg_parm).i)[0] = index,
      (((cinfo->err)->msg_parm).i)[1] = val, (*
      (cinfo->err)->emit_message)((j_common_ptr )cinfo, 1);
    if(index < 0 || index >= 2 * 16)
      (cinfo->err)->msg_code = JERR_DAC_INDEX, (((cinfo->err)->msg_parm).i)[0] =
	index, (* (cinfo->err)->error_exit)((j_common_ptr )cinfo);
    if(index >= 16)
    {
      (cinfo->arith_ac_K)[index - 16] = (UINT8 )val;
    }
    else
    {
      (cinfo->arith_dc_L)[index] = (UINT8 )(val & 0x0F);
      (cinfo->arith_dc_U)[index] = (UINT8 )(val >> 4);
      if((cinfo->arith_dc_L)[index] > (cinfo->arith_dc_U)[index])
	(cinfo->err)->msg_code = JERR_DAC_VALUE, (((cinfo->err)->msg_parm).i)[0]
	  = val, (* (cinfo->err)->error_exit)((j_common_ptr )cinfo);
    }
  }
  datasrc->next_input_byte = next_input_byte, datasrc->bytes_in_buffer =
    bytes_in_buffer;
  return 1;
}

static boolean get_dht(j_decompress_ptr cinfo )
{
  INT32 length ; /*decdef*/
  UINT8 bits[17] ; /*decdef*/
  UINT8 huffval[256] ; /*decdef*/
  int i , index , count ; /*decdef*/
  JHUFF_TBL *  *  htblptr ; /*decdef*/
  struct jpeg_source_mgr *  datasrc = cinfo->src; /*decdef*/
  const JOCTET *  next_input_byte = datasrc->next_input_byte; /*decdef*/
  size_t bytes_in_buffer = datasrc->bytes_in_buffer; /*decdef*/
  do
  {
    if(bytes_in_buffer == 0)
    {
      if(! (* datasrc->fill_input_buffer)(cinfo))
      {
	return 0;
      }
      next_input_byte = datasrc->next_input_byte, bytes_in_buffer =
	datasrc->bytes_in_buffer;
    }
    bytes_in_buffer--;
    length = (unsigned int )(* next_input_byte++) << 8;
    if(bytes_in_buffer == 0)
    {
      if(! (* datasrc->fill_input_buffer)(cinfo))
      {
	return 0;
      }
      next_input_byte = datasrc->next_input_byte, bytes_in_buffer =
	datasrc->bytes_in_buffer;
    }
    bytes_in_buffer--;
    length += * next_input_byte++;
  }
  while(0);
  length -= 2;
  while(length > 0)
  {
    do
    {
      if(bytes_in_buffer == 0)
      {
	if(! (* datasrc->fill_input_buffer)(cinfo))
	{
	  return 0;
	}
	next_input_byte = datasrc->next_input_byte, bytes_in_buffer =
	  datasrc->bytes_in_buffer;
      }
      bytes_in_buffer--;
      index = * next_input_byte++;
    }
    while(0);
    (cinfo->err)->msg_code = JTRC_DHT, (((cinfo->err)->msg_parm).i)[0] = index,
      (* (cinfo->err)->emit_message)((j_common_ptr )cinfo, 1);
    bits[0] = 0;
    count = 0;
    for(i = 1; i <= 16; i++)
    {
      do
      {
	if(bytes_in_buffer == 0)
	{
	  if(! (* datasrc->fill_input_buffer)(cinfo))
	  {
	    return 0;
	  }
	  next_input_byte = datasrc->next_input_byte, bytes_in_buffer =
	    datasrc->bytes_in_buffer;
	}
	bytes_in_buffer--;
	bits[i] = * next_input_byte++;
      }
      while(0);
      count += bits[i];
    }
    length -= 1 + 16;
    do
    {
      int *  _mp = ((cinfo->err)->msg_parm).i; /*decdef*/
      _mp[0] = bits[1];
      _mp[1] = bits[2];
      _mp[2] = bits[3];
      _mp[3] = bits[4];
      _mp[4] = bits[5];
      _mp[5] = bits[6];
      _mp[6] = bits[7];
      _mp[7] = bits[8];
      (cinfo->err)->msg_code = JTRC_HUFFBITS;
      (* (cinfo->err)->emit_message)((j_common_ptr )cinfo, 2);
    }
    while(0);
    do
    {
      int *  _mp = ((cinfo->err)->msg_parm).i; /*decdef*/
      _mp[0] = bits[9];
      _mp[1] = bits[10];
      _mp[2] = bits[11];
      _mp[3] = bits[12];
      _mp[4] = bits[13];
      _mp[5] = bits[14];
      _mp[6] = bits[15];
      _mp[7] = bits[16];
      (cinfo->err)->msg_code = JTRC_HUFFBITS;
      (* (cinfo->err)->emit_message)((j_common_ptr )cinfo, 2);
    }
    while(0);
    if(count > 256 || (INT32 )count > length)
      (cinfo->err)->msg_code = JERR_DHT_COUNTS, (*
	(cinfo->err)->error_exit)((j_common_ptr )cinfo);
    for(i = 0; i < count; i++)
    {
      do
      {
	if(bytes_in_buffer == 0)
	{
	  if(! (* datasrc->fill_input_buffer)(cinfo))
	  {
	    return 0;
	  }
	  next_input_byte = datasrc->next_input_byte, bytes_in_buffer =
	    datasrc->bytes_in_buffer;
	}
	bytes_in_buffer--;
	huffval[i] = * next_input_byte++;
      }
      while(0);
    }
    length -= count;
    if(index & 0x10)
    {
      index -= 0x10;
      htblptr = & (cinfo->ac_huff_tbl_ptrs)[index];
    }
    else
    {
      htblptr = & (cinfo->dc_huff_tbl_ptrs)[index];
    }
    if(index < 0 || index >= 4)
      (cinfo->err)->msg_code = JERR_DHT_INDEX, (((cinfo->err)->msg_parm).i)[0] =
	index, (* (cinfo->err)->error_exit)((j_common_ptr )cinfo);
    if(* htblptr == (void *  )0)
      * htblptr = jpeg_alloc_huff_table((j_common_ptr )cinfo);
    memcpy((void *  )(* htblptr)->bits, (const void *  )bits, (size_t )((size_t
      )sizeof((* htblptr)->bits)));
    memcpy((void *  )(* htblptr)->huffval, (const void *  )huffval, (size_t
      )((size_t )sizeof((* htblptr)->huffval)));
  }
  datasrc->next_input_byte = next_input_byte, datasrc->bytes_in_buffer =
    bytes_in_buffer;
  return 1;
}

static boolean get_dqt(j_decompress_ptr cinfo )
{
  INT32 length ; /*decdef*/
  int n , i , prec ; /*decdef*/
  unsigned int tmp ; /*decdef*/
  JQUANT_TBL *  quant_ptr ; /*decdef*/
  struct jpeg_source_mgr *  datasrc = cinfo->src; /*decdef*/
  const JOCTET *  next_input_byte = datasrc->next_input_byte; /*decdef*/
  size_t bytes_in_buffer = datasrc->bytes_in_buffer; /*decdef*/
  do
  {
    if(bytes_in_buffer == 0)
    {
      if(! (* datasrc->fill_input_buffer)(cinfo))
      {
	return 0;
      }
      next_input_byte = datasrc->next_input_byte, bytes_in_buffer =
	datasrc->bytes_in_buffer;
    }
    bytes_in_buffer--;
    length = (unsigned int )(* next_input_byte++) << 8;
    if(bytes_in_buffer == 0)
    {
      if(! (* datasrc->fill_input_buffer)(cinfo))
      {
	return 0;
      }
      next_input_byte = datasrc->next_input_byte, bytes_in_buffer =
	datasrc->bytes_in_buffer;
    }
    bytes_in_buffer--;
    length += * next_input_byte++;
  }
  while(0);
  length -= 2;
  while(length > 0)
  {
    do
    {
      if(bytes_in_buffer == 0)
      {
	if(! (* datasrc->fill_input_buffer)(cinfo))
	{
	  return 0;
	}
	next_input_byte = datasrc->next_input_byte, bytes_in_buffer =
	  datasrc->bytes_in_buffer;
      }
      bytes_in_buffer--;
      n = * next_input_byte++;
    }
    while(0);
    prec = n >> 4;
    n &= 0x0F;
    (cinfo->err)->msg_code = JTRC_DQT, (((cinfo->err)->msg_parm).i)[0] = n,
      (((cinfo->err)->msg_parm).i)[1] = prec, (*
      (cinfo->err)->emit_message)((j_common_ptr )cinfo, 1);
    if(n >= 4)
      (cinfo->err)->msg_code = JERR_DQT_INDEX, (((cinfo->err)->msg_parm).i)[0] =
	n, (* (cinfo->err)->error_exit)((j_common_ptr )cinfo);
    if((cinfo->quant_tbl_ptrs)[n] == (void *  )0)
      (cinfo->quant_tbl_ptrs)[n] = jpeg_alloc_quant_table((j_common_ptr )cinfo);
    quant_ptr = (cinfo->quant_tbl_ptrs)[n];
    for(i = 0; i < 64; i++)
    {
      if(prec)
      {
	do
	{
	  if(bytes_in_buffer == 0)
	  {
	    if(! (* datasrc->fill_input_buffer)(cinfo))
	    {
	      return 0;
	    }
	    next_input_byte = datasrc->next_input_byte, bytes_in_buffer =
	      datasrc->bytes_in_buffer;
	  }
	  bytes_in_buffer--;
	  tmp = (unsigned int )(* next_input_byte++) << 8;
	  if(bytes_in_buffer == 0)
	  {
	    if(! (* datasrc->fill_input_buffer)(cinfo))
	    {
	      return 0;
	    }
	    next_input_byte = datasrc->next_input_byte, bytes_in_buffer =
	      datasrc->bytes_in_buffer;
	  }
	  bytes_in_buffer--;
	  tmp += * next_input_byte++;
	}
	while(0);
      }
      else
      {
	do
	{
	  if(bytes_in_buffer == 0)
	  {
	    if(! (* datasrc->fill_input_buffer)(cinfo))
	    {
	      return 0;
	    }
	    next_input_byte = datasrc->next_input_byte, bytes_in_buffer =
	      datasrc->bytes_in_buffer;
	  }
	  bytes_in_buffer--;
	  tmp = * next_input_byte++;
	}
	while(0);
      }
      (quant_ptr->quantval)[i] = (UINT16 )tmp;
    }
    for(i = 0; i < 64; i += 8)
    {
      do
      {
	int *  _mp = ((cinfo->err)->msg_parm).i; /*decdef*/
	_mp[0] = (quant_ptr->quantval)[i];
	_mp[1] = (quant_ptr->quantval)[i + 1];
	_mp[2] = (quant_ptr->quantval)[i + 2];
	_mp[3] = (quant_ptr->quantval)[i + 3];
	_mp[4] = (quant_ptr->quantval)[i + 4];
	_mp[5] = (quant_ptr->quantval)[i + 5];
	_mp[6] = (quant_ptr->quantval)[i + 6];
	_mp[7] = (quant_ptr->quantval)[i + 7];
	(cinfo->err)->msg_code = JTRC_QUANTVALS;
	(* (cinfo->err)->emit_message)((j_common_ptr )cinfo, 2);
      }
      while(0);
    }
    length -= 64 + 1;
    if(prec)
      length -= 64;
  }
  datasrc->next_input_byte = next_input_byte, datasrc->bytes_in_buffer =
    bytes_in_buffer;
  return 1;
}

static boolean get_dri(j_decompress_ptr cinfo )
{
  INT32 length ; /*decdef*/
  unsigned int tmp ; /*decdef*/
  struct jpeg_source_mgr *  datasrc = cinfo->src; /*decdef*/
  const JOCTET *  next_input_byte = datasrc->next_input_byte; /*decdef*/
  size_t bytes_in_buffer = datasrc->bytes_in_buffer; /*decdef*/
  do
  {
    if(bytes_in_buffer == 0)
    {
      if(! (* datasrc->fill_input_buffer)(cinfo))
      {
	return 0;
      }
      next_input_byte = datasrc->next_input_byte, bytes_in_buffer =
	datasrc->bytes_in_buffer;
    }
    bytes_in_buffer--;
    length = (unsigned int )(* next_input_byte++) << 8;
    if(bytes_in_buffer == 0)
    {
      if(! (* datasrc->fill_input_buffer)(cinfo))
      {
	return 0;
      }
      next_input_byte = datasrc->next_input_byte, bytes_in_buffer =
	datasrc->bytes_in_buffer;
    }
    bytes_in_buffer--;
    length += * next_input_byte++;
  }
  while(0);
  if(length != 4)
    (cinfo->err)->msg_code = JERR_BAD_LENGTH, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  do
  {
    if(bytes_in_buffer == 0)
    {
      if(! (* datasrc->fill_input_buffer)(cinfo))
      {
	return 0;
      }
      next_input_byte = datasrc->next_input_byte, bytes_in_buffer =
	datasrc->bytes_in_buffer;
    }
    bytes_in_buffer--;
    tmp = (unsigned int )(* next_input_byte++) << 8;
    if(bytes_in_buffer == 0)
    {
      if(! (* datasrc->fill_input_buffer)(cinfo))
      {
	return 0;
      }
      next_input_byte = datasrc->next_input_byte, bytes_in_buffer =
	datasrc->bytes_in_buffer;
    }
    bytes_in_buffer--;
    tmp += * next_input_byte++;
  }
  while(0);
  (cinfo->err)->msg_code = JTRC_DRI, (((cinfo->err)->msg_parm).i)[0] = tmp, (*
    (cinfo->err)->emit_message)((j_common_ptr )cinfo, 1);
  cinfo->restart_interval = tmp;
  datasrc->next_input_byte = next_input_byte, datasrc->bytes_in_buffer =
    bytes_in_buffer;
  return 1;
}

static boolean skip_variable(j_decompress_ptr cinfo )
{
  INT32 length ; /*decdef*/
  struct jpeg_source_mgr *  datasrc = cinfo->src; /*decdef*/
  const JOCTET *  next_input_byte = datasrc->next_input_byte; /*decdef*/
  size_t bytes_in_buffer = datasrc->bytes_in_buffer; /*decdef*/
  do
  {
    if(bytes_in_buffer == 0)
    {
      if(! (* datasrc->fill_input_buffer)(cinfo))
      {
	return 0;
      }
      next_input_byte = datasrc->next_input_byte, bytes_in_buffer =
	datasrc->bytes_in_buffer;
    }
    bytes_in_buffer--;
    length = (unsigned int )(* next_input_byte++) << 8;
    if(bytes_in_buffer == 0)
    {
      if(! (* datasrc->fill_input_buffer)(cinfo))
      {
	return 0;
      }
      next_input_byte = datasrc->next_input_byte, bytes_in_buffer =
	datasrc->bytes_in_buffer;
    }
    bytes_in_buffer--;
    length += * next_input_byte++;
  }
  while(0);
  (cinfo->err)->msg_code = JTRC_MISC_MARKER, (((cinfo->err)->msg_parm).i)[0] =
    cinfo->unread_marker, (((cinfo->err)->msg_parm).i)[1] = (int )length, (*
    (cinfo->err)->emit_message)((j_common_ptr )cinfo, 1);
  datasrc->next_input_byte = next_input_byte, datasrc->bytes_in_buffer =
    bytes_in_buffer;
  (* (cinfo->src)->skip_input_data)(cinfo, (long )length - 2L);
  return 1;
}

static boolean next_marker(j_decompress_ptr cinfo )
{
  int c ; /*decdef*/
  struct jpeg_source_mgr *  datasrc = cinfo->src; /*decdef*/
  const JOCTET *  next_input_byte = datasrc->next_input_byte; /*decdef*/
  size_t bytes_in_buffer = datasrc->bytes_in_buffer; /*decdef*/
  for(; ; )
  {
    do
    {
      if(bytes_in_buffer == 0)
      {
	if(! (* datasrc->fill_input_buffer)(cinfo))
	{
	  return 0;
	}
	next_input_byte = datasrc->next_input_byte, bytes_in_buffer =
	  datasrc->bytes_in_buffer;
      }
      bytes_in_buffer--;
      c = * next_input_byte++;
    }
    while(0);
    while(c != 0xFF)
    {
      (cinfo->marker)->discarded_bytes++;
      datasrc->next_input_byte = next_input_byte, datasrc->bytes_in_buffer =
	bytes_in_buffer;
      do
      {
	if(bytes_in_buffer == 0)
	{
	  if(! (* datasrc->fill_input_buffer)(cinfo))
	  {
	    return 0;
	  }
	  next_input_byte = datasrc->next_input_byte, bytes_in_buffer =
	    datasrc->bytes_in_buffer;
	}
	bytes_in_buffer--;
	c = * next_input_byte++;
      }
      while(0);
    }
    do
    {
      do
      {
	if(bytes_in_buffer == 0)
	{
	  if(! (* datasrc->fill_input_buffer)(cinfo))
	  {
	    return 0;
	  }
	  next_input_byte = datasrc->next_input_byte, bytes_in_buffer =
	    datasrc->bytes_in_buffer;
	}
	bytes_in_buffer--;
	c = * next_input_byte++;
      }
      while(0);
    }
    while(c == 0xFF);
    if(c != 0)
      break;
    (cinfo->marker)->discarded_bytes += 2;
    datasrc->next_input_byte = next_input_byte, datasrc->bytes_in_buffer =
      bytes_in_buffer;
  }
  if((cinfo->marker)->discarded_bytes != 0)
  {
    (cinfo->err)->msg_code = JWRN_EXTRANEOUS_DATA,
      (((cinfo->err)->msg_parm).i)[0] = (cinfo->marker)->discarded_bytes,
      (((cinfo->err)->msg_parm).i)[1] = c, (*
      (cinfo->err)->emit_message)((j_common_ptr )cinfo, - 1);
    (cinfo->marker)->discarded_bytes = 0;
  }
  cinfo->unread_marker = c;
  datasrc->next_input_byte = next_input_byte, datasrc->bytes_in_buffer =
    bytes_in_buffer;
  return 1;
}

static boolean first_marker(j_decompress_ptr cinfo )
{
  int c , c2 ; /*decdef*/
  struct jpeg_source_mgr *  datasrc = cinfo->src; /*decdef*/
  const JOCTET *  next_input_byte = datasrc->next_input_byte; /*decdef*/
  size_t bytes_in_buffer = datasrc->bytes_in_buffer; /*decdef*/
  do
  {
    if(bytes_in_buffer == 0)
    {
      if(! (* datasrc->fill_input_buffer)(cinfo))
      {
	return 0;
      }
      next_input_byte = datasrc->next_input_byte, bytes_in_buffer =
	datasrc->bytes_in_buffer;
    }
    bytes_in_buffer--;
    c = * next_input_byte++;
  }
  while(0);
  do
  {
    if(bytes_in_buffer == 0)
    {
      if(! (* datasrc->fill_input_buffer)(cinfo))
      {
	return 0;
      }
      next_input_byte = datasrc->next_input_byte, bytes_in_buffer =
	datasrc->bytes_in_buffer;
    }
    bytes_in_buffer--;
    c2 = * next_input_byte++;
  }
  while(0);
  if(c != 0xFF || c2 != (int )M_SOI)
    (cinfo->err)->msg_code = JERR_NO_SOI, (((cinfo->err)->msg_parm).i)[0] = c,
      (((cinfo->err)->msg_parm).i)[1] = c2, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  cinfo->unread_marker = c2;
  datasrc->next_input_byte = next_input_byte, datasrc->bytes_in_buffer =
    bytes_in_buffer;
  return 1;
}

static int read_markers(j_decompress_ptr cinfo )
{
  for(; ; )
  {
    if(cinfo->unread_marker == 0)
    {
      if(! (cinfo->marker)->saw_SOI)
      {
	if(! first_marker(cinfo))
	  return 2;
      }
      else
      {
	if(! next_marker(cinfo))
	  return 2;
      }
    }
    switch(cinfo->unread_marker)
    {
    case M_SOI:
	;
      if(! get_soi(cinfo))
	return 2;
      break;
    case M_SOF0:
	;
    case M_SOF1:
	;
      cinfo->arith_code = 0;
      if(! get_sof(cinfo))
	return 2;
      break;
    case M_SOF9:
	;
      cinfo->arith_code = 1;
      if(! get_sof(cinfo))
	return 2;
      break;
    case M_SOF2:
	;
    case M_SOF3:
	;
    case M_SOF5:
	;
    case M_SOF6:
	;
    case M_SOF7:
	;
    case M_JPG:
	;
    case M_SOF10:
	;
    case M_SOF11:
	;
    case M_SOF13:
	;
    case M_SOF14:
	;
    case M_SOF15:
	;
      (cinfo->err)->msg_code = JERR_SOF_UNSUPPORTED,
	(((cinfo->err)->msg_parm).i)[0] = cinfo->unread_marker, (*
	(cinfo->err)->error_exit)((j_common_ptr )cinfo);
      break;
    case M_SOS:
	;
      if(! get_sos(cinfo))
	return 2;
      cinfo->unread_marker = 0;
      return 0;
    case M_EOI:
	;
      (cinfo->err)->msg_code = JTRC_EOI, (*
	(cinfo->err)->emit_message)((j_common_ptr )cinfo, 1);
      cinfo->unread_marker = 0;
      return 1;
    case M_DAC:
	;
      if(! get_dac(cinfo))
	return 2;
      break;
    case M_DHT:
	;
      if(! get_dht(cinfo))
	return 2;
      break;
    case M_DQT:
	;
      if(! get_dqt(cinfo))
	return 2;
      break;
    case M_DRI:
	;
      if(! get_dri(cinfo))
	return 2;
      break;
    case M_APP0:
	;
    case M_APP1:
	;
    case M_APP2:
	;
    case M_APP3:
	;
    case M_APP4:
	;
    case M_APP5:
	;
    case M_APP6:
	;
    case M_APP7:
	;
    case M_APP8:
	;
    case M_APP9:
	;
    case M_APP10:
	;
    case M_APP11:
	;
    case M_APP12:
	;
    case M_APP13:
	;
    case M_APP14:
	;
    case M_APP15:
	;
      if(! (* ((cinfo->marker)->process_APPn)[cinfo->unread_marker -
	(int )M_APP0])(cinfo))
	return 2;
      break;
    case M_COM:
	;
      if(! (* (cinfo->marker)->process_COM)(cinfo))
	return 2;
      break;
    case M_RST0:
	;
    case M_RST1:
	;
    case M_RST2:
	;
    case M_RST3:
	;
    case M_RST4:
	;
    case M_RST5:
	;
    case M_RST6:
	;
    case M_RST7:
	;
    case M_TEM:
	;
      (cinfo->err)->msg_code = JTRC_PARMLESS_MARKER,
	(((cinfo->err)->msg_parm).i)[0] = cinfo->unread_marker, (*
	(cinfo->err)->emit_message)((j_common_ptr )cinfo, 1);
      break;
    case M_DNL:
	;
      if(! skip_variable(cinfo))
	return 2;
      break;
    default :
	;
      (cinfo->err)->msg_code = JERR_UNKNOWN_MARKER,
	(((cinfo->err)->msg_parm).i)[0] = cinfo->unread_marker, (*
	(cinfo->err)->error_exit)((j_common_ptr )cinfo);
      break;
    }
    cinfo->unread_marker = 0;
  }
}

static boolean read_restart_marker(j_decompress_ptr cinfo )
{
  if(cinfo->unread_marker == 0)
  {
    if(! next_marker(cinfo))
      return 0;
  }
  if(cinfo->unread_marker == (int )M_RST0 + (cinfo->marker)->next_restart_num)
  {
    (cinfo->err)->msg_code = JTRC_RST, (((cinfo->err)->msg_parm).i)[0] =
      (cinfo->marker)->next_restart_num, (*
      (cinfo->err)->emit_message)((j_common_ptr )cinfo, 2);
    cinfo->unread_marker = 0;
  }
  else
  {
    if(! (* (cinfo->src)->resync_to_restart)(cinfo))
      return 0;
  }
  (cinfo->marker)->next_restart_num = (cinfo->marker)->next_restart_num + 1 & 7;
  return 1;
}

boolean jpeg_resync_to_restart(j_decompress_ptr cinfo )
{
  int marker = cinfo->unread_marker; /*decdef*/
  int desired = (cinfo->marker)->next_restart_num; /*decdef*/
  int action = 1; /*decdef*/
  (cinfo->err)->msg_code = JWRN_MUST_RESYNC, (((cinfo->err)->msg_parm).i)[0] =
    marker, (((cinfo->err)->msg_parm).i)[1] = desired, (*
    (cinfo->err)->emit_message)((j_common_ptr )cinfo, - 1);
  for(; ; )
  {
    if(marker < (int )M_SOF0)
      action = 2;
    else
    {
      if(marker < (int )M_RST0 || marker > (int )M_RST7)
	action = 3;
      else
      {
	if(marker == (int )M_RST0 + (desired + 1 & 7) || marker == (int )M_RST0
	  + (desired + 2 & 7))
	  action = 3;
	else
	{
	  if(marker == (int )M_RST0 + (desired - 1 & 7) || marker ==
	    (int )M_RST0 + (desired - 2 & 7))
	    action = 2;
	  else
	    action = 1;
	}
      }
    }
    (cinfo->err)->msg_code = JTRC_RECOVERY_ACTION,
      (((cinfo->err)->msg_parm).i)[0] = marker, (((cinfo->err)->msg_parm).i)[1]
      = action, (* (cinfo->err)->emit_message)((j_common_ptr )cinfo, 4);
    switch(action)
    {
    case 1:
	;
      cinfo->unread_marker = 0;
      return 1;
    case 2:
	;
      if(! next_marker(cinfo))
	return 0;
      marker = cinfo->unread_marker;
      break;
    case 3:
	;
      return 1;
    }
  }
}

static void reset_marker_reader(j_decompress_ptr cinfo )
{
  cinfo->unread_marker = 0;
  (cinfo->marker)->saw_SOI = 0;
  (cinfo->marker)->saw_SOF = 0;
  (cinfo->marker)->discarded_bytes = 0;
  cinfo->comp_info = (void *  )0;
}

void jinit_marker_reader(j_decompress_ptr cinfo )
{
  int i ; /*decdef*/
  if(cinfo->marker == (void *  )0)
  {
    cinfo->marker = (struct jpeg_marker_reader *  )(*
      (cinfo->mem)->alloc_small)((j_common_ptr )cinfo, 0, (size_t
      )sizeof(struct jpeg_marker_reader ));
  }
  (cinfo->marker)->reset_marker_reader = reset_marker_reader;
  (cinfo->marker)->read_markers = read_markers;
  (cinfo->marker)->read_restart_marker = read_restart_marker;
  (cinfo->marker)->process_COM = skip_variable;
  for(i = 0; i < 16; i++)
    ((cinfo->marker)->process_APPn)[i] = skip_variable;
  ((cinfo->marker)->process_APPn)[0] = get_app0;
  ((cinfo->marker)->process_APPn)[14] = get_app14;
  reset_marker_reader(cinfo);
}


#pragma combiner("./jdmainct.i", "-g -O -I/home/scott/wrk/safec/cil/lib ")

#pragma boxalloc("malloc", nozero, sizein(0))

#pragma boxalloc("alloca", nozero, sizein(0))

#pragma boxalloc("calloc", zero, sizemul(0, 1))

#pragma boxprintf("printf", 0)

#pragma boxprintf("fprintf", 1)

#pragma boxprintf("sprintf", 1)

#pragma boxprintf("snprintf", 2)

#pragma boxpoly("memcpy")

#pragma boxexported("main")
typedef struct  {
  struct jpeg_d_main_controller pub ;
  JSAMPARRAY buffer[10] ;
  boolean buffer_full ;
  JDIMENSION rowgroup_ctr ;
  JSAMPIMAGE xbuffer[2] ;
  int whichptr ;
  int context_state ;
  JDIMENSION rowgroups_avail ;
  JDIMENSION iMCU_row_ctr ;
} my_main_controller_d ; /*typedef*/

typedef my_main_controller_d *  my_main_ptr__0 ; /*typedef*/

static void process_data_simple_main__0(j_decompress_ptr cinfo , JSAMPARRAY
  output_buf , JDIMENSION *  out_row_ctr , JDIMENSION out_rows_avail )
  ; /*decdef*/
static void process_data_context_main(j_decompress_ptr cinfo , JSAMPARRAY
  output_buf , JDIMENSION *  out_row_ctr , JDIMENSION out_rows_avail )
  ; /*decdef*/
static void process_data_input_only(j_decompress_ptr cinfo , JSAMPARRAY
  output_buf , JDIMENSION *  out_row_ctr , JDIMENSION out_rows_avail )
  ; /*decdef*/
static void process_data_crank_post(j_decompress_ptr cinfo , JSAMPARRAY
  output_buf , JDIMENSION *  out_row_ctr , JDIMENSION out_rows_avail )
  ; /*decdef*/

static void make_funny_pointers(j_decompress_ptr cinfo )
{
  my_main_ptr__0 main = (my_main_ptr__0 )cinfo->main; /*decdef*/
  int ci , i , rgroup ; /*decdef*/
  int M = cinfo->min_DCT_scaled_size; /*decdef*/
  jpeg_component_info *  compptr ; /*decdef*/
  JSAMPARRAY buf , xbuf0 , xbuf1 ; /*decdef*/
  (main->xbuffer)[0] = (JSAMPIMAGE )(* (cinfo->mem)->alloc_small)((j_common_ptr
    )cinfo, 1, cinfo->num_components * 2 * (size_t )sizeof(*
    (main->xbuffer)[0]));
  (main->xbuffer)[1] = (main->xbuffer)[0] + cinfo->num_components;
  for(ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components; ci++,
    compptr++)
  {
    rgroup = compptr->v_samp_factor * compptr->DCT_scaled_size /
      cinfo->min_DCT_scaled_size;
    xbuf0 = (JSAMPARRAY )(* (cinfo->mem)->alloc_small)((j_common_ptr )cinfo, 1,
      2 * (rgroup * (M + 4)) * (size_t )sizeof(* xbuf0));
    xbuf0 += rgroup;
    ((main->xbuffer)[0])[ci] = xbuf0;
    xbuf1 = xbuf0 + rgroup * (M + 4);
    ((main->xbuffer)[1])[ci] = xbuf1;
    buf = (main->buffer)[ci];
    for(i = 0; i < rgroup * (M + 2); i++)
    {
      xbuf0[i] = (xbuf1[i] = buf[i]);
    }
    for(i = 0; i < rgroup * 2; i++)
    {
      xbuf1[rgroup * (M - 2) + i] = buf[rgroup * M + i];
      xbuf1[rgroup * M + i] = buf[rgroup * (M - 2) + i];
    }
    for(i = 0; i < rgroup; i++)
    {
      xbuf0[i - rgroup] = xbuf0[0];
    }
  }
}

static void set_wraparound_pointers(j_decompress_ptr cinfo )
{
  my_main_ptr__0 main = (my_main_ptr__0 )cinfo->main; /*decdef*/
  int ci , i , rgroup ; /*decdef*/
  int M = cinfo->min_DCT_scaled_size; /*decdef*/
  jpeg_component_info *  compptr ; /*decdef*/
  JSAMPARRAY xbuf0 , xbuf1 ; /*decdef*/
  for(ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components; ci++,
    compptr++)
  {
    rgroup = compptr->v_samp_factor * compptr->DCT_scaled_size /
      cinfo->min_DCT_scaled_size;
    xbuf0 = ((main->xbuffer)[0])[ci];
    xbuf1 = ((main->xbuffer)[1])[ci];
    for(i = 0; i < rgroup; i++)
    {
      xbuf0[i - rgroup] = xbuf0[rgroup * (M + 1) + i];
      xbuf1[i - rgroup] = xbuf1[rgroup * (M + 1) + i];
      xbuf0[rgroup * (M + 2) + i] = xbuf0[i];
      xbuf1[rgroup * (M + 2) + i] = xbuf1[i];
    }
  }
}

static void set_bottom_pointers(j_decompress_ptr cinfo )
{
  my_main_ptr__0 main = (my_main_ptr__0 )cinfo->main; /*decdef*/
  int ci , i , rgroup , iMCUheight , rows_left ; /*decdef*/
  jpeg_component_info *  compptr ; /*decdef*/
  JSAMPARRAY xbuf ; /*decdef*/
  for(ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components; ci++,
    compptr++)
  {
    iMCUheight = compptr->v_samp_factor * compptr->DCT_scaled_size;
    rgroup = iMCUheight / cinfo->min_DCT_scaled_size;
    rows_left = (int )(compptr->downsampled_height % (JDIMENSION )iMCUheight);
    if(rows_left == 0)
      rows_left = iMCUheight;
    if(ci == 0)
    {
      main->rowgroups_avail = (JDIMENSION )((rows_left - 1) / rgroup + 1);
    }
    xbuf = ((main->xbuffer)[main->whichptr])[ci];
    for(i = 0; i < rgroup * 2; i++)
    {
      xbuf[rows_left + i] = xbuf[rows_left - 1];
    }
  }
}

static void start_pass_main__0(j_decompress_ptr cinfo , J_BUF_MODE pass_mode )
{
  my_main_ptr__0 main = (my_main_ptr__0 )cinfo->main; /*decdef*/
  (main->pub).num_chunks = cinfo->output_height;
  switch(pass_mode)
  {
  case JBUF_PASS_THRU:
      ;
    if(cinfo->raw_data_out)
      return;
    if((cinfo->upsample)->need_context_rows)
    {
      (main->pub).process_data = process_data_context_main;
      make_funny_pointers(cinfo);
      main->whichptr = 0;
      main->context_state = 0;
      main->iMCU_row_ctr = 0;
    }
    else
    {
      (main->pub).process_data = process_data_simple_main__0;
    }
    main->buffer_full = 0;
    main->rowgroup_ctr = 0;
    break;
  case JBUF_CRANK_SOURCE:
      ;
    (main->pub).process_data = process_data_input_only;
    (main->pub).num_chunks = cinfo->total_iMCU_rows;
    break;
  case JBUF_CRANK_DEST:
      ;
    (main->pub).process_data = process_data_crank_post;
    break;
  default :
      ;
    (cinfo->err)->msg_code = JERR_BAD_BUFFER_MODE, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
    break;
  }
}

static void process_data_simple_main__0(j_decompress_ptr cinfo , JSAMPARRAY
  output_buf , JDIMENSION *  out_row_ctr , JDIMENSION out_rows_avail )
{
  my_main_ptr__0 main = (my_main_ptr__0 )cinfo->main; /*decdef*/
  JDIMENSION rowgroups_avail ; /*decdef*/
  if(! main->buffer_full)
  {
    if(! (* (cinfo->coef)->decompress_data)(cinfo, main->buffer))
      return;
    main->buffer_full = 1;
  }
  rowgroups_avail = (JDIMENSION )cinfo->min_DCT_scaled_size;
  (* (cinfo->post)->post_process_data)(cinfo, main->buffer, &
    main->rowgroup_ctr, rowgroups_avail, output_buf, out_row_ctr,
    out_rows_avail);
  if(main->rowgroup_ctr >= rowgroups_avail)
  {
    main->buffer_full = 0;
    main->rowgroup_ctr = 0;
  }
}

static void process_data_context_main(j_decompress_ptr cinfo , JSAMPARRAY
  output_buf , JDIMENSION *  out_row_ctr , JDIMENSION out_rows_avail )
{
  my_main_ptr__0 main = (my_main_ptr__0 )cinfo->main; /*decdef*/
  if(! main->buffer_full)
  {
    if(! (* (cinfo->coef)->decompress_data)(cinfo,
      (main->xbuffer)[main->whichptr]))
      return;
    main->buffer_full = 1;
    main->iMCU_row_ctr++;
  }
  switch(main->context_state)
  {
  case 2:
      ;
    (* (cinfo->post)->post_process_data)(cinfo, (main->xbuffer)[main->whichptr],
      & main->rowgroup_ctr, main->rowgroups_avail, output_buf, out_row_ctr,
      out_rows_avail);
    if(main->rowgroup_ctr < main->rowgroups_avail)
      return;
    main->context_state = 0;
    if(* out_row_ctr >= out_rows_avail)
      return;
  case 0:
      ;
    main->rowgroup_ctr = 0;
    main->rowgroups_avail = (JDIMENSION )(cinfo->min_DCT_scaled_size - 1);
    if(main->iMCU_row_ctr == cinfo->total_iMCU_rows)
      set_bottom_pointers(cinfo);
    main->context_state = 1;
  case 1:
      ;
    (* (cinfo->post)->post_process_data)(cinfo, (main->xbuffer)[main->whichptr],
      & main->rowgroup_ctr, main->rowgroups_avail, output_buf, out_row_ctr,
      out_rows_avail);
    if(main->rowgroup_ctr < main->rowgroups_avail)
      return;
    if(main->iMCU_row_ctr == 1)
      set_wraparound_pointers(cinfo);
    main->whichptr ^= 1;
    main->buffer_full = 0;
    main->rowgroup_ctr = (JDIMENSION )(cinfo->min_DCT_scaled_size + 1);
    main->rowgroups_avail = (JDIMENSION )(cinfo->min_DCT_scaled_size + 2);
    main->context_state = 2;
  }
}

static void process_data_input_only(j_decompress_ptr cinfo , JSAMPARRAY
  output_buf , JDIMENSION *  out_row_ctr , JDIMENSION out_rows_avail )
{
  if(! (* (cinfo->coef)->decompress_data)(cinfo, (JSAMPIMAGE )((void *  )0)))
    return;
  * out_row_ctr += 1;
}

static void process_data_crank_post(j_decompress_ptr cinfo , JSAMPARRAY
  output_buf , JDIMENSION *  out_row_ctr , JDIMENSION out_rows_avail )
{
  (* (cinfo->post)->post_process_data)(cinfo, (JSAMPIMAGE )((void *  )0),
    (JDIMENSION *  )((void *  )0), (JDIMENSION )0, output_buf, out_row_ctr,
    out_rows_avail);
}

void jinit_d_main_controller(j_decompress_ptr cinfo , boolean need_full_buffer )
{
  my_main_ptr__0 main ; /*decdef*/
  int ci , rgroup , ngroups ; /*decdef*/
  jpeg_component_info *  compptr ; /*decdef*/
  main = (my_main_ptr__0 )(* (cinfo->mem)->alloc_small)((j_common_ptr )cinfo, 1,
    (size_t )sizeof(my_main_controller_d ));
  cinfo->main = (struct jpeg_d_main_controller *  )main;
  (main->pub).start_pass = start_pass_main__0;
  if(need_full_buffer)
    (cinfo->err)->msg_code = JERR_BAD_BUFFER_MODE, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  if(cinfo->raw_data_out)
    return;
  if((cinfo->upsample)->need_context_rows)
  {
    if(cinfo->min_DCT_scaled_size < 2)
      (cinfo->err)->msg_code = JERR_NOTIMPL, (*
	(cinfo->err)->error_exit)((j_common_ptr )cinfo);
    ngroups = cinfo->min_DCT_scaled_size + 2;
  }
  else
  {
    ngroups = cinfo->min_DCT_scaled_size;
  }
  for(ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components; ci++,
    compptr++)
  {
    rgroup = compptr->v_samp_factor * compptr->DCT_scaled_size /
      cinfo->min_DCT_scaled_size;
    (main->buffer)[ci] = (* (cinfo->mem)->alloc_sarray)((j_common_ptr )cinfo, 1,
      compptr->width_in_blocks * compptr->DCT_scaled_size, (JDIMENSION )(rgroup
      * ngroups));
  }
}


#pragma combiner("./jdcoefct.i", "-g -O -I/home/scott/wrk/safec/cil/lib ")

#pragma boxalloc("malloc", nozero, sizein(0))

#pragma boxalloc("alloca", nozero, sizein(0))

#pragma boxalloc("calloc", zero, sizemul(0, 1))

#pragma boxprintf("printf", 0)

#pragma boxprintf("fprintf", 1)

#pragma boxprintf("sprintf", 1)

#pragma boxprintf("snprintf", 2)

#pragma boxpoly("memcpy")

#pragma boxexported("main")
typedef struct  {
  struct jpeg_d_coef_controller pub ;
  JDIMENSION MCU_col_num ;
  JDIMENSION MCU_row_num ;
  JBLOCKROW MCU_buffer[10] ;
  jvirt_barray_ptr whole_image[10] ;
} my_coef_controller_d ; /*typedef*/

typedef my_coef_controller_d *  my_coef_ptr__0 ; /*typedef*/

static boolean decompress_data(j_decompress_ptr cinfo , JSAMPIMAGE output_buf )
  ; /*decdef*/
static boolean decompress_read(j_decompress_ptr cinfo , JSAMPIMAGE output_buf )
  ; /*decdef*/
static boolean decompress_output(j_decompress_ptr cinfo , JSAMPIMAGE output_buf
  ) ; /*decdef*/

static void start_pass_coef__0(j_decompress_ptr cinfo , J_BUF_MODE pass_mode )
{
  my_coef_ptr__0 coef = (my_coef_ptr__0 )cinfo->coef; /*decdef*/
  coef->MCU_col_num = 0;
  coef->MCU_row_num = 0;
  switch(pass_mode)
  {
  case JBUF_PASS_THRU:
      ;
    if((coef->whole_image)[0] != (void *  )0)
      (cinfo->err)->msg_code = JERR_BAD_BUFFER_MODE, (*
	(cinfo->err)->error_exit)((j_common_ptr )cinfo);
    (coef->pub).decompress_data = decompress_data;
    break;
  case JBUF_SAVE_SOURCE:
      ;
    if((coef->whole_image)[0] == (void *  )0)
      (cinfo->err)->msg_code = JERR_BAD_BUFFER_MODE, (*
	(cinfo->err)->error_exit)((j_common_ptr )cinfo);
    (coef->pub).decompress_data = decompress_read;
    break;
  case JBUF_CRANK_DEST:
      ;
    if((coef->whole_image)[0] == (void *  )0)
      (cinfo->err)->msg_code = JERR_BAD_BUFFER_MODE, (*
	(cinfo->err)->error_exit)((j_common_ptr )cinfo);
    (coef->pub).decompress_data = decompress_output;
    break;
  default :
      ;
    (cinfo->err)->msg_code = JERR_BAD_BUFFER_MODE, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
    break;
  }
}

static boolean decompress_data(j_decompress_ptr cinfo , JSAMPIMAGE output_buf )
{
  my_coef_ptr__0 coef = (my_coef_ptr__0 )cinfo->coef; /*decdef*/
  JDIMENSION MCU_col_num ; /*decdef*/
  JDIMENSION last_MCU_col = cinfo->MCUs_per_row - 1; /*decdef*/
  JDIMENSION last_MCU_row = cinfo->MCU_rows_in_scan - 1; /*decdef*/
  int blkn , ci , xindex , yindex , useful_width ; /*decdef*/
  JSAMPARRAY output_ptr ; /*decdef*/
  JDIMENSION start_col , output_col ; /*decdef*/
  jpeg_component_info *  compptr ; /*decdef*/
  inverse_DCT_method_ptr inverse_DCT ; /*decdef*/
  for(MCU_col_num = coef->MCU_col_num; MCU_col_num <= last_MCU_col;
    MCU_col_num++)
  {
    jzero_far((void *  )(coef->MCU_buffer)[0], (size_t )(cinfo->blocks_in_MCU *
      (size_t )sizeof(JBLOCK )));
    if(! (* (cinfo->entropy)->decode_mcu)(cinfo, coef->MCU_buffer))
    {
      coef->MCU_col_num = MCU_col_num;
      return 0;
    }
    blkn = 0;
    for(ci = 0; ci < cinfo->comps_in_scan; ci++)
    {
      compptr = (cinfo->cur_comp_info)[ci];
      if(! compptr->component_needed)
      {
	blkn += compptr->MCU_blocks;
	continue;
      }
      inverse_DCT = ((cinfo->idct)->inverse_DCT)[compptr->component_index];
      useful_width = MCU_col_num < last_MCU_col ? compptr->MCU_width
	: compptr->last_col_width;
      output_ptr = output_buf[ci];
      start_col = MCU_col_num * compptr->MCU_sample_width;
      for(yindex = 0; yindex < compptr->MCU_height; yindex++)
      {
	if(coef->MCU_row_num < last_MCU_row || yindex <
	  compptr->last_row_height)
	{
	  output_col = start_col;
	  for(xindex = 0; xindex < useful_width; xindex++)
	  {
	    (* inverse_DCT)(cinfo, compptr, (JCOEFPTR )(coef->MCU_buffer)[blkn +
	      xindex], output_ptr, output_col);
	    output_col += compptr->DCT_scaled_size;
	  }
	}
	blkn += compptr->MCU_width;
	output_ptr += compptr->DCT_scaled_size;
      }
    }
  }
  coef->MCU_col_num = 0;
  coef->MCU_row_num++;
  return 1;
}

static boolean decompress_read(j_decompress_ptr cinfo , JSAMPIMAGE output_buf )
{
  my_coef_ptr__0 coef = (my_coef_ptr__0 )cinfo->coef; /*decdef*/
  JDIMENSION MCU_col_num ; /*decdef*/
  int blkn , ci , xindex , yindex , yoffset , num_MCU_rows ; /*decdef*/
  JDIMENSION total_width , remaining_rows , start_col ; /*decdef*/
  JBLOCKARRAY buffer[4] ; /*decdef*/
  JBLOCKROW buffer_ptr ; /*decdef*/
  jpeg_component_info *  compptr ; /*decdef*/
  for(ci = 0; ci < cinfo->comps_in_scan; ci++)
  {
    compptr = (cinfo->cur_comp_info)[ci];
    buffer[ci] = (* (cinfo->mem)->access_virt_barray)((j_common_ptr )cinfo,
      (coef->whole_image)[compptr->component_index], coef->MCU_row_num *
      compptr->v_samp_factor, 1);
    total_width = (JDIMENSION )jround_up((long )compptr->width_in_blocks,
      (long )compptr->h_samp_factor);
    for(yindex = 0; yindex < compptr->v_samp_factor; yindex++)
    {
      jzero_far((void *  )(buffer[ci])[yindex], (size_t )(total_width * (size_t
	)sizeof(JBLOCK )));
    }
  }
  if(cinfo->comps_in_scan == 1)
  {
    compptr = (cinfo->cur_comp_info)[0];
    num_MCU_rows = compptr->v_samp_factor;
    remaining_rows = cinfo->MCU_rows_in_scan - coef->MCU_row_num *
      compptr->v_samp_factor;
    if(remaining_rows < (JDIMENSION )num_MCU_rows)
      num_MCU_rows = (int )remaining_rows;
  }
  else
  {
    num_MCU_rows = 1;
  }
  for(yoffset = 0; yoffset < num_MCU_rows; yoffset++)
  {
    for(MCU_col_num = 0; MCU_col_num < cinfo->MCUs_per_row; MCU_col_num++)
    {
      blkn = 0;
      for(ci = 0; ci < cinfo->comps_in_scan; ci++)
      {
	compptr = (cinfo->cur_comp_info)[ci];
	start_col = MCU_col_num * compptr->MCU_width;
	for(yindex = 0; yindex < compptr->MCU_height; yindex++)
	{
	  buffer_ptr = (buffer[ci])[yindex + yoffset] + start_col;
	  for(xindex = 0; xindex < compptr->MCU_width; xindex++)
	  {
	    (coef->MCU_buffer)[blkn++] = buffer_ptr++;
	  }
	}
      }
      if(! (* (cinfo->entropy)->decode_mcu)(cinfo, coef->MCU_buffer))
      {
	(cinfo->err)->msg_code = JERR_CANT_SUSPEND, (*
	  (cinfo->err)->error_exit)((j_common_ptr )cinfo);
      }
    }
  }
  coef->MCU_row_num++;
  return 1;
}

static boolean decompress_output(j_decompress_ptr cinfo , JSAMPIMAGE output_buf
  )
{
  my_coef_ptr__0 coef = (my_coef_ptr__0 )cinfo->coef; /*decdef*/
  JDIMENSION last_MCU_row = cinfo->total_iMCU_rows - 1; /*decdef*/
  JDIMENSION block_num ; /*decdef*/
  int ci , block_row , block_rows ; /*decdef*/
  JBLOCKARRAY buffer ; /*decdef*/
  JBLOCKROW buffer_ptr ; /*decdef*/
  JSAMPARRAY output_ptr ; /*decdef*/
  JDIMENSION output_col ; /*decdef*/
  jpeg_component_info *  compptr ; /*decdef*/
  inverse_DCT_method_ptr inverse_DCT ; /*decdef*/
  for(ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components; ci++,
    compptr++)
  {
    if(! compptr->component_needed)
      continue;
    buffer = (* (cinfo->mem)->access_virt_barray)((j_common_ptr )cinfo,
      (coef->whole_image)[ci], coef->MCU_row_num * compptr->v_samp_factor, 0);
    if(coef->MCU_row_num < last_MCU_row)
      block_rows = compptr->v_samp_factor;
    else
    {
      block_rows = (int )(compptr->height_in_blocks % compptr->v_samp_factor);
      if(block_rows == 0)
	block_rows = compptr->v_samp_factor;
    }
    inverse_DCT = ((cinfo->idct)->inverse_DCT)[ci];
    output_ptr = output_buf[ci];
    for(block_row = 0; block_row < block_rows; block_row++)
    {
      buffer_ptr = buffer[block_row];
      output_col = 0;
      for(block_num = 0; block_num < compptr->width_in_blocks; block_num++)
      {
	(* inverse_DCT)(cinfo, compptr, (JCOEFPTR )buffer_ptr, output_ptr,
	  output_col);
	buffer_ptr++;
	output_col += compptr->DCT_scaled_size;
      }
      output_ptr += compptr->DCT_scaled_size;
    }
  }
  coef->MCU_row_num++;
  return 1;
}

void jinit_d_coef_controller(j_decompress_ptr cinfo , boolean need_full_buffer )
{
  my_coef_ptr__0 coef ; /*decdef*/
  int ci , i ; /*decdef*/
  jpeg_component_info *  compptr ; /*decdef*/
  JBLOCKROW buffer ; /*decdef*/
  coef = (my_coef_ptr__0 )(* (cinfo->mem)->alloc_small)((j_common_ptr )cinfo, 1,
    (size_t )sizeof(my_coef_controller_d ));
  cinfo->coef = (struct jpeg_d_coef_controller *  )coef;
  (coef->pub).start_pass = start_pass_coef__0;
  if(need_full_buffer)
  {
    for(ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components; ci++,
      compptr++)
    {
      (coef->whole_image)[ci] = (*
	(cinfo->mem)->request_virt_barray)((j_common_ptr )cinfo, 1, (JDIMENSION
	)jround_up((long )compptr->width_in_blocks,
	(long )compptr->h_samp_factor), compptr->height_in_blocks, (JDIMENSION
	)compptr->v_samp_factor);
    }
  }
  else
  {
    buffer = (JBLOCKROW )(* (cinfo->mem)->alloc_large)((j_common_ptr )cinfo, 1,
      10 * (size_t )sizeof(JBLOCK ));
    for(i = 0; i < 10; i++)
    {
      (coef->MCU_buffer)[i] = buffer + i;
    }
    (coef->whole_image)[0] = (void *  )0;
  }
}


#pragma combiner("./jdpostct.i", "-g -O -I/home/scott/wrk/safec/cil/lib ")

#pragma boxalloc("malloc", nozero, sizein(0))

#pragma boxalloc("alloca", nozero, sizein(0))

#pragma boxalloc("calloc", zero, sizemul(0, 1))

#pragma boxprintf("printf", 0)

#pragma boxprintf("fprintf", 1)

#pragma boxprintf("sprintf", 1)

#pragma boxprintf("snprintf", 2)

#pragma boxpoly("memcpy")

#pragma boxexported("main")
typedef struct  {
  struct jpeg_d_post_controller pub ;
  jvirt_sarray_ptr whole_image ;
  JSAMPARRAY buffer ;
  JDIMENSION strip_height ;
  JDIMENSION starting_row ;
  JDIMENSION next_row ;
} my_post_controller ; /*typedef*/

typedef my_post_controller *  my_post_ptr ; /*typedef*/

static void post_process_1pass(j_decompress_ptr cinfo , JSAMPIMAGE input_buf ,
  JDIMENSION *  in_row_group_ctr , JDIMENSION in_row_groups_avail , JSAMPARRAY
  output_buf , JDIMENSION *  out_row_ctr , JDIMENSION out_rows_avail )
  ; /*decdef*/
static void post_process_prepass(j_decompress_ptr cinfo , JSAMPIMAGE input_buf ,
  JDIMENSION *  in_row_group_ctr , JDIMENSION in_row_groups_avail , JSAMPARRAY
  output_buf , JDIMENSION *  out_row_ctr , JDIMENSION out_rows_avail )
  ; /*decdef*/
static void post_process_2pass(j_decompress_ptr cinfo , JSAMPIMAGE input_buf ,
  JDIMENSION *  in_row_group_ctr , JDIMENSION in_row_groups_avail , JSAMPARRAY
  output_buf , JDIMENSION *  out_row_ctr , JDIMENSION out_rows_avail )
  ; /*decdef*/

static void start_pass_dpost(j_decompress_ptr cinfo , J_BUF_MODE pass_mode )
{
  my_post_ptr post = (my_post_ptr )cinfo->post; /*decdef*/
  switch(pass_mode)
  {
  case JBUF_PASS_THRU:
      ;
    if(cinfo->quantize_colors)
    {
      (post->pub).post_process_data = post_process_1pass;
    }
    else
    {
      (post->pub).post_process_data = (cinfo->upsample)->upsample;
    }
    break;
  case JBUF_SAVE_AND_PASS:
      ;
    if(post->whole_image == (void *  )0)
      (cinfo->err)->msg_code = JERR_BAD_BUFFER_MODE, (*
	(cinfo->err)->error_exit)((j_common_ptr )cinfo);
    (post->pub).post_process_data = post_process_prepass;
    break;
  case JBUF_CRANK_DEST:
      ;
    if(post->whole_image == (void *  )0)
      (cinfo->err)->msg_code = JERR_BAD_BUFFER_MODE, (*
	(cinfo->err)->error_exit)((j_common_ptr )cinfo);
    (post->pub).post_process_data = post_process_2pass;
    break;
  default :
      ;
    (cinfo->err)->msg_code = JERR_BAD_BUFFER_MODE, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
    break;
  }
  post->starting_row = (post->next_row = 0);
}

static void post_process_1pass(j_decompress_ptr cinfo , JSAMPIMAGE input_buf ,
  JDIMENSION *  in_row_group_ctr , JDIMENSION in_row_groups_avail , JSAMPARRAY
  output_buf , JDIMENSION *  out_row_ctr , JDIMENSION out_rows_avail )
{
  my_post_ptr post = (my_post_ptr )cinfo->post; /*decdef*/
  JDIMENSION num_rows , max_rows ; /*decdef*/
  max_rows = out_rows_avail - * out_row_ctr;
  if(max_rows > post->strip_height)
    max_rows = post->strip_height;
  num_rows = 0;
  (* (cinfo->upsample)->upsample)(cinfo, input_buf, in_row_group_ctr,
    in_row_groups_avail, post->buffer, & num_rows, max_rows);
  (* (cinfo->cquantize)->color_quantize)(cinfo, post->buffer, output_buf + *
    out_row_ctr, (int )num_rows);
  * out_row_ctr += num_rows;
}

static void post_process_prepass(j_decompress_ptr cinfo , JSAMPIMAGE input_buf ,
  JDIMENSION *  in_row_group_ctr , JDIMENSION in_row_groups_avail , JSAMPARRAY
  output_buf , JDIMENSION *  out_row_ctr , JDIMENSION out_rows_avail )
{
  my_post_ptr post = (my_post_ptr )cinfo->post; /*decdef*/
  JDIMENSION old_next_row , num_rows ; /*decdef*/
  if(post->next_row == 0)
  {
    post->buffer = (* (cinfo->mem)->access_virt_sarray)((j_common_ptr )cinfo,
      post->whole_image, post->starting_row, 1);
  }
  old_next_row = post->next_row;
  (* (cinfo->upsample)->upsample)(cinfo, input_buf, in_row_group_ctr,
    in_row_groups_avail, post->buffer, & post->next_row, post->strip_height);
  if(post->next_row > old_next_row)
  {
    num_rows = post->next_row - old_next_row;
    (* (cinfo->cquantize)->color_quantize)(cinfo, post->buffer + old_next_row,
      (JSAMPARRAY )((void *  )0), (int )num_rows);
    * out_row_ctr += num_rows;
  }
  if(post->next_row >= post->strip_height)
  {
    post->starting_row += post->strip_height;
    post->next_row = 0;
  }
}

static void post_process_2pass(j_decompress_ptr cinfo , JSAMPIMAGE input_buf ,
  JDIMENSION *  in_row_group_ctr , JDIMENSION in_row_groups_avail , JSAMPARRAY
  output_buf , JDIMENSION *  out_row_ctr , JDIMENSION out_rows_avail )
{
  my_post_ptr post = (my_post_ptr )cinfo->post; /*decdef*/
  JDIMENSION num_rows , max_rows ; /*decdef*/
  if(post->next_row == 0)
  {
    post->buffer = (* (cinfo->mem)->access_virt_sarray)((j_common_ptr )cinfo,
      post->whole_image, post->starting_row, 0);
  }
  num_rows = post->strip_height - post->next_row;
  max_rows = out_rows_avail - * out_row_ctr;
  if(num_rows > max_rows)
    num_rows = max_rows;
  max_rows = cinfo->output_height - post->starting_row;
  if(num_rows > max_rows)
    num_rows = max_rows;
  (* (cinfo->cquantize)->color_quantize)(cinfo, post->buffer + post->next_row,
    output_buf + * out_row_ctr, (int )num_rows);
  * out_row_ctr += num_rows;
  post->next_row += num_rows;
  if(post->next_row >= post->strip_height)
  {
    post->starting_row += post->strip_height;
    post->next_row = 0;
  }
}

void jinit_d_post_controller(j_decompress_ptr cinfo , boolean need_full_buffer )
{
  my_post_ptr post ; /*decdef*/
  post = (my_post_ptr )(* (cinfo->mem)->alloc_small)((j_common_ptr )cinfo, 1,
    (size_t )sizeof(my_post_controller ));
  cinfo->post = (struct jpeg_d_post_controller *  )post;
  (post->pub).start_pass = start_pass_dpost;
  post->whole_image = (void *  )0;
  if(cinfo->quantize_colors)
  {
    post->strip_height = (JDIMENSION )cinfo->max_v_samp_factor;
    if(need_full_buffer)
    {
      post->whole_image = (* (cinfo->mem)->request_virt_sarray)((j_common_ptr
	)cinfo, 1, cinfo->output_width * cinfo->out_color_components,
	cinfo->output_height, post->strip_height);
    }
    else
    {
      post->buffer = (* (cinfo->mem)->alloc_sarray)((j_common_ptr )cinfo, 1,
	cinfo->output_width * cinfo->out_color_components, post->strip_height);
    }
  }
}


#pragma combiner("./jddctmgr.i", "-g -O -I/home/scott/wrk/safec/cil/lib ")

#pragma boxalloc("malloc", nozero, sizein(0))

#pragma boxalloc("alloca", nozero, sizein(0))

#pragma boxalloc("calloc", zero, sizemul(0, 1))

#pragma boxprintf("printf", 0)

#pragma boxprintf("fprintf", 1)

#pragma boxprintf("sprintf", 1)

#pragma boxprintf("snprintf", 2)

#pragma boxpoly("memcpy")

#pragma boxexported("main")
typedef struct  {
  struct jpeg_inverse_dct pub ;
  J_DCT_METHOD real_method[10] ;
} my_idct_controller ; /*typedef*/

typedef my_idct_controller *  my_idct_ptr ; /*typedef*/

static const int ZIG[64] = {0, 1, 5, 6, 14, 15, 27, 28, 2, 4, 7, 13, 16, 26, 29,
  42, 3, 8, 12, 17, 25, 30, 41, 43, 9, 11, 18, 24, 31, 40, 44, 53, 10, 19, 23,
  32, 39, 45, 52, 54, 20, 22, 33, 38, 46, 51, 55, 60, 21, 34, 37, 47, 50, 56,
  59, 61, 35, 36, 48, 49, 57, 58, 62, 63}; /*decdef*/

static void start_input_pass(j_decompress_ptr cinfo )
{
  my_idct_ptr idct = (my_idct_ptr )cinfo->idct; /*decdef*/
  int ci , qtblno , i ; /*decdef*/
  jpeg_component_info *  compptr ; /*decdef*/
  JQUANT_TBL *  qtbl ; /*decdef*/
  for(ci = 0; ci < cinfo->comps_in_scan; ci++)
  {
    compptr = (cinfo->cur_comp_info)[ci];
    qtblno = compptr->quant_tbl_no;
    if(qtblno < 0 || qtblno >= 4 || (cinfo->quant_tbl_ptrs)[qtblno] == (void * 
      )0)
      (cinfo->err)->msg_code = JERR_NO_QUANT_TABLE,
	(((cinfo->err)->msg_parm).i)[0] = qtblno, (*
	(cinfo->err)->error_exit)((j_common_ptr )cinfo);
    qtbl = (cinfo->quant_tbl_ptrs)[qtblno];
    if(compptr->dct_table != (void *  )0)
      continue;
    switch((idct->real_method)[compptr->component_index])
    {
    case JDCT_ISLOW:
	;
      {
	ISLOW_MULT_TYPE *  ismtbl ; /*decdef*/
	compptr->dct_table = (* (cinfo->mem)->alloc_small)((j_common_ptr )cinfo,
	  1, 64 * (size_t )sizeof(ISLOW_MULT_TYPE ));
	ismtbl = (ISLOW_MULT_TYPE *  )compptr->dct_table;
	for(i = 0; i < 64; i++)
	{
	  ismtbl[i] = (ISLOW_MULT_TYPE )(qtbl->quantval)[ZIG[i]];
	}
      }
      break;
    case JDCT_IFAST:
	;
      {
	IFAST_MULT_TYPE *  ifmtbl ; /*decdef*/
	static const INT16 aanscales[64] = {16384, 22725, 21407, 19266, 16384,
	  12873, 8867, 4520, 22725, 31521, 29692, 26722, 22725, 17855, 12299,
	  6270, 21407, 29692, 27969, 25172, 21407, 16819, 11585, 5906, 19266,
	  26722, 25172, 22654, 19266, 15137, 10426, 5315, 16384, 22725, 21407,
	  19266, 16384, 12873, 8867, 4520, 12873, 17855, 16819, 15137, 12873,
	  10114, 6967, 3552, 8867, 12299, 11585, 10426, 8867, 6967, 4799, 2446,
	  4520, 6270, 5906, 5315, 4520, 3552, 2446, 1247}; /*decdef*/
	compptr->dct_table = (* (cinfo->mem)->alloc_small)((j_common_ptr )cinfo,
	  1, 64 * (size_t )sizeof(IFAST_MULT_TYPE ));
	ifmtbl = (IFAST_MULT_TYPE *  )compptr->dct_table;
	for(i = 0; i < 64; i++)
	{
	  ifmtbl[i] = (IFAST_MULT_TYPE )((INT32 )(qtbl->quantval)[ZIG[i]] *
	    (INT32 )aanscales[i] + ((INT32 )1 << 14 - 2 - 1) >> 14 - 2);
	}
      }
      break;
    case JDCT_FLOAT:
	;
      {
	FLOAT_MULT_TYPE *  fmtbl ; /*decdef*/
	int row , col ; /*decdef*/
	static const double aanscalefactor[8] = {1.0, 1.387039845, 1.306562965,
	  1.175875602, 1.0, 0.785694958, 0.541196100, 0.275899379}; /*decdef*/
	compptr->dct_table = (* (cinfo->mem)->alloc_small)((j_common_ptr )cinfo,
	  1, 64 * (size_t )sizeof(FLOAT_MULT_TYPE ));
	fmtbl = (FLOAT_MULT_TYPE *  )compptr->dct_table;
	i = 0;
	for(row = 0; row < 8; row++)
	{
	  for(col = 0; col < 8; col++)
	  {
	    fmtbl[i] = (FLOAT_MULT_TYPE )((double )(qtbl->quantval)[ZIG[i]] *
	      aanscalefactor[row] * aanscalefactor[col]);
	    i++;
	  }
	}
      }
      break;
    default :
	;
      (cinfo->err)->msg_code = JERR_NOT_COMPILED, (*
	(cinfo->err)->error_exit)((j_common_ptr )cinfo);
      break;
    }
  }
}

static void start_output_pass(j_decompress_ptr cinfo )
{
  jpeg_component_info *  compptr ; /*decdef*/
  int ci ; /*decdef*/
  for(ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components; ci++,
    compptr++)
  {
    if(! compptr->component_needed)
      continue;
    if(compptr->dct_table == (void *  )0)
      (cinfo->err)->msg_code = JERR_NO_QUANT_TABLE,
	(((cinfo->err)->msg_parm).i)[0] = compptr->quant_tbl_no, (*
	(cinfo->err)->error_exit)((j_common_ptr )cinfo);
  }
}

void jinit_inverse_dct(j_decompress_ptr cinfo )
{
  my_idct_ptr idct ; /*decdef*/
  int ci ; /*decdef*/
  jpeg_component_info *  compptr ; /*decdef*/
  idct = (my_idct_ptr )(* (cinfo->mem)->alloc_small)((j_common_ptr )cinfo, 1,
    (size_t )sizeof(my_idct_controller ));
  cinfo->idct = (struct jpeg_inverse_dct *  )idct;
  (idct->pub).start_input_pass = start_input_pass;
  (idct->pub).start_output_pass = start_output_pass;
  for(ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components; ci++,
    compptr++)
  {
    compptr->dct_table = (void *  )0;
    switch(compptr->DCT_scaled_size)
    {
    case 1:
	;
      ((idct->pub).inverse_DCT)[ci] = jpeg_idct_1x1;
      (idct->real_method)[ci] = JDCT_ISLOW;
      break;
    case 2:
	;
      ((idct->pub).inverse_DCT)[ci] = jpeg_idct_2x2;
      (idct->real_method)[ci] = JDCT_ISLOW;
      break;
    case 4:
	;
      ((idct->pub).inverse_DCT)[ci] = jpeg_idct_4x4;
      (idct->real_method)[ci] = JDCT_ISLOW;
      break;
    case 8:
	;
      switch(cinfo->dct_method)
      {
      case JDCT_ISLOW:
	  ;
	((idct->pub).inverse_DCT)[ci] = jpeg_idct_islow;
	(idct->real_method)[ci] = JDCT_ISLOW;
	break;
      case JDCT_IFAST:
	  ;
	((idct->pub).inverse_DCT)[ci] = jpeg_idct_ifast;
	(idct->real_method)[ci] = JDCT_IFAST;
	break;
      case JDCT_FLOAT:
	  ;
	((idct->pub).inverse_DCT)[ci] = jpeg_idct_float;
	(idct->real_method)[ci] = JDCT_FLOAT;
	break;
      default :
	  ;
	(cinfo->err)->msg_code = JERR_NOT_COMPILED, (*
	  (cinfo->err)->error_exit)((j_common_ptr )cinfo);
	break;
      }
      break;
    default :
	;
      (cinfo->err)->msg_code = JERR_BAD_DCTSIZE, (((cinfo->err)->msg_parm).i)[0]
	= compptr->DCT_scaled_size, (* (cinfo->err)->error_exit)((j_common_ptr
	)cinfo);
      break;
    }
  }
}


#pragma combiner("./jidctfst.i", "-g -O -I/home/scott/wrk/safec/cil/lib ")

#pragma boxalloc("malloc", nozero, sizein(0))

#pragma boxalloc("alloca", nozero, sizein(0))

#pragma boxalloc("calloc", zero, sizemul(0, 1))

#pragma boxprintf("printf", 0)

#pragma boxprintf("fprintf", 1)

#pragma boxprintf("sprintf", 1)

#pragma boxprintf("snprintf", 2)

#pragma boxpoly("memcpy")

#pragma boxexported("main")
void jpeg_idct_ifast(j_decompress_ptr cinfo , jpeg_component_info *  compptr ,
  JCOEFPTR coef_block , JSAMPARRAY output_buf , JDIMENSION output_col )
{
  DCTELEM tmp0 , tmp1 , tmp2 , tmp3 , tmp4 , tmp5 , tmp6 , tmp7 ; /*decdef*/
  DCTELEM tmp10 , tmp11 , tmp12 , tmp13 ; /*decdef*/
  DCTELEM z5 , z10 , z11 , z12 , z13 ; /*decdef*/
  JCOEFPTR inptr ; /*decdef*/
  IFAST_MULT_TYPE *  quantptr ; /*decdef*/
  int *  wsptr ; /*decdef*/
  JSAMPROW outptr ; /*decdef*/
  JSAMPLE *  range_limit = cinfo->sample_range_limit + 128; /*decdef*/
  int ctr ; /*decdef*/
  int workspace[64] ; /*decdef*/
  inptr = coef_block;
  quantptr = (IFAST_MULT_TYPE *  )compptr->dct_table;
  wsptr = workspace;
  for(ctr = 8; ctr > 0; ctr--)
  {
    if((inptr[8 * 1] | inptr[8 * 2] | inptr[8 * 3] | inptr[8 * 4] | inptr[8 * 5]
      | inptr[8 * 6] | inptr[8 * 7]) == 0)
    {
      int dcval = (int )((IFAST_MULT_TYPE )inptr[8 * 0] * quantptr[8 *
	0]); /*decdef*/
      wsptr[8 * 0] = dcval;
      wsptr[8 * 1] = dcval;
      wsptr[8 * 2] = dcval;
      wsptr[8 * 3] = dcval;
      wsptr[8 * 4] = dcval;
      wsptr[8 * 5] = dcval;
      wsptr[8 * 6] = dcval;
      wsptr[8 * 7] = dcval;
      inptr++;
      quantptr++;
      wsptr++;
      continue;
    }
    tmp0 = (IFAST_MULT_TYPE )inptr[8 * 0] * quantptr[8 * 0];
    tmp1 = (IFAST_MULT_TYPE )inptr[8 * 2] * quantptr[8 * 2];
    tmp2 = (IFAST_MULT_TYPE )inptr[8 * 4] * quantptr[8 * 4];
    tmp3 = (IFAST_MULT_TYPE )inptr[8 * 6] * quantptr[8 * 6];
    tmp10 = tmp0 + tmp2;
    tmp11 = tmp0 - tmp2;
    tmp13 = tmp1 + tmp3;
    tmp12 = (DCTELEM )((tmp1 - tmp3) * (INT32 )362 >> 8) - tmp13;
    tmp0 = tmp10 + tmp13;
    tmp3 = tmp10 - tmp13;
    tmp1 = tmp11 + tmp12;
    tmp2 = tmp11 - tmp12;
    tmp4 = (IFAST_MULT_TYPE )inptr[8 * 1] * quantptr[8 * 1];
    tmp5 = (IFAST_MULT_TYPE )inptr[8 * 3] * quantptr[8 * 3];
    tmp6 = (IFAST_MULT_TYPE )inptr[8 * 5] * quantptr[8 * 5];
    tmp7 = (IFAST_MULT_TYPE )inptr[8 * 7] * quantptr[8 * 7];
    z13 = tmp6 + tmp5;
    z10 = tmp6 - tmp5;
    z11 = tmp4 + tmp7;
    z12 = tmp4 - tmp7;
    tmp7 = z11 + z13;
    tmp11 = (DCTELEM )((z11 - z13) * (INT32 )362 >> 8);
    z5 = (DCTELEM )((z10 + z12) * (INT32 )473 >> 8);
    tmp10 = (DCTELEM )(z12 * (INT32 )277 >> 8) - z5;
    tmp12 = (DCTELEM )(z10 * - (INT32 )669 >> 8) + z5;
    tmp6 = tmp12 - tmp7;
    tmp5 = tmp11 - tmp6;
    tmp4 = tmp10 + tmp5;
    wsptr[8 * 0] = (int )(tmp0 + tmp7);
    wsptr[8 * 7] = (int )(tmp0 - tmp7);
    wsptr[8 * 1] = (int )(tmp1 + tmp6);
    wsptr[8 * 6] = (int )(tmp1 - tmp6);
    wsptr[8 * 2] = (int )(tmp2 + tmp5);
    wsptr[8 * 5] = (int )(tmp2 - tmp5);
    wsptr[8 * 4] = (int )(tmp3 + tmp4);
    wsptr[8 * 3] = (int )(tmp3 - tmp4);
    inptr++;
    quantptr++;
    wsptr++;
  }
  wsptr = workspace;
  for(ctr = 0; ctr < 8; ctr++)
  {
    outptr = output_buf[ctr] + output_col;
    if((wsptr[1] | wsptr[2] | wsptr[3] | wsptr[4] | wsptr[5] | wsptr[6] |
      wsptr[7]) == 0)
    {
      JSAMPLE dcval = range_limit[(int )(wsptr[0] >> 2 + 3) & 255 * 4 +
	3]; /*decdef*/
      outptr[0] = dcval;
      outptr[1] = dcval;
      outptr[2] = dcval;
      outptr[3] = dcval;
      outptr[4] = dcval;
      outptr[5] = dcval;
      outptr[6] = dcval;
      outptr[7] = dcval;
      wsptr += 8;
      continue;
    }
    tmp10 = (DCTELEM )wsptr[0] + (DCTELEM )wsptr[4];
    tmp11 = (DCTELEM )wsptr[0] - (DCTELEM )wsptr[4];
    tmp13 = (DCTELEM )wsptr[2] + (DCTELEM )wsptr[6];
    tmp12 = (DCTELEM )(((DCTELEM )wsptr[2] - (DCTELEM )wsptr[6]) * (INT32 )362
      >> 8) - tmp13;
    tmp0 = tmp10 + tmp13;
    tmp3 = tmp10 - tmp13;
    tmp1 = tmp11 + tmp12;
    tmp2 = tmp11 - tmp12;
    z13 = (DCTELEM )wsptr[5] + (DCTELEM )wsptr[3];
    z10 = (DCTELEM )wsptr[5] - (DCTELEM )wsptr[3];
    z11 = (DCTELEM )wsptr[1] + (DCTELEM )wsptr[7];
    z12 = (DCTELEM )wsptr[1] - (DCTELEM )wsptr[7];
    tmp7 = z11 + z13;
    tmp11 = (DCTELEM )((z11 - z13) * (INT32 )362 >> 8);
    z5 = (DCTELEM )((z10 + z12) * (INT32 )473 >> 8);
    tmp10 = (DCTELEM )(z12 * (INT32 )277 >> 8) - z5;
    tmp12 = (DCTELEM )(z10 * - (INT32 )669 >> 8) + z5;
    tmp6 = tmp12 - tmp7;
    tmp5 = tmp11 - tmp6;
    tmp4 = tmp10 + tmp5;
    outptr[0] = range_limit[(int )(tmp0 + tmp7 >> 2 + 3) & 255 * 4 + 3];
    outptr[7] = range_limit[(int )(tmp0 - tmp7 >> 2 + 3) & 255 * 4 + 3];
    outptr[1] = range_limit[(int )(tmp1 + tmp6 >> 2 + 3) & 255 * 4 + 3];
    outptr[6] = range_limit[(int )(tmp1 - tmp6 >> 2 + 3) & 255 * 4 + 3];
    outptr[2] = range_limit[(int )(tmp2 + tmp5 >> 2 + 3) & 255 * 4 + 3];
    outptr[5] = range_limit[(int )(tmp2 - tmp5 >> 2 + 3) & 255 * 4 + 3];
    outptr[4] = range_limit[(int )(tmp3 + tmp4 >> 2 + 3) & 255 * 4 + 3];
    outptr[3] = range_limit[(int )(tmp3 - tmp4 >> 2 + 3) & 255 * 4 + 3];
    wsptr += 8;
  }
}


#pragma combiner("./jidctflt.i", "-g -O -I/home/scott/wrk/safec/cil/lib ")

#pragma boxalloc("malloc", nozero, sizein(0))

#pragma boxalloc("alloca", nozero, sizein(0))

#pragma boxalloc("calloc", zero, sizemul(0, 1))

#pragma boxprintf("printf", 0)

#pragma boxprintf("fprintf", 1)

#pragma boxprintf("sprintf", 1)

#pragma boxprintf("snprintf", 2)

#pragma boxpoly("memcpy")

#pragma boxexported("main")
void jpeg_idct_float(j_decompress_ptr cinfo , jpeg_component_info *  compptr ,
  JCOEFPTR coef_block , JSAMPARRAY output_buf , JDIMENSION output_col )
{
  float tmp0 , tmp1 , tmp2 , tmp3 , tmp4 , tmp5 , tmp6 , tmp7 ; /*decdef*/
  float tmp10 , tmp11 , tmp12 , tmp13 ; /*decdef*/
  float z5 , z10 , z11 , z12 , z13 ; /*decdef*/
  JCOEFPTR inptr ; /*decdef*/
  FLOAT_MULT_TYPE *  quantptr ; /*decdef*/
  float *  wsptr ; /*decdef*/
  JSAMPROW outptr ; /*decdef*/
  JSAMPLE *  range_limit = cinfo->sample_range_limit + 128; /*decdef*/
  int ctr ; /*decdef*/
  float workspace[64] ; /*decdef*/
  inptr = coef_block;
  quantptr = (FLOAT_MULT_TYPE *  )compptr->dct_table;
  wsptr = workspace;
  for(ctr = 8; ctr > 0; ctr--)
  {
    if((inptr[8 * 1] | inptr[8 * 2] | inptr[8 * 3] | inptr[8 * 4] | inptr[8 * 5]
      | inptr[8 * 6] | inptr[8 * 7]) == 0)
    {
      float dcval = (float )inptr[8 * 0] * quantptr[8 * 0]; /*decdef*/
      wsptr[8 * 0] = dcval;
      wsptr[8 * 1] = dcval;
      wsptr[8 * 2] = dcval;
      wsptr[8 * 3] = dcval;
      wsptr[8 * 4] = dcval;
      wsptr[8 * 5] = dcval;
      wsptr[8 * 6] = dcval;
      wsptr[8 * 7] = dcval;
      inptr++;
      quantptr++;
      wsptr++;
      continue;
    }
    tmp0 = (float )inptr[8 * 0] * quantptr[8 * 0];
    tmp1 = (float )inptr[8 * 2] * quantptr[8 * 2];
    tmp2 = (float )inptr[8 * 4] * quantptr[8 * 4];
    tmp3 = (float )inptr[8 * 6] * quantptr[8 * 6];
    tmp10 = tmp0 + tmp2;
    tmp11 = tmp0 - tmp2;
    tmp13 = tmp1 + tmp3;
    tmp12 = (tmp1 - tmp3) * (float )1.414213562 - tmp13;
    tmp0 = tmp10 + tmp13;
    tmp3 = tmp10 - tmp13;
    tmp1 = tmp11 + tmp12;
    tmp2 = tmp11 - tmp12;
    tmp4 = (float )inptr[8 * 1] * quantptr[8 * 1];
    tmp5 = (float )inptr[8 * 3] * quantptr[8 * 3];
    tmp6 = (float )inptr[8 * 5] * quantptr[8 * 5];
    tmp7 = (float )inptr[8 * 7] * quantptr[8 * 7];
    z13 = tmp6 + tmp5;
    z10 = tmp6 - tmp5;
    z11 = tmp4 + tmp7;
    z12 = tmp4 - tmp7;
    tmp7 = z11 + z13;
    tmp11 = (z11 - z13) * (float )1.414213562;
    z5 = (z10 + z12) * (float )1.847759065;
    tmp10 = (float )1.082392200 * z12 - z5;
    tmp12 = (float )(- 2.613125930) * z10 + z5;
    tmp6 = tmp12 - tmp7;
    tmp5 = tmp11 - tmp6;
    tmp4 = tmp10 + tmp5;
    wsptr[8 * 0] = tmp0 + tmp7;
    wsptr[8 * 7] = tmp0 - tmp7;
    wsptr[8 * 1] = tmp1 + tmp6;
    wsptr[8 * 6] = tmp1 - tmp6;
    wsptr[8 * 2] = tmp2 + tmp5;
    wsptr[8 * 5] = tmp2 - tmp5;
    wsptr[8 * 4] = tmp3 + tmp4;
    wsptr[8 * 3] = tmp3 - tmp4;
    inptr++;
    quantptr++;
    wsptr++;
  }
  wsptr = workspace;
  for(ctr = 0; ctr < 8; ctr++)
  {
    outptr = output_buf[ctr] + output_col;
    tmp10 = wsptr[0] + wsptr[4];
    tmp11 = wsptr[0] - wsptr[4];
    tmp13 = wsptr[2] + wsptr[6];
    tmp12 = (wsptr[2] - wsptr[6]) * (float )1.414213562 - tmp13;
    tmp0 = tmp10 + tmp13;
    tmp3 = tmp10 - tmp13;
    tmp1 = tmp11 + tmp12;
    tmp2 = tmp11 - tmp12;
    z13 = wsptr[5] + wsptr[3];
    z10 = wsptr[5] - wsptr[3];
    z11 = wsptr[1] + wsptr[7];
    z12 = wsptr[1] - wsptr[7];
    tmp7 = z11 + z13;
    tmp11 = (z11 - z13) * (float )1.414213562;
    z5 = (z10 + z12) * (float )1.847759065;
    tmp10 = (float )1.082392200 * z12 - z5;
    tmp12 = (float )(- 2.613125930) * z10 + z5;
    tmp6 = tmp12 - tmp7;
    tmp5 = tmp11 - tmp6;
    tmp4 = tmp10 + tmp5;
    outptr[0] = range_limit[(int )((INT32 )(tmp0 + tmp7) + ((INT32 )1 << 3 - 1)
      >> 3) & 255 * 4 + 3];
    outptr[7] = range_limit[(int )((INT32 )(tmp0 - tmp7) + ((INT32 )1 << 3 - 1)
      >> 3) & 255 * 4 + 3];
    outptr[1] = range_limit[(int )((INT32 )(tmp1 + tmp6) + ((INT32 )1 << 3 - 1)
      >> 3) & 255 * 4 + 3];
    outptr[6] = range_limit[(int )((INT32 )(tmp1 - tmp6) + ((INT32 )1 << 3 - 1)
      >> 3) & 255 * 4 + 3];
    outptr[2] = range_limit[(int )((INT32 )(tmp2 + tmp5) + ((INT32 )1 << 3 - 1)
      >> 3) & 255 * 4 + 3];
    outptr[5] = range_limit[(int )((INT32 )(tmp2 - tmp5) + ((INT32 )1 << 3 - 1)
      >> 3) & 255 * 4 + 3];
    outptr[4] = range_limit[(int )((INT32 )(tmp3 + tmp4) + ((INT32 )1 << 3 - 1)
      >> 3) & 255 * 4 + 3];
    outptr[3] = range_limit[(int )((INT32 )(tmp3 - tmp4) + ((INT32 )1 << 3 - 1)
      >> 3) & 255 * 4 + 3];
    wsptr += 8;
  }
}


#pragma combiner("./jidctint.i", "-g -O -I/home/scott/wrk/safec/cil/lib ")

#pragma boxalloc("malloc", nozero, sizein(0))

#pragma boxalloc("alloca", nozero, sizein(0))

#pragma boxalloc("calloc", zero, sizemul(0, 1))

#pragma boxprintf("printf", 0)

#pragma boxprintf("fprintf", 1)

#pragma boxprintf("sprintf", 1)

#pragma boxprintf("snprintf", 2)

#pragma boxpoly("memcpy")

#pragma boxexported("main")
void jpeg_idct_islow(j_decompress_ptr cinfo , jpeg_component_info *  compptr ,
  JCOEFPTR coef_block , JSAMPARRAY output_buf , JDIMENSION output_col )
{
  INT32 tmp0 , tmp1 , tmp2 , tmp3 ; /*decdef*/
  INT32 tmp10 , tmp11 , tmp12 , tmp13 ; /*decdef*/
  INT32 z1 , z2 , z3 , z4 , z5 ; /*decdef*/
  JCOEFPTR inptr ; /*decdef*/
  ISLOW_MULT_TYPE *  quantptr ; /*decdef*/
  int *  wsptr ; /*decdef*/
  JSAMPROW outptr ; /*decdef*/
  JSAMPLE *  range_limit = cinfo->sample_range_limit + 128; /*decdef*/
  int ctr ; /*decdef*/
  int workspace[64] ; /*decdef*/
  inptr = coef_block;
  quantptr = (ISLOW_MULT_TYPE *  )compptr->dct_table;
  wsptr = workspace;
  for(ctr = 8; ctr > 0; ctr--)
  {
    if((inptr[8 * 1] | inptr[8 * 2] | inptr[8 * 3] | inptr[8 * 4] | inptr[8 * 5]
      | inptr[8 * 6] | inptr[8 * 7]) == 0)
    {
      int dcval = (ISLOW_MULT_TYPE )inptr[8 * 0] * quantptr[8 * 0] <<
	2; /*decdef*/
      wsptr[8 * 0] = dcval;
      wsptr[8 * 1] = dcval;
      wsptr[8 * 2] = dcval;
      wsptr[8 * 3] = dcval;
      wsptr[8 * 4] = dcval;
      wsptr[8 * 5] = dcval;
      wsptr[8 * 6] = dcval;
      wsptr[8 * 7] = dcval;
      inptr++;
      quantptr++;
      wsptr++;
      continue;
    }
    z2 = (ISLOW_MULT_TYPE )inptr[8 * 2] * quantptr[8 * 2];
    z3 = (ISLOW_MULT_TYPE )inptr[8 * 6] * quantptr[8 * 6];
    z1 = (z2 + z3) * (INT32 )4433;
    tmp2 = z1 + z3 * - (INT32 )15137;
    tmp3 = z1 + z2 * (INT32 )6270;
    z2 = (ISLOW_MULT_TYPE )inptr[8 * 0] * quantptr[8 * 0];
    z3 = (ISLOW_MULT_TYPE )inptr[8 * 4] * quantptr[8 * 4];
    tmp0 = z2 + z3 << 13;
    tmp1 = z2 - z3 << 13;
    tmp10 = tmp0 + tmp3;
    tmp13 = tmp0 - tmp3;
    tmp11 = tmp1 + tmp2;
    tmp12 = tmp1 - tmp2;
    tmp0 = (ISLOW_MULT_TYPE )inptr[8 * 7] * quantptr[8 * 7];
    tmp1 = (ISLOW_MULT_TYPE )inptr[8 * 5] * quantptr[8 * 5];
    tmp2 = (ISLOW_MULT_TYPE )inptr[8 * 3] * quantptr[8 * 3];
    tmp3 = (ISLOW_MULT_TYPE )inptr[8 * 1] * quantptr[8 * 1];
    z1 = tmp0 + tmp3;
    z2 = tmp1 + tmp2;
    z3 = tmp0 + tmp2;
    z4 = tmp1 + tmp3;
    z5 = (z3 + z4) * (INT32 )9633;
    tmp0 = tmp0 * (INT32 )2446;
    tmp1 = tmp1 * (INT32 )16819;
    tmp2 = tmp2 * (INT32 )25172;
    tmp3 = tmp3 * (INT32 )12299;
    z1 = z1 * - (INT32 )7373;
    z2 = z2 * - (INT32 )20995;
    z3 = z3 * - (INT32 )16069;
    z4 = z4 * - (INT32 )3196;
    z3 += z5;
    z4 += z5;
    tmp0 += z1 + z3;
    tmp1 += z2 + z4;
    tmp2 += z2 + z3;
    tmp3 += z1 + z4;
    wsptr[8 * 0] = (int )(tmp10 + tmp3 + ((INT32 )1 << 13 - 2 - 1) >> 13 - 2);
    wsptr[8 * 7] = (int )(tmp10 - tmp3 + ((INT32 )1 << 13 - 2 - 1) >> 13 - 2);
    wsptr[8 * 1] = (int )(tmp11 + tmp2 + ((INT32 )1 << 13 - 2 - 1) >> 13 - 2);
    wsptr[8 * 6] = (int )(tmp11 - tmp2 + ((INT32 )1 << 13 - 2 - 1) >> 13 - 2);
    wsptr[8 * 2] = (int )(tmp12 + tmp1 + ((INT32 )1 << 13 - 2 - 1) >> 13 - 2);
    wsptr[8 * 5] = (int )(tmp12 - tmp1 + ((INT32 )1 << 13 - 2 - 1) >> 13 - 2);
    wsptr[8 * 3] = (int )(tmp13 + tmp0 + ((INT32 )1 << 13 - 2 - 1) >> 13 - 2);
    wsptr[8 * 4] = (int )(tmp13 - tmp0 + ((INT32 )1 << 13 - 2 - 1) >> 13 - 2);
    inptr++;
    quantptr++;
    wsptr++;
  }
  wsptr = workspace;
  for(ctr = 0; ctr < 8; ctr++)
  {
    outptr = output_buf[ctr] + output_col;
    if((wsptr[1] | wsptr[2] | wsptr[3] | wsptr[4] | wsptr[5] | wsptr[6] |
      wsptr[7]) == 0)
    {
      JSAMPLE dcval = range_limit[(int )((INT32 )wsptr[0] + ((INT32 )1 << 2 + 3
	- 1) >> 2 + 3) & 255 * 4 + 3]; /*decdef*/
      outptr[0] = dcval;
      outptr[1] = dcval;
      outptr[2] = dcval;
      outptr[3] = dcval;
      outptr[4] = dcval;
      outptr[5] = dcval;
      outptr[6] = dcval;
      outptr[7] = dcval;
      wsptr += 8;
      continue;
    }
    z2 = (INT32 )wsptr[2];
    z3 = (INT32 )wsptr[6];
    z1 = (z2 + z3) * (INT32 )4433;
    tmp2 = z1 + z3 * - (INT32 )15137;
    tmp3 = z1 + z2 * (INT32 )6270;
    tmp0 = (INT32 )wsptr[0] + (INT32 )wsptr[4] << 13;
    tmp1 = (INT32 )wsptr[0] - (INT32 )wsptr[4] << 13;
    tmp10 = tmp0 + tmp3;
    tmp13 = tmp0 - tmp3;
    tmp11 = tmp1 + tmp2;
    tmp12 = tmp1 - tmp2;
    tmp0 = (INT32 )wsptr[7];
    tmp1 = (INT32 )wsptr[5];
    tmp2 = (INT32 )wsptr[3];
    tmp3 = (INT32 )wsptr[1];
    z1 = tmp0 + tmp3;
    z2 = tmp1 + tmp2;
    z3 = tmp0 + tmp2;
    z4 = tmp1 + tmp3;
    z5 = (z3 + z4) * (INT32 )9633;
    tmp0 = tmp0 * (INT32 )2446;
    tmp1 = tmp1 * (INT32 )16819;
    tmp2 = tmp2 * (INT32 )25172;
    tmp3 = tmp3 * (INT32 )12299;
    z1 = z1 * - (INT32 )7373;
    z2 = z2 * - (INT32 )20995;
    z3 = z3 * - (INT32 )16069;
    z4 = z4 * - (INT32 )3196;
    z3 += z5;
    z4 += z5;
    tmp0 += z1 + z3;
    tmp1 += z2 + z4;
    tmp2 += z2 + z3;
    tmp3 += z1 + z4;
    outptr[0] = range_limit[(int )(tmp10 + tmp3 + ((INT32 )1 << 13 + 2 + 3 - 1)
      >> 13 + 2 + 3) & 255 * 4 + 3];
    outptr[7] = range_limit[(int )(tmp10 - tmp3 + ((INT32 )1 << 13 + 2 + 3 - 1)
      >> 13 + 2 + 3) & 255 * 4 + 3];
    outptr[1] = range_limit[(int )(tmp11 + tmp2 + ((INT32 )1 << 13 + 2 + 3 - 1)
      >> 13 + 2 + 3) & 255 * 4 + 3];
    outptr[6] = range_limit[(int )(tmp11 - tmp2 + ((INT32 )1 << 13 + 2 + 3 - 1)
      >> 13 + 2 + 3) & 255 * 4 + 3];
    outptr[2] = range_limit[(int )(tmp12 + tmp1 + ((INT32 )1 << 13 + 2 + 3 - 1)
      >> 13 + 2 + 3) & 255 * 4 + 3];
    outptr[5] = range_limit[(int )(tmp12 - tmp1 + ((INT32 )1 << 13 + 2 + 3 - 1)
      >> 13 + 2 + 3) & 255 * 4 + 3];
    outptr[3] = range_limit[(int )(tmp13 + tmp0 + ((INT32 )1 << 13 + 2 + 3 - 1)
      >> 13 + 2 + 3) & 255 * 4 + 3];
    outptr[4] = range_limit[(int )(tmp13 - tmp0 + ((INT32 )1 << 13 + 2 + 3 - 1)
      >> 13 + 2 + 3) & 255 * 4 + 3];
    wsptr += 8;
  }
}


#pragma combiner("./jidctred.i", "-g -O -I/home/scott/wrk/safec/cil/lib ")

#pragma boxalloc("malloc", nozero, sizein(0))

#pragma boxalloc("alloca", nozero, sizein(0))

#pragma boxalloc("calloc", zero, sizemul(0, 1))

#pragma boxprintf("printf", 0)

#pragma boxprintf("fprintf", 1)

#pragma boxprintf("sprintf", 1)

#pragma boxprintf("snprintf", 2)

#pragma boxpoly("memcpy")

#pragma boxexported("main")
void jpeg_idct_4x4(j_decompress_ptr cinfo , jpeg_component_info *  compptr ,
  JCOEFPTR coef_block , JSAMPARRAY output_buf , JDIMENSION output_col )
{
  INT32 tmp0 , tmp2 , tmp10 , tmp12 ; /*decdef*/
  INT32 z1 , z2 , z3 , z4 ; /*decdef*/
  JCOEFPTR inptr ; /*decdef*/
  ISLOW_MULT_TYPE *  quantptr ; /*decdef*/
  int *  wsptr ; /*decdef*/
  JSAMPROW outptr ; /*decdef*/
  JSAMPLE *  range_limit = cinfo->sample_range_limit + 128; /*decdef*/
  int ctr ; /*decdef*/
  int workspace[8 * 4] ; /*decdef*/
  inptr = coef_block;
  quantptr = (ISLOW_MULT_TYPE *  )compptr->dct_table;
  wsptr = workspace;
  for(ctr = 8; ctr > 0; inptr++, quantptr++, wsptr++, ctr--)
  {
    if(ctr == 8 - 4)
      continue;
    if((inptr[8 * 1] | inptr[8 * 2] | inptr[8 * 3] | inptr[8 * 5] | inptr[8 * 6]
      | inptr[8 * 7]) == 0)
    {
      int dcval = (ISLOW_MULT_TYPE )inptr[8 * 0] * quantptr[8 * 0] <<
	2; /*decdef*/
      wsptr[8 * 0] = dcval;
      wsptr[8 * 1] = dcval;
      wsptr[8 * 2] = dcval;
      wsptr[8 * 3] = dcval;
      continue;
    }
    tmp0 = (ISLOW_MULT_TYPE )inptr[8 * 0] * quantptr[8 * 0];
    tmp0 <<= 13 + 1;
    z2 = (ISLOW_MULT_TYPE )inptr[8 * 2] * quantptr[8 * 2];
    z3 = (ISLOW_MULT_TYPE )inptr[8 * 6] * quantptr[8 * 6];
    tmp2 = z2 * (INT32 )15137 + z3 * - (INT32 )6270;
    tmp10 = tmp0 + tmp2;
    tmp12 = tmp0 - tmp2;
    z1 = (ISLOW_MULT_TYPE )inptr[8 * 7] * quantptr[8 * 7];
    z2 = (ISLOW_MULT_TYPE )inptr[8 * 5] * quantptr[8 * 5];
    z3 = (ISLOW_MULT_TYPE )inptr[8 * 3] * quantptr[8 * 3];
    z4 = (ISLOW_MULT_TYPE )inptr[8 * 1] * quantptr[8 * 1];
    tmp0 = z1 * - (INT32 )1730 + z2 * (INT32 )11893 + z3 * - (INT32 )17799 + z4
      * (INT32 )8697;
    tmp2 = z1 * - (INT32 )4176 + z2 * - (INT32 )4926 + z3 * (INT32 )7373 + z4 *
      (INT32 )20995;
    wsptr[8 * 0] = (int )(tmp10 + tmp2 + ((INT32 )1 << 13 - 2 + 1 - 1) >> 13 - 2
      + 1);
    wsptr[8 * 3] = (int )(tmp10 - tmp2 + ((INT32 )1 << 13 - 2 + 1 - 1) >> 13 - 2
      + 1);
    wsptr[8 * 1] = (int )(tmp12 + tmp0 + ((INT32 )1 << 13 - 2 + 1 - 1) >> 13 - 2
      + 1);
    wsptr[8 * 2] = (int )(tmp12 - tmp0 + ((INT32 )1 << 13 - 2 + 1 - 1) >> 13 - 2
      + 1);
  }
  wsptr = workspace;
  for(ctr = 0; ctr < 4; ctr++)
  {
    outptr = output_buf[ctr] + output_col;
    if((wsptr[1] | wsptr[2] | wsptr[3] | wsptr[5] | wsptr[6] | wsptr[7]) == 0)
    {
      JSAMPLE dcval = range_limit[(int )((INT32 )wsptr[0] + ((INT32 )1 << 2 + 3
	- 1) >> 2 + 3) & 255 * 4 + 3]; /*decdef*/
      outptr[0] = dcval;
      outptr[1] = dcval;
      outptr[2] = dcval;
      outptr[3] = dcval;
      wsptr += 8;
      continue;
    }
    tmp0 = (INT32 )wsptr[0] << 13 + 1;
    tmp2 = (INT32 )wsptr[2] * (INT32 )15137 + (INT32 )wsptr[6] * - (INT32 )6270;
    tmp10 = tmp0 + tmp2;
    tmp12 = tmp0 - tmp2;
    z1 = (INT32 )wsptr[7];
    z2 = (INT32 )wsptr[5];
    z3 = (INT32 )wsptr[3];
    z4 = (INT32 )wsptr[1];
    tmp0 = z1 * - (INT32 )1730 + z2 * (INT32 )11893 + z3 * - (INT32 )17799 + z4
      * (INT32 )8697;
    tmp2 = z1 * - (INT32 )4176 + z2 * - (INT32 )4926 + z3 * (INT32 )7373 + z4 *
      (INT32 )20995;
    outptr[0] = range_limit[(int )(tmp10 + tmp2 + ((INT32 )1 << 13 + 2 + 3 + 1 -
      1) >> 13 + 2 + 3 + 1) & 255 * 4 + 3];
    outptr[3] = range_limit[(int )(tmp10 - tmp2 + ((INT32 )1 << 13 + 2 + 3 + 1 -
      1) >> 13 + 2 + 3 + 1) & 255 * 4 + 3];
    outptr[1] = range_limit[(int )(tmp12 + tmp0 + ((INT32 )1 << 13 + 2 + 3 + 1 -
      1) >> 13 + 2 + 3 + 1) & 255 * 4 + 3];
    outptr[2] = range_limit[(int )(tmp12 - tmp0 + ((INT32 )1 << 13 + 2 + 3 + 1 -
      1) >> 13 + 2 + 3 + 1) & 255 * 4 + 3];
    wsptr += 8;
  }
}

void jpeg_idct_2x2(j_decompress_ptr cinfo , jpeg_component_info *  compptr ,
  JCOEFPTR coef_block , JSAMPARRAY output_buf , JDIMENSION output_col )
{
  INT32 tmp0 , tmp10 , z1 ; /*decdef*/
  JCOEFPTR inptr ; /*decdef*/
  ISLOW_MULT_TYPE *  quantptr ; /*decdef*/
  int *  wsptr ; /*decdef*/
  JSAMPROW outptr ; /*decdef*/
  JSAMPLE *  range_limit = cinfo->sample_range_limit + 128; /*decdef*/
  int ctr ; /*decdef*/
  int workspace[8 * 2] ; /*decdef*/
  inptr = coef_block;
  quantptr = (ISLOW_MULT_TYPE *  )compptr->dct_table;
  wsptr = workspace;
  for(ctr = 8; ctr > 0; inptr++, quantptr++, wsptr++, ctr--)
  {
    if(ctr == 8 - 2 || ctr == 8 - 4 || ctr == 8 - 6)
      continue;
    if((inptr[8 * 1] | inptr[8 * 3] | inptr[8 * 5] | inptr[8 * 7]) == 0)
    {
      int dcval = (ISLOW_MULT_TYPE )inptr[8 * 0] * quantptr[8 * 0] <<
	2; /*decdef*/
      wsptr[8 * 0] = dcval;
      wsptr[8 * 1] = dcval;
      continue;
    }
    z1 = (ISLOW_MULT_TYPE )inptr[8 * 0] * quantptr[8 * 0];
    tmp10 = z1 << 13 + 2;
    z1 = (ISLOW_MULT_TYPE )inptr[8 * 7] * quantptr[8 * 7];
    tmp0 = z1 * - (INT32 )5906;
    z1 = (ISLOW_MULT_TYPE )inptr[8 * 5] * quantptr[8 * 5];
    tmp0 += z1 * (INT32 )6967;
    z1 = (ISLOW_MULT_TYPE )inptr[8 * 3] * quantptr[8 * 3];
    tmp0 += z1 * - (INT32 )10426;
    z1 = (ISLOW_MULT_TYPE )inptr[8 * 1] * quantptr[8 * 1];
    tmp0 += z1 * (INT32 )29692;
    wsptr[8 * 0] = (int )(tmp10 + tmp0 + ((INT32 )1 << 13 - 2 + 2 - 1) >> 13 - 2
      + 2);
    wsptr[8 * 1] = (int )(tmp10 - tmp0 + ((INT32 )1 << 13 - 2 + 2 - 1) >> 13 - 2
      + 2);
  }
  wsptr = workspace;
  for(ctr = 0; ctr < 2; ctr++)
  {
    outptr = output_buf[ctr] + output_col;
    if((wsptr[1] | wsptr[3] | wsptr[5] | wsptr[7]) == 0)
    {
      JSAMPLE dcval = range_limit[(int )((INT32 )wsptr[0] + ((INT32 )1 << 2 + 3
	- 1) >> 2 + 3) & 255 * 4 + 3]; /*decdef*/
      outptr[0] = dcval;
      outptr[1] = dcval;
      wsptr += 8;
      continue;
    }
    tmp10 = (INT32 )wsptr[0] << 13 + 2;
    tmp0 = (INT32 )wsptr[7] * - (INT32 )5906 + (INT32 )wsptr[5] * (INT32 )6967 +
      (INT32 )wsptr[3] * - (INT32 )10426 + (INT32 )wsptr[1] * (INT32 )29692;
    outptr[0] = range_limit[(int )(tmp10 + tmp0 + ((INT32 )1 << 13 + 2 + 3 + 2 -
      1) >> 13 + 2 + 3 + 2) & 255 * 4 + 3];
    outptr[1] = range_limit[(int )(tmp10 - tmp0 + ((INT32 )1 << 13 + 2 + 3 + 2 -
      1) >> 13 + 2 + 3 + 2) & 255 * 4 + 3];
    wsptr += 8;
  }
}

void jpeg_idct_1x1(j_decompress_ptr cinfo , jpeg_component_info *  compptr ,
  JCOEFPTR coef_block , JSAMPARRAY output_buf , JDIMENSION output_col )
{
  int dcval ; /*decdef*/
  ISLOW_MULT_TYPE *  quantptr ; /*decdef*/
  JSAMPLE *  range_limit = cinfo->sample_range_limit + 128; /*decdef*/
  quantptr = (ISLOW_MULT_TYPE *  )compptr->dct_table;
  dcval = (ISLOW_MULT_TYPE )coef_block[0] * quantptr[0];
  dcval = (int )((INT32 )dcval + ((INT32 )1 << 3 - 1) >> 3);
  (output_buf[0])[output_col] = range_limit[dcval & 255 * 4 + 3];
}


#pragma combiner("./jdhuff.i", "-g -O -I/home/scott/wrk/safec/cil/lib ")

#pragma boxalloc("malloc", nozero, sizein(0))

#pragma boxalloc("alloca", nozero, sizein(0))

#pragma boxalloc("calloc", zero, sizemul(0, 1))

#pragma boxprintf("printf", 0)

#pragma boxprintf("fprintf", 1)

#pragma boxprintf("sprintf", 1)

#pragma boxprintf("snprintf", 2)

#pragma boxpoly("memcpy")

#pragma boxexported("main")
typedef struct  {
  INT32 mincode[17] ;
  INT32 maxcode[18] ;
  int valptr[17] ;
  JHUFF_TBL *  pub ;
  int look_nbits[1 << 8] ;
  UINT8 look_sym[1 << 8] ;
} D_DERIVED_TBL ; /*typedef*/

typedef struct  {
  INT32 get_buffer ;
  int bits_left ;
  int last_dc_val[4] ;
} savable_state__0 ; /*typedef*/

typedef struct  {
  struct jpeg_entropy_decoder pub ;
  savable_state__0 saved ;
  unsigned int restarts_to_go ;
  boolean printed_eod ;
  D_DERIVED_TBL *  dc_derived_tbls[4] ;
  D_DERIVED_TBL *  ac_derived_tbls[4] ;
} huff_entropy_decoder ; /*typedef*/

typedef huff_entropy_decoder *  huff_entropy_ptr__0 ; /*typedef*/

typedef struct  {
  int unread_marker ;
  const JOCTET *  next_input_byte ;
  size_t bytes_in_buffer ;
  savable_state__0 cur ;
  j_decompress_ptr cinfo ;
} working_state__0 ; /*typedef*/

static void fix_huff_tbl__0(j_decompress_ptr cinfo , JHUFF_TBL *  htbl ,
  D_DERIVED_TBL *  *  pdtbl ) ; /*decdef*/

static void start_pass_huff_decoder(j_decompress_ptr cinfo )
{
  huff_entropy_ptr__0 entropy = (huff_entropy_ptr__0 )cinfo->entropy; /*decdef*/
  int ci , dctbl , actbl ; /*decdef*/
  jpeg_component_info *  compptr ; /*decdef*/
  for(ci = 0; ci < cinfo->comps_in_scan; ci++)
  {
    compptr = (cinfo->cur_comp_info)[ci];
    dctbl = compptr->dc_tbl_no;
    actbl = compptr->ac_tbl_no;
    if(dctbl < 0 || dctbl >= 4 || (cinfo->dc_huff_tbl_ptrs)[dctbl] == (void * 
      )0)
      (cinfo->err)->msg_code = JERR_NO_HUFF_TABLE,
	(((cinfo->err)->msg_parm).i)[0] = dctbl, (*
	(cinfo->err)->error_exit)((j_common_ptr )cinfo);
    if(actbl < 0 || actbl >= 4 || (cinfo->ac_huff_tbl_ptrs)[actbl] == (void * 
      )0)
      (cinfo->err)->msg_code = JERR_NO_HUFF_TABLE,
	(((cinfo->err)->msg_parm).i)[0] = actbl, (*
	(cinfo->err)->error_exit)((j_common_ptr )cinfo);
    fix_huff_tbl__0(cinfo, (cinfo->dc_huff_tbl_ptrs)[dctbl], &
      (entropy->dc_derived_tbls)[dctbl]);
    fix_huff_tbl__0(cinfo, (cinfo->ac_huff_tbl_ptrs)[actbl], &
      (entropy->ac_derived_tbls)[actbl]);
    ((entropy->saved).last_dc_val)[ci] = 0;
  }
  (entropy->saved).bits_left = 0;
  entropy->printed_eod = 0;
  entropy->restarts_to_go = cinfo->restart_interval;
}

static void fix_huff_tbl__0(j_decompress_ptr cinfo , JHUFF_TBL *  htbl ,
  D_DERIVED_TBL *  *  pdtbl )
{
  D_DERIVED_TBL *  dtbl ; /*decdef*/
  int p , i , l , si ; /*decdef*/
  int lookbits , ctr ; /*decdef*/
  char huffsize[257] ; /*decdef*/
  unsigned int huffcode[257] ; /*decdef*/
  unsigned int code ; /*decdef*/
  if(* pdtbl == (void *  )0)
    * pdtbl = (D_DERIVED_TBL *  )(* (cinfo->mem)->alloc_small)((j_common_ptr
      )cinfo, 1, (size_t )sizeof(D_DERIVED_TBL ));
  dtbl = * pdtbl;
  dtbl->pub = htbl;
  p = 0;
  for(l = 1; l <= 16; l++)
  {
    for(i = 1; i <= (int )(htbl->bits)[l]; i++)
      huffsize[p++] = (char )l;
  }
  huffsize[p] = 0;
  code = 0;
  si = huffsize[0];
  p = 0;
  while(huffsize[p])
  {
    while((int )huffsize[p] == si)
    {
      huffcode[p++] = code;
      code++;
    }
    code <<= 1;
    si++;
  }
  p = 0;
  for(l = 1; l <= 16; l++)
  {
    if((htbl->bits)[l])
    {
      (dtbl->valptr)[l] = p;
      (dtbl->mincode)[l] = huffcode[p];
      p += (htbl->bits)[l];
      (dtbl->maxcode)[l] = huffcode[p - 1];
    }
    else
    {
      (dtbl->maxcode)[l] = - 1;
    }
  }
  (dtbl->maxcode)[17] = 0xFFFFFL;
  memset((void *  )dtbl->look_nbits, 0, (size_t )((size_t
    )sizeof(dtbl->look_nbits)));
  p = 0;
  for(l = 1; l <= 8; l++)
  {
    for(i = 1; i <= (int )(htbl->bits)[l]; i++, p++)
    {
      lookbits = huffcode[p] << 8 - l;
      for(ctr = 1 << 8 - l; ctr > 0; ctr--)
      {
	(dtbl->look_nbits)[lookbits] = l;
	(dtbl->look_sym)[lookbits] = (htbl->huffval)[p];
	lookbits++;
      }
    }
  }
}

static boolean fill_bit_buffer(working_state__0 *  state , int nbits )
{
  register const JOCTET *  next_input_byte = state->next_input_byte; /*decdef*/
  register size_t bytes_in_buffer = state->bytes_in_buffer; /*decdef*/
  register INT32 get_buffer = (state->cur).get_buffer; /*decdef*/
  register int bits_left = (state->cur).bits_left; /*decdef*/
  register int c ; /*decdef*/
  while(bits_left < 25)
  {
    if(state->unread_marker != 0)
      goto no_more_data;
    if(bytes_in_buffer == 0)
    {
      if(! (* ((state->cinfo)->src)->fill_input_buffer)(state->cinfo))
	return 0;
      next_input_byte = ((state->cinfo)->src)->next_input_byte;
      bytes_in_buffer = ((state->cinfo)->src)->bytes_in_buffer;
    }
    bytes_in_buffer--;
    c = * next_input_byte++;
    if(c == 0xFF)
    {
      do
      {
	if(bytes_in_buffer == 0)
	{
	  if(! (* ((state->cinfo)->src)->fill_input_buffer)(state->cinfo))
	    return 0;
	  next_input_byte = ((state->cinfo)->src)->next_input_byte;
	  bytes_in_buffer = ((state->cinfo)->src)->bytes_in_buffer;
	}
	bytes_in_buffer--;
	c = * next_input_byte++;
      }
      while(c == 0xFF);
      if(c == 0)
      {
	c = 0xFF;
      }
      else
      {
	state->unread_marker = c;
	no_more_data:
	{
	  if(bits_left >= nbits)
	    break;
	}
	if(! ((huff_entropy_ptr__0 )(state->cinfo)->entropy)->printed_eod)
	{
	  ((state->cinfo)->err)->msg_code = JWRN_HIT_MARKER, (*
	    ((state->cinfo)->err)->emit_message)((j_common_ptr )state->cinfo, -
	    1);
	  ((huff_entropy_ptr__0 )(state->cinfo)->entropy)->printed_eod = 1;
	}
	c = 0;
      }
    }
    get_buffer = get_buffer << 8 | c;
    bits_left += 8;
  }
  state->next_input_byte = next_input_byte;
  state->bytes_in_buffer = bytes_in_buffer;
  (state->cur).get_buffer = get_buffer;
  (state->cur).bits_left = bits_left;
  return 1;
}

static int slow_DECODE(working_state__0 *  state , D_DERIVED_TBL *  htbl ,
  int min_bits )
{
  register int l = min_bits; /*decdef*/
  register INT32 code ; /*decdef*/
  {
    if(((* state).cur).bits_left < l)
    {
      if(! fill_bit_buffer(& * state, l))
      {
	return - 1;
      }
    }
  }
  ;
  code = (int )(((* state).cur).get_buffer >> (((* state).cur).bits_left -= l))
    & (1 << l) - 1;
  while(code > (htbl->maxcode)[l])
  {
    code <<= 1;
    {
      if(((* state).cur).bits_left < 1)
      {
	if(! fill_bit_buffer(& * state, 1))
	{
	  return - 1;
	}
      }
    }
    ;
    code |= (int )(((* state).cur).get_buffer >> (((* state).cur).bits_left -=
      1)) & (1 << 1) - 1;
    l++;
  }
  if(l > 16)
  {
    ((state->cinfo)->err)->msg_code = JWRN_HUFF_BAD_CODE, (*
      ((state->cinfo)->err)->emit_message)((j_common_ptr )state->cinfo, - 1);
    return 0;
  }
  return ((htbl->pub)->huffval)[(htbl->valptr)[l] + (int )(code -
    (htbl->mincode)[l])];
}

static const int extend_test[16] = {0, 0x0001, 0x0002, 0x0004, 0x0008, 0x0010,
  0x0020, 0x0040, 0x0080, 0x0100, 0x0200, 0x0400, 0x0800, 0x1000, 0x2000,
  0x4000}; /*decdef*/
static const int extend_offset[16] = {0, (- 1 << 1) + 1, (- 1 << 2) + 1, (- 1 <<
  3) + 1, (- 1 << 4) + 1, (- 1 << 5) + 1, (- 1 << 6) + 1, (- 1 << 7) + 1, (- 1
  << 8) + 1, (- 1 << 9) + 1, (- 1 << 10) + 1, (- 1 << 11) + 1, (- 1 << 12) + 1,
  (- 1 << 13) + 1, (- 1 << 14) + 1, (- 1 << 15) + 1}; /*decdef*/

static boolean process_restart(j_decompress_ptr cinfo )
{
  huff_entropy_ptr__0 entropy = (huff_entropy_ptr__0 )cinfo->entropy; /*decdef*/
  int ci ; /*decdef*/
  (cinfo->marker)->discarded_bytes += (entropy->saved).bits_left / 8;
  (entropy->saved).bits_left = 0;
  if(! (* (cinfo->marker)->read_restart_marker)(cinfo))
    return 0;
  for(ci = 0; ci < cinfo->comps_in_scan; ci++)
    ((entropy->saved).last_dc_val)[ci] = 0;
  entropy->restarts_to_go = cinfo->restart_interval;
  entropy->printed_eod = 0;
  return 1;
}

static const int ZAG__0[64 + 16] = {0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25,
  18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28,
  35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52,
  45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0}; /*decdef*/

static boolean decode_mcu(j_decompress_ptr cinfo , JBLOCKROW *  MCU_data )
{
  huff_entropy_ptr__0 entropy = (huff_entropy_ptr__0 )cinfo->entropy; /*decdef*/
  register int s , k , r ; /*decdef*/
  int blkn , ci ; /*decdef*/
  JBLOCKROW block ; /*decdef*/
  working_state__0 state ; /*decdef*/
  D_DERIVED_TBL *  dctbl ; /*decdef*/
  D_DERIVED_TBL *  actbl ; /*decdef*/
  jpeg_component_info *  compptr ; /*decdef*/
  if(cinfo->restart_interval)
  {
    if(entropy->restarts_to_go == 0)
    {
      if(! process_restart(cinfo))
	return 0;
    }
  }
  state.unread_marker = cinfo->unread_marker;
  state.next_input_byte = (cinfo->src)->next_input_byte;
  state.bytes_in_buffer = (cinfo->src)->bytes_in_buffer;
  state.cur = entropy->saved;
  state.cinfo = cinfo;
  for(blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++)
  {
    block = MCU_data[blkn];
    ci = (cinfo->MCU_membership)[blkn];
    compptr = (cinfo->cur_comp_info)[ci];
    dctbl = (entropy->dc_derived_tbls)[compptr->dc_tbl_no];
    actbl = (entropy->ac_derived_tbls)[compptr->ac_tbl_no];
    {
      if((state.cur).bits_left < 8)
      {
	if(! fill_bit_buffer(& state, 0))
	  return 0;
	if((state.cur).bits_left < 8)
	{
	  if((s = slow_DECODE(& state, dctbl, 1)) < 0)
	    return 0;
	  goto label1;
	}
      }
      {
	register int nb , look ; /*decdef*/
	look = (int )((state.cur).get_buffer >> (state.cur).bits_left - 8) & (1
	  << 8) - 1;
	if((nb = (dctbl->look_nbits)[look]) != 0)
	{
	  (state.cur).bits_left -= nb;
	  s = (dctbl->look_sym)[look];
	}
	else
	{
	  if((s = slow_DECODE(& state, dctbl, 8 + 1)) < 0)
	    return 0;
	}
      }
      label1:
	;
    }
    ;
    if(s)
    {
      {
	if((state.cur).bits_left < s)
	{
	  if(! fill_bit_buffer(& state, s))
	  {
	    return 0;
	  }
	}
      }
      ;
      r = (int )((state.cur).get_buffer >> ((state.cur).bits_left -= s)) & (1 <<
	s) - 1;
      s = r < extend_test[s] ? r + extend_offset[s] : r;
    }
    if(! compptr->component_needed)
      goto skip_ACs;
    s += ((state.cur).last_dc_val)[ci];
    ((state.cur).last_dc_val)[ci] = s;
    (* block)[0] = (JCOEF )s;
    if(compptr->DCT_scaled_size > 1)
    {
      for(k = 1; k < 64; k++)
      {
	{
	  if((state.cur).bits_left < 8)
	  {
	    if(! fill_bit_buffer(& state, 0))
	      return 0;
	    if((state.cur).bits_left < 8)
	    {
	      if((s = slow_DECODE(& state, actbl, 1)) < 0)
		return 0;
	      goto label2;
	    }
	  }
	  {
	    register int nb , look ; /*decdef*/
	    look = (int )((state.cur).get_buffer >> (state.cur).bits_left - 8) &
	      (1 << 8) - 1;
	    if((nb = (actbl->look_nbits)[look]) != 0)
	    {
	      (state.cur).bits_left -= nb;
	      s = (actbl->look_sym)[look];
	    }
	    else
	    {
	      if((s = slow_DECODE(& state, actbl, 8 + 1)) < 0)
		return 0;
	    }
	  }
	  label2:
	    ;
	}
	;
	r = s >> 4;
	s &= 15;
	if(s)
	{
	  k += r;
	  {
	    if((state.cur).bits_left < s)
	    {
	      if(! fill_bit_buffer(& state, s))
	      {
		return 0;
	      }
	    }
	  }
	  ;
	  r = (int )((state.cur).get_buffer >> ((state.cur).bits_left -= s)) &
	    (1 << s) - 1;
	  s = r < extend_test[s] ? r + extend_offset[s] : r;
	  (* block)[ZAG__0[k]] = (JCOEF )s;
	}
	else
	{
	  if(r != 15)
	    break;
	  k += 15;
	}
      }
    }
    else
    {
      skip_ACs:
	for(k = 1; k < 64; k++)
	{
	  {
	    if((state.cur).bits_left < 8)
	    {
	      if(! fill_bit_buffer(& state, 0))
		return 0;
	      if((state.cur).bits_left < 8)
	      {
		if((s = slow_DECODE(& state, actbl, 1)) < 0)
		  return 0;
		goto label3;
	      }
	    }
	    {
	      register int nb , look ; /*decdef*/
	      look = (int )((state.cur).get_buffer >> (state.cur).bits_left - 8)
		& (1 << 8) - 1;
	      if((nb = (actbl->look_nbits)[look]) != 0)
	      {
		(state.cur).bits_left -= nb;
		s = (actbl->look_sym)[look];
	      }
	      else
	      {
		if((s = slow_DECODE(& state, actbl, 8 + 1)) < 0)
		  return 0;
	      }
	    }
	    label3:
	      ;
	  }
	  ;
	  r = s >> 4;
	  s &= 15;
	  if(s)
	  {
	    k += r;
	    {
	      if((state.cur).bits_left < s)
	      {
		if(! fill_bit_buffer(& state, s))
		{
		  return 0;
		}
	      }
	    }
	    ;
	    (state.cur).bits_left -= s;
	  }
	  else
	  {
	    if(r != 15)
	      break;
	    k += 15;
	  }
	}
    }
  }
  cinfo->unread_marker = state.unread_marker;
  (cinfo->src)->next_input_byte = state.next_input_byte;
  (cinfo->src)->bytes_in_buffer = state.bytes_in_buffer;
  entropy->saved = state.cur;
  entropy->restarts_to_go--;
  return 1;
}

void jinit_huff_decoder(j_decompress_ptr cinfo )
{
  huff_entropy_ptr__0 entropy ; /*decdef*/
  int i ; /*decdef*/
  entropy = (huff_entropy_ptr__0 )(* (cinfo->mem)->alloc_small)((j_common_ptr
    )cinfo, 1, (size_t )sizeof(huff_entropy_decoder ));
  cinfo->entropy = (struct jpeg_entropy_decoder *  )entropy;
  (entropy->pub).start_pass = start_pass_huff_decoder;
  (entropy->pub).decode_mcu = decode_mcu;
  for(i = 0; i < 4; i++)
  {
    (entropy->dc_derived_tbls)[i] = ((entropy->ac_derived_tbls)[i] = (void * 
      )0);
  }
}


#pragma combiner("./jdsample.i", "-g -O -I/home/scott/wrk/safec/cil/lib ")

#pragma boxalloc("malloc", nozero, sizein(0))

#pragma boxalloc("alloca", nozero, sizein(0))

#pragma boxalloc("calloc", zero, sizemul(0, 1))

#pragma boxprintf("printf", 0)

#pragma boxprintf("fprintf", 1)

#pragma boxprintf("sprintf", 1)

#pragma boxprintf("snprintf", 2)

#pragma boxpoly("memcpy")

#pragma boxexported("main")
typedef void ( *  upsample1_ptr )(j_decompress_ptr cinfo , jpeg_component_info
  *  compptr , JSAMPARRAY input_data , JSAMPARRAY *  output_data_ptr )
  ; /*typedef*/

typedef struct  {
  struct jpeg_upsampler pub ;
  JSAMPARRAY color_buf[10] ;
  upsample1_ptr methods[10] ;
  int next_row_out ;
  JDIMENSION rows_to_go ;
  int rowgroup_height[10] ;
  UINT8 h_expand[10] ;
  UINT8 v_expand[10] ;
} my_upsampler ; /*typedef*/

typedef my_upsampler *  my_upsample_ptr ; /*typedef*/

static void start_pass_upsample(j_decompress_ptr cinfo )
{
  my_upsample_ptr upsample = (my_upsample_ptr )cinfo->upsample; /*decdef*/
  upsample->next_row_out = cinfo->max_v_samp_factor;
  upsample->rows_to_go = cinfo->output_height;
}

static void sep_upsample(j_decompress_ptr cinfo , JSAMPIMAGE input_buf ,
  JDIMENSION *  in_row_group_ctr , JDIMENSION in_row_groups_avail , JSAMPARRAY
  output_buf , JDIMENSION *  out_row_ctr , JDIMENSION out_rows_avail )
{
  my_upsample_ptr upsample = (my_upsample_ptr )cinfo->upsample; /*decdef*/
  int ci ; /*decdef*/
  jpeg_component_info *  compptr ; /*decdef*/
  JDIMENSION num_rows ; /*decdef*/
  if(upsample->next_row_out >= cinfo->max_v_samp_factor)
  {
    for(ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components; ci++,
      compptr++)
    {
      (* (upsample->methods)[ci])(cinfo, compptr, input_buf[ci] + *
	in_row_group_ctr * (upsample->rowgroup_height)[ci], upsample->color_buf
	+ ci);
    }
    upsample->next_row_out = 0;
  }
  num_rows = (JDIMENSION )(cinfo->max_v_samp_factor - upsample->next_row_out);
  if(num_rows > upsample->rows_to_go)
    num_rows = upsample->rows_to_go;
  out_rows_avail -= * out_row_ctr;
  if(num_rows > out_rows_avail)
    num_rows = out_rows_avail;
  (* (cinfo->cconvert)->color_convert)(cinfo, upsample->color_buf, (JDIMENSION
    )upsample->next_row_out, output_buf + * out_row_ctr, (int )num_rows);
  * out_row_ctr += num_rows;
  upsample->rows_to_go -= num_rows;
  upsample->next_row_out += num_rows;
  if(upsample->next_row_out >= cinfo->max_v_samp_factor)
    (* in_row_group_ctr)++;
}

static void fullsize_upsample(j_decompress_ptr cinfo , jpeg_component_info * 
  compptr , JSAMPARRAY input_data , JSAMPARRAY *  output_data_ptr )
{
  * output_data_ptr = input_data;
}

static void noop_upsample(j_decompress_ptr cinfo , jpeg_component_info * 
  compptr , JSAMPARRAY input_data , JSAMPARRAY *  output_data_ptr )
{
  * output_data_ptr = (void *  )0;
}

static void int_upsample(j_decompress_ptr cinfo , jpeg_component_info *  compptr
  , JSAMPARRAY input_data , JSAMPARRAY *  output_data_ptr )
{
  my_upsample_ptr upsample = (my_upsample_ptr )cinfo->upsample; /*decdef*/
  JSAMPARRAY output_data = * output_data_ptr; /*decdef*/
  register JSAMPROW inptr , outptr ; /*decdef*/
  register JSAMPLE invalue ; /*decdef*/
  register int h ; /*decdef*/
  JSAMPROW outend ; /*decdef*/
  int h_expand , v_expand ; /*decdef*/
  int inrow , outrow ; /*decdef*/
  h_expand = (upsample->h_expand)[compptr->component_index];
  v_expand = (upsample->v_expand)[compptr->component_index];
  inrow = (outrow = 0);
  while(outrow < cinfo->max_v_samp_factor)
  {
    inptr = input_data[inrow];
    outptr = output_data[outrow];
    outend = outptr + cinfo->output_width;
    while(outptr < outend)
    {
      invalue = * inptr++;
      for(h = h_expand; h > 0; h--)
      {
	* outptr++ = invalue;
      }
    }
    if(v_expand > 1)
    {
      jcopy_sample_rows(output_data, outrow, output_data, outrow + 1, v_expand -
	1, cinfo->output_width);
    }
    inrow++;
    outrow += v_expand;
  }
}

static void h2v1_upsample(j_decompress_ptr cinfo , jpeg_component_info * 
  compptr , JSAMPARRAY input_data , JSAMPARRAY *  output_data_ptr )
{
  JSAMPARRAY output_data = * output_data_ptr; /*decdef*/
  register JSAMPROW inptr , outptr ; /*decdef*/
  register JSAMPLE invalue ; /*decdef*/
  JSAMPROW outend ; /*decdef*/
  int inrow ; /*decdef*/
  for(inrow = 0; inrow < cinfo->max_v_samp_factor; inrow++)
  {
    inptr = input_data[inrow];
    outptr = output_data[inrow];
    outend = outptr + cinfo->output_width;
    while(outptr < outend)
    {
      invalue = * inptr++;
      * outptr++ = invalue;
      * outptr++ = invalue;
    }
  }
}

static void h2v2_upsample(j_decompress_ptr cinfo , jpeg_component_info * 
  compptr , JSAMPARRAY input_data , JSAMPARRAY *  output_data_ptr )
{
  JSAMPARRAY output_data = * output_data_ptr; /*decdef*/
  register JSAMPROW inptr , outptr ; /*decdef*/
  register JSAMPLE invalue ; /*decdef*/
  JSAMPROW outend ; /*decdef*/
  int inrow , outrow ; /*decdef*/
  inrow = (outrow = 0);
  while(outrow < cinfo->max_v_samp_factor)
  {
    inptr = input_data[inrow];
    outptr = output_data[outrow];
    outend = outptr + cinfo->output_width;
    while(outptr < outend)
    {
      invalue = * inptr++;
      * outptr++ = invalue;
      * outptr++ = invalue;
    }
    jcopy_sample_rows(output_data, outrow, output_data, outrow + 1, 1,
      cinfo->output_width);
    inrow++;
    outrow += 2;
  }
}

static void h2v1_fancy_upsample(j_decompress_ptr cinfo , jpeg_component_info * 
  compptr , JSAMPARRAY input_data , JSAMPARRAY *  output_data_ptr )
{
  JSAMPARRAY output_data = * output_data_ptr; /*decdef*/
  register JSAMPROW inptr , outptr ; /*decdef*/
  register int invalue ; /*decdef*/
  register JDIMENSION colctr ; /*decdef*/
  int inrow ; /*decdef*/
  for(inrow = 0; inrow < cinfo->max_v_samp_factor; inrow++)
  {
    inptr = input_data[inrow];
    outptr = output_data[inrow];
    invalue = (int )(* inptr++);
    * outptr++ = (JSAMPLE )invalue;
    * outptr++ = (JSAMPLE )(invalue * 3 + (int )(* inptr) + 2 >> 2);
    for(colctr = compptr->downsampled_width - 2; colctr > 0; colctr--)
    {
      invalue = (int )(* inptr++) * 3;
      * outptr++ = (JSAMPLE )(invalue + (int )inptr[- 2] + 1 >> 2);
      * outptr++ = (JSAMPLE )(invalue + (int )(* inptr) + 2 >> 2);
    }
    invalue = (int )(* inptr);
    * outptr++ = (JSAMPLE )(invalue * 3 + (int )inptr[- 1] + 1 >> 2);
    * outptr++ = (JSAMPLE )invalue;
  }
}

static void h2v2_fancy_upsample(j_decompress_ptr cinfo , jpeg_component_info * 
  compptr , JSAMPARRAY input_data , JSAMPARRAY *  output_data_ptr )
{
  JSAMPARRAY output_data = * output_data_ptr; /*decdef*/
  register JSAMPROW inptr0 , inptr1 , outptr ; /*decdef*/
  register int thiscolsum , lastcolsum , nextcolsum ; /*decdef*/
  register JDIMENSION colctr ; /*decdef*/
  int inrow , outrow , v ; /*decdef*/
  inrow = (outrow = 0);
  while(outrow < cinfo->max_v_samp_factor)
  {
    for(v = 0; v < 2; v++)
    {
      inptr0 = input_data[inrow];
      if(v == 0)
	inptr1 = input_data[inrow - 1];
      else
	inptr1 = input_data[inrow + 1];
      outptr = output_data[outrow++];
      thiscolsum = (int )(* inptr0++) * 3 + (int )(* inptr1++);
      nextcolsum = (int )(* inptr0++) * 3 + (int )(* inptr1++);
      * outptr++ = (JSAMPLE )(thiscolsum * 4 + 8 >> 4);
      * outptr++ = (JSAMPLE )(thiscolsum * 3 + nextcolsum + 7 >> 4);
      lastcolsum = thiscolsum;
      thiscolsum = nextcolsum;
      for(colctr = compptr->downsampled_width - 2; colctr > 0; colctr--)
      {
	nextcolsum = (int )(* inptr0++) * 3 + (int )(* inptr1++);
	* outptr++ = (JSAMPLE )(thiscolsum * 3 + lastcolsum + 8 >> 4);
	* outptr++ = (JSAMPLE )(thiscolsum * 3 + nextcolsum + 7 >> 4);
	lastcolsum = thiscolsum;
	thiscolsum = nextcolsum;
      }
      * outptr++ = (JSAMPLE )(thiscolsum * 3 + lastcolsum + 8 >> 4);
      * outptr++ = (JSAMPLE )(thiscolsum * 4 + 7 >> 4);
    }
    inrow++;
  }
}

void jinit_upsampler(j_decompress_ptr cinfo )
{
  my_upsample_ptr upsample ; /*decdef*/
  int ci ; /*decdef*/
  jpeg_component_info *  compptr ; /*decdef*/
  boolean need_buffer , do_fancy ; /*decdef*/
  int h_in_group , v_in_group , h_out_group , v_out_group ; /*decdef*/
  upsample = (my_upsample_ptr )(* (cinfo->mem)->alloc_small)((j_common_ptr
    )cinfo, 1, (size_t )sizeof(my_upsampler ));
  cinfo->upsample = (struct jpeg_upsampler *  )upsample;
  (upsample->pub).start_pass = start_pass_upsample;
  (upsample->pub).upsample = sep_upsample;
  (upsample->pub).need_context_rows = 0;
  if(cinfo->CCIR601_sampling)
    (cinfo->err)->msg_code = JERR_CCIR601_NOTIMPL, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  do_fancy = cinfo->do_fancy_upsampling && cinfo->min_DCT_scaled_size > 1;
  for(ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components; ci++,
    compptr++)
  {
    h_in_group = compptr->h_samp_factor * compptr->DCT_scaled_size /
      cinfo->min_DCT_scaled_size;
    v_in_group = compptr->v_samp_factor * compptr->DCT_scaled_size /
      cinfo->min_DCT_scaled_size;
    h_out_group = cinfo->max_h_samp_factor;
    v_out_group = cinfo->max_v_samp_factor;
    (upsample->rowgroup_height)[ci] = v_in_group;
    need_buffer = 1;
    if(! compptr->component_needed)
    {
      (upsample->methods)[ci] = noop_upsample;
      need_buffer = 0;
    }
    else
    {
      if(h_in_group == h_out_group && v_in_group == v_out_group)
      {
	(upsample->methods)[ci] = fullsize_upsample;
	need_buffer = 0;
      }
      else
      {
	if(h_in_group * 2 == h_out_group && v_in_group == v_out_group)
	{
	  if(do_fancy && compptr->downsampled_width > 2)
	    (upsample->methods)[ci] = h2v1_fancy_upsample;
	  else
	    (upsample->methods)[ci] = h2v1_upsample;
	}
	else
	{
	  if(h_in_group * 2 == h_out_group && v_in_group * 2 == v_out_group)
	  {
	    if(do_fancy && compptr->downsampled_width > 2)
	    {
	      (upsample->methods)[ci] = h2v2_fancy_upsample;
	      (upsample->pub).need_context_rows = 1;
	    }
	    else
	      (upsample->methods)[ci] = h2v2_upsample;
	  }
	  else
	  {
	    if(h_out_group % h_in_group == 0 && v_out_group % v_in_group == 0)
	    {
	      (upsample->methods)[ci] = int_upsample;
	      (upsample->h_expand)[ci] = (UINT8 )(h_out_group / h_in_group);
	      (upsample->v_expand)[ci] = (UINT8 )(v_out_group / v_in_group);
	    }
	    else
	      (cinfo->err)->msg_code = JERR_FRACT_SAMPLE_NOTIMPL, (*
		(cinfo->err)->error_exit)((j_common_ptr )cinfo);
	  }
	}
      }
    }
    if(need_buffer)
    {
      (upsample->color_buf)[ci] = (* (cinfo->mem)->alloc_sarray)((j_common_ptr
	)cinfo, 1, (JDIMENSION )jround_up((long )cinfo->output_width,
	(long )cinfo->max_h_samp_factor), (JDIMENSION
	)cinfo->max_v_samp_factor);
    }
  }
}


#pragma combiner("./jdcolor.i", "-g -O -I/home/scott/wrk/safec/cil/lib ")

#pragma boxalloc("malloc", nozero, sizein(0))

#pragma boxalloc("alloca", nozero, sizein(0))

#pragma boxalloc("calloc", zero, sizemul(0, 1))

#pragma boxprintf("printf", 0)

#pragma boxprintf("fprintf", 1)

#pragma boxprintf("sprintf", 1)

#pragma boxprintf("snprintf", 2)

#pragma boxpoly("memcpy")

#pragma boxexported("main")
typedef struct  {
  struct jpeg_color_deconverter pub ;
  int *  Cr_r_tab ;
  int *  Cb_b_tab ;
  INT32 *  Cr_g_tab ;
  INT32 *  Cb_g_tab ;
} my_color_deconverter ; /*typedef*/

typedef my_color_deconverter *  my_cconvert_ptr__0 ; /*typedef*/

static void ycc_rgb_start(j_decompress_ptr cinfo )
{
  my_cconvert_ptr__0 cconvert = (my_cconvert_ptr__0 )cinfo->cconvert; /*decdef*/
  INT32 i , x2 ; /*decdef*/
  cconvert->Cr_r_tab = (int *  )(* (cinfo->mem)->alloc_small)((j_common_ptr
    )cinfo, 1, (255 + 1) * (size_t )sizeof(int ));
  cconvert->Cb_b_tab = (int *  )(* (cinfo->mem)->alloc_small)((j_common_ptr
    )cinfo, 1, (255 + 1) * (size_t )sizeof(int ));
  cconvert->Cr_g_tab = (INT32 *  )(* (cinfo->mem)->alloc_small)((j_common_ptr
    )cinfo, 1, (255 + 1) * (size_t )sizeof(INT32 ));
  cconvert->Cb_g_tab = (INT32 *  )(* (cinfo->mem)->alloc_small)((j_common_ptr
    )cinfo, 1, (255 + 1) * (size_t )sizeof(INT32 ));
  for(i = 0; i <= 255; i++)
  {
    x2 = 2 * i - 255;
    (cconvert->Cr_r_tab)[i] = (int )((INT32 )(1.40200 / 2 * (1L << 16) + 0.5) *
      x2 + ((INT32 )1 << 16 - 1) >> 16);
    (cconvert->Cb_b_tab)[i] = (int )((INT32 )(1.77200 / 2 * (1L << 16) + 0.5) *
      x2 + ((INT32 )1 << 16 - 1) >> 16);
    (cconvert->Cr_g_tab)[i] = - (INT32 )(0.71414 / 2 * (1L << 16) + 0.5) * x2;
    (cconvert->Cb_g_tab)[i] = - (INT32 )(0.34414 / 2 * (1L << 16) + 0.5) * x2 +
      ((INT32 )1 << 16 - 1);
  }
}

static void ycc_rgb_convert(j_decompress_ptr cinfo , JSAMPIMAGE input_buf ,
  JDIMENSION input_row , JSAMPARRAY output_buf , int num_rows )
{
  my_cconvert_ptr__0 cconvert = (my_cconvert_ptr__0 )cinfo->cconvert; /*decdef*/
  register int y , cb , cr ; /*decdef*/
  register JSAMPROW outptr ; /*decdef*/
  register JSAMPROW inptr0 , inptr1 , inptr2 ; /*decdef*/
  register JDIMENSION col ; /*decdef*/
  JDIMENSION num_cols = cinfo->output_width; /*decdef*/
  register JSAMPLE *  range_limit = cinfo->sample_range_limit; /*decdef*/
  register int *  Crrtab = cconvert->Cr_r_tab; /*decdef*/
  register int *  Cbbtab = cconvert->Cb_b_tab; /*decdef*/
  register INT32 *  Crgtab = cconvert->Cr_g_tab; /*decdef*/
  register INT32 *  Cbgtab = cconvert->Cb_g_tab; /*decdef*/
  while(-- num_rows >= 0)
  {
    inptr0 = (input_buf[0])[input_row];
    inptr1 = (input_buf[1])[input_row];
    inptr2 = (input_buf[2])[input_row];
    input_row++;
    outptr = * output_buf++;
    for(col = 0; col < num_cols; col++)
    {
      y = (int )inptr0[col];
      cb = (int )inptr1[col];
      cr = (int )inptr2[col];
      outptr[0] = range_limit[y + Crrtab[cr]];
      outptr[1] = range_limit[y + (int )(Cbgtab[cb] + Crgtab[cr] >> 16)];
      outptr[2] = range_limit[y + Cbbtab[cb]];
      outptr += 3;
    }
  }
}

static void null_convert__0(j_decompress_ptr cinfo , JSAMPIMAGE input_buf ,
  JDIMENSION input_row , JSAMPARRAY output_buf , int num_rows )
{
  register JSAMPROW inptr , outptr ; /*decdef*/
  register JDIMENSION count ; /*decdef*/
  register int num_components = cinfo->output_components; /*decdef*/
  JDIMENSION num_cols = cinfo->output_width; /*decdef*/
  int ci ; /*decdef*/
  while(-- num_rows >= 0)
  {
    for(ci = 0; ci < num_components; ci++)
    {
      inptr = (input_buf[ci])[input_row];
      outptr = output_buf[0] + ci;
      for(count = num_cols; count > 0; count--)
      {
	* outptr = * inptr++;
	outptr += num_components;
      }
    }
    input_row++;
    output_buf++;
  }
}

static void grayscale_convert__0(j_decompress_ptr cinfo , JSAMPIMAGE input_buf ,
  JDIMENSION input_row , JSAMPARRAY output_buf , int num_rows )
{
  jcopy_sample_rows(input_buf[0], (int )input_row, output_buf, 0, num_rows,
    cinfo->output_width);
}

static void ycck_cmyk_convert(j_decompress_ptr cinfo , JSAMPIMAGE input_buf ,
  JDIMENSION input_row , JSAMPARRAY output_buf , int num_rows )
{
  my_cconvert_ptr__0 cconvert = (my_cconvert_ptr__0 )cinfo->cconvert; /*decdef*/
  register int y , cb , cr ; /*decdef*/
  register JSAMPROW outptr ; /*decdef*/
  register JSAMPROW inptr0 , inptr1 , inptr2 , inptr3 ; /*decdef*/
  register JDIMENSION col ; /*decdef*/
  JDIMENSION num_cols = cinfo->output_width; /*decdef*/
  register JSAMPLE *  range_limit = cinfo->sample_range_limit; /*decdef*/
  register int *  Crrtab = cconvert->Cr_r_tab; /*decdef*/
  register int *  Cbbtab = cconvert->Cb_b_tab; /*decdef*/
  register INT32 *  Crgtab = cconvert->Cr_g_tab; /*decdef*/
  register INT32 *  Cbgtab = cconvert->Cb_g_tab; /*decdef*/
  while(-- num_rows >= 0)
  {
    inptr0 = (input_buf[0])[input_row];
    inptr1 = (input_buf[1])[input_row];
    inptr2 = (input_buf[2])[input_row];
    inptr3 = (input_buf[3])[input_row];
    input_row++;
    outptr = * output_buf++;
    for(col = 0; col < num_cols; col++)
    {
      y = (int )inptr0[col];
      cb = (int )inptr1[col];
      cr = (int )inptr2[col];
      outptr[0] = range_limit[255 - (y + Crrtab[cr])];
      outptr[1] = range_limit[255 - (y + (int )(Cbgtab[cb] + Crgtab[cr] >>
	16))];
      outptr[2] = range_limit[255 - (y + Cbbtab[cb])];
      outptr[3] = inptr3[col];
      outptr += 4;
    }
  }
}

static void null_method__0(j_decompress_ptr cinfo )
{
}

void jinit_color_deconverter(j_decompress_ptr cinfo )
{
  my_cconvert_ptr__0 cconvert ; /*decdef*/
  int ci ; /*decdef*/
  cconvert = (my_cconvert_ptr__0 )(* (cinfo->mem)->alloc_small)((j_common_ptr
    )cinfo, 1, (size_t )sizeof(my_color_deconverter ));
  cinfo->cconvert = (struct jpeg_color_deconverter *  )cconvert;
  (cconvert->pub).start_pass = null_method__0;
  switch(cinfo->jpeg_color_space)
  {
  case JCS_GRAYSCALE:
      ;
    if(cinfo->num_components != 1)
      (cinfo->err)->msg_code = JERR_BAD_J_COLORSPACE, (*
	(cinfo->err)->error_exit)((j_common_ptr )cinfo);
    break;
  case JCS_RGB:
      ;
  case JCS_YCbCr:
      ;
    if(cinfo->num_components != 3)
      (cinfo->err)->msg_code = JERR_BAD_J_COLORSPACE, (*
	(cinfo->err)->error_exit)((j_common_ptr )cinfo);
    break;
  case JCS_CMYK:
      ;
  case JCS_YCCK:
      ;
    if(cinfo->num_components != 4)
      (cinfo->err)->msg_code = JERR_BAD_J_COLORSPACE, (*
	(cinfo->err)->error_exit)((j_common_ptr )cinfo);
    break;
  default :
      ;
    if(cinfo->num_components < 1)
      (cinfo->err)->msg_code = JERR_BAD_J_COLORSPACE, (*
	(cinfo->err)->error_exit)((j_common_ptr )cinfo);
    break;
  }
  switch(cinfo->out_color_space)
  {
  case JCS_GRAYSCALE:
      ;
    cinfo->out_color_components = 1;
    if(cinfo->jpeg_color_space == JCS_GRAYSCALE || cinfo->jpeg_color_space ==
      JCS_YCbCr)
    {
      (cconvert->pub).color_convert = grayscale_convert__0;
      for(ci = 1; ci < cinfo->num_components; ci++)
	((cinfo->comp_info)[ci]).component_needed = 0;
    }
    else
      (cinfo->err)->msg_code = JERR_CONVERSION_NOTIMPL, (*
	(cinfo->err)->error_exit)((j_common_ptr )cinfo);
    break;
  case JCS_RGB:
      ;
    cinfo->out_color_components = 3;
    if(cinfo->jpeg_color_space == JCS_YCbCr)
    {
      (cconvert->pub).start_pass = ycc_rgb_start;
      (cconvert->pub).color_convert = ycc_rgb_convert;
    }
    else
    {
      if(cinfo->jpeg_color_space == JCS_RGB && 3 == 3)
      {
	(cconvert->pub).color_convert = null_convert__0;
      }
      else
	(cinfo->err)->msg_code = JERR_CONVERSION_NOTIMPL, (*
	  (cinfo->err)->error_exit)((j_common_ptr )cinfo);
    }
    break;
  case JCS_CMYK:
      ;
    cinfo->out_color_components = 4;
    if(cinfo->jpeg_color_space == JCS_YCCK)
    {
      (cconvert->pub).start_pass = ycc_rgb_start;
      (cconvert->pub).color_convert = ycck_cmyk_convert;
    }
    else
    {
      if(cinfo->jpeg_color_space == JCS_CMYK)
      {
	(cconvert->pub).color_convert = null_convert__0;
      }
      else
	(cinfo->err)->msg_code = JERR_CONVERSION_NOTIMPL, (*
	  (cinfo->err)->error_exit)((j_common_ptr )cinfo);
    }
    break;
  default :
      ;
    if(cinfo->out_color_space == cinfo->jpeg_color_space)
    {
      cinfo->out_color_components = cinfo->num_components;
      (cconvert->pub).color_convert = null_convert__0;
    }
    else
      (cinfo->err)->msg_code = JERR_CONVERSION_NOTIMPL, (*
	(cinfo->err)->error_exit)((j_common_ptr )cinfo);
    break;
  }
  if(cinfo->quantize_colors)
    cinfo->output_components = 1;
  else
    cinfo->output_components = cinfo->out_color_components;
}


#pragma combiner("./jquant1.i", "-g -O -I/home/scott/wrk/safec/cil/lib ")

#pragma boxalloc("malloc", nozero, sizein(0))

#pragma boxalloc("alloca", nozero, sizein(0))

#pragma boxalloc("calloc", zero, sizemul(0, 1))

#pragma boxprintf("printf", 0)

#pragma boxprintf("fprintf", 1)

#pragma boxprintf("sprintf", 1)

#pragma boxprintf("snprintf", 2)

#pragma boxpoly("memcpy")

#pragma boxexported("main")
typedef int ODITHER_MATRIX[4][4] ; /*typedef*/

typedef INT16 FSERROR ; /*typedef*/

typedef int LOCFSERROR ; /*typedef*/

typedef FSERROR *  FSERRPTR ; /*typedef*/

typedef struct  {
  struct jpeg_color_quantizer pub ;
  JSAMPARRAY colorindex ;
  int row_index ;
  ODITHER_MATRIX *  odither ;
  FSERRPTR fserrors[4] ;
  boolean on_odd_row ;
} my_cquantizer ; /*typedef*/

typedef my_cquantizer *  my_cquantize_ptr ; /*typedef*/

static int select_ncolors(j_decompress_ptr cinfo , int Ncolors[] )
{
  int nc = cinfo->out_color_components; /*decdef*/
  int max_colors = cinfo->desired_number_of_colors; /*decdef*/
  int total_colors , iroot , i , j ; /*decdef*/
  long temp ; /*decdef*/
  static const int RGB_order[3] = {1, 0, 2}; /*decdef*/
  iroot = 1;
  do
  {
    iroot++;
    temp = iroot;
    for(i = 1; i < nc; i++)
      temp *= iroot;
  }
  while(temp <= (long )max_colors);
  iroot--;
  if(iroot < 2)
    (cinfo->err)->msg_code = JERR_QUANT_FEW_COLORS,
      (((cinfo->err)->msg_parm).i)[0] = (int )temp, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  total_colors = 1;
  for(i = 0; i < nc; i++)
  {
    Ncolors[i] = iroot;
    total_colors *= iroot;
  }
  for(i = 0; i < nc; i++)
  {
    j = cinfo->out_color_space == JCS_RGB ? RGB_order[i] : i;
    temp = total_colors / Ncolors[j];
    temp *= Ncolors[j] + 1;
    if(temp > (long )max_colors)
      break;
    Ncolors[j]++;
    total_colors = (int )temp;
  }
  return total_colors;
}

static int output_value(j_decompress_ptr cinfo , int ci , int j , int maxj )
{
  return (int )(((INT32 )j * 255 + maxj / 2) / maxj);
}

static int largest_input_value(j_decompress_ptr cinfo , int ci , int j ,
  int maxj )
{
  return (int )(((INT32 )(2 * j + 1) * 255 + maxj) / (2 * maxj));
}

static void create_colormap(j_decompress_ptr cinfo )
{
  my_cquantize_ptr cquantize = (my_cquantize_ptr )cinfo->cquantize; /*decdef*/
  JSAMPARRAY colormap ; /*decdef*/
  JSAMPROW indexptr ; /*decdef*/
  int total_colors ; /*decdef*/
  int Ncolors[4] ; /*decdef*/
  ODITHER_MATRIX *  odither ; /*decdef*/
  int i , j , k , nci , blksize , blkdist , ptr , val , pad ; /*decdef*/
  total_colors = select_ncolors(cinfo, Ncolors);
  if(cinfo->out_color_components == 3)
  {
    do
    {
      int *  _mp = ((cinfo->err)->msg_parm).i; /*decdef*/
      _mp[0] = total_colors;
      _mp[1] = Ncolors[0];
      _mp[2] = Ncolors[1];
      _mp[3] = Ncolors[2];
      (cinfo->err)->msg_code = JTRC_QUANT_3_NCOLORS;
      (* (cinfo->err)->emit_message)((j_common_ptr )cinfo, 1);
    }
    while(0);
  }
  else
    (cinfo->err)->msg_code = JTRC_QUANT_NCOLORS, (((cinfo->err)->msg_parm).i)[0]
      = total_colors, (* (cinfo->err)->emit_message)((j_common_ptr )cinfo, 1);
  pad = cinfo->dither_mode == JDITHER_ORDERED ? 255 * 2 : 0;
  colormap = (* (cinfo->mem)->alloc_sarray)((j_common_ptr )cinfo, 1, (JDIMENSION
    )total_colors, (JDIMENSION )cinfo->out_color_components);
  cquantize->colorindex = (* (cinfo->mem)->alloc_sarray)((j_common_ptr )cinfo,
    1, (JDIMENSION )(255 + 1 + pad), (JDIMENSION )cinfo->out_color_components);
  blkdist = total_colors;
  for(i = 0; i < cinfo->out_color_components; i++)
  {
    nci = Ncolors[i];
    blksize = blkdist / nci;
    for(j = 0; j < nci; j++)
    {
      val = output_value(cinfo, i, j, nci - 1);
      for(ptr = j * blksize; ptr < total_colors; ptr += blkdist)
      {
	for(k = 0; k < blksize; k++)
	  (colormap[i])[ptr + k] = (JSAMPLE )val;
      }
    }
    blkdist = blksize;
    if(pad)
      (cquantize->colorindex)[i] += 255;
    indexptr = (cquantize->colorindex)[i];
    val = 0;
    k = largest_input_value(cinfo, i, 0, nci - 1);
    for(j = 0; j <= 255; j++)
    {
      while(j > k)
	k = largest_input_value(cinfo, i, ++ val, nci - 1);
      indexptr[j] = (JSAMPLE )(val * blksize);
    }
    if(pad)
      for(j = 1; j <= 255; j++)
      {
	indexptr[- j] = indexptr[0];
	indexptr[255 + j] = indexptr[255];
      }
  }
  cinfo->colormap = colormap;
  cinfo->actual_number_of_colors = total_colors;
  if(cinfo->dither_mode == JDITHER_ORDERED)
  {
    odither = (ODITHER_MATRIX *  )(* (cinfo->mem)->alloc_small)((j_common_ptr
      )cinfo, 1, cinfo->out_color_components * (size_t )sizeof(ODITHER_MATRIX
      ));
    cquantize->odither = odither;
    for(i = 0; i < cinfo->out_color_components; i++)
    {
      nci = Ncolors[i];
      val = 2 * (4 * 4 + 1) * (nci - 1);
      ((odither[0])[0])[0] = (4 * 4 + 1 - 2 * 1) * 255 < 0 ? - (- ((4 * 4 + 1 -
	2 * 1) * 255) / val) : (4 * 4 + 1 - 2 * 1) * 255 / val;
      ((odither[0])[0])[1] = (4 * 4 + 1 - 2 * 9) * 255 < 0 ? - (- ((4 * 4 + 1 -
	2 * 9) * 255) / val) : (4 * 4 + 1 - 2 * 9) * 255 / val;
      ((odither[0])[0])[2] = (4 * 4 + 1 - 2 * 3) * 255 < 0 ? - (- ((4 * 4 + 1 -
	2 * 3) * 255) / val) : (4 * 4 + 1 - 2 * 3) * 255 / val;
      ((odither[0])[0])[3] = (4 * 4 + 1 - 2 * 11) * 255 < 0 ? - (- ((4 * 4 + 1 -
	2 * 11) * 255) / val) : (4 * 4 + 1 - 2 * 11) * 255 / val;
      ((odither[0])[1])[0] = (4 * 4 + 1 - 2 * 13) * 255 < 0 ? - (- ((4 * 4 + 1 -
	2 * 13) * 255) / val) : (4 * 4 + 1 - 2 * 13) * 255 / val;
      ((odither[0])[1])[1] = (4 * 4 + 1 - 2 * 5) * 255 < 0 ? - (- ((4 * 4 + 1 -
	2 * 5) * 255) / val) : (4 * 4 + 1 - 2 * 5) * 255 / val;
      ((odither[0])[1])[2] = (4 * 4 + 1 - 2 * 15) * 255 < 0 ? - (- ((4 * 4 + 1 -
	2 * 15) * 255) / val) : (4 * 4 + 1 - 2 * 15) * 255 / val;
      ((odither[0])[1])[3] = (4 * 4 + 1 - 2 * 7) * 255 < 0 ? - (- ((4 * 4 + 1 -
	2 * 7) * 255) / val) : (4 * 4 + 1 - 2 * 7) * 255 / val;
      ((odither[0])[2])[0] = (4 * 4 + 1 - 2 * 4) * 255 < 0 ? - (- ((4 * 4 + 1 -
	2 * 4) * 255) / val) : (4 * 4 + 1 - 2 * 4) * 255 / val;
      ((odither[0])[2])[1] = (4 * 4 + 1 - 2 * 12) * 255 < 0 ? - (- ((4 * 4 + 1 -
	2 * 12) * 255) / val) : (4 * 4 + 1 - 2 * 12) * 255 / val;
      ((odither[0])[2])[2] = (4 * 4 + 1 - 2 * 2) * 255 < 0 ? - (- ((4 * 4 + 1 -
	2 * 2) * 255) / val) : (4 * 4 + 1 - 2 * 2) * 255 / val;
      ((odither[0])[2])[3] = (4 * 4 + 1 - 2 * 10) * 255 < 0 ? - (- ((4 * 4 + 1 -
	2 * 10) * 255) / val) : (4 * 4 + 1 - 2 * 10) * 255 / val;
      ((odither[0])[3])[0] = (4 * 4 + 1 - 2 * 16) * 255 < 0 ? - (- ((4 * 4 + 1 -
	2 * 16) * 255) / val) : (4 * 4 + 1 - 2 * 16) * 255 / val;
      ((odither[0])[3])[1] = (4 * 4 + 1 - 2 * 8) * 255 < 0 ? - (- ((4 * 4 + 1 -
	2 * 8) * 255) / val) : (4 * 4 + 1 - 2 * 8) * 255 / val;
      ((odither[0])[3])[2] = (4 * 4 + 1 - 2 * 14) * 255 < 0 ? - (- ((4 * 4 + 1 -
	2 * 14) * 255) / val) : (4 * 4 + 1 - 2 * 14) * 255 / val;
      ((odither[0])[3])[3] = (4 * 4 + 1 - 2 * 6) * 255 < 0 ? - (- ((4 * 4 + 1 -
	2 * 6) * 255) / val) : (4 * 4 + 1 - 2 * 6) * 255 / val;
      odither++;
    }
  }
}

static void color_quantize(j_decompress_ptr cinfo , JSAMPARRAY input_buf ,
  JSAMPARRAY output_buf , int num_rows )
{
  my_cquantize_ptr cquantize = (my_cquantize_ptr )cinfo->cquantize; /*decdef*/
  JSAMPARRAY colorindex = cquantize->colorindex; /*decdef*/
  register int pixcode , ci ; /*decdef*/
  register JSAMPROW ptrin , ptrout ; /*decdef*/
  int row ; /*decdef*/
  JDIMENSION col ; /*decdef*/
  JDIMENSION width = cinfo->output_width; /*decdef*/
  register int nc = cinfo->out_color_components; /*decdef*/
  for(row = 0; row < num_rows; row++)
  {
    ptrin = input_buf[row];
    ptrout = output_buf[row];
    for(col = width; col > 0; col--)
    {
      pixcode = 0;
      for(ci = 0; ci < nc; ci++)
      {
	pixcode += (int )(colorindex[ci])[(int )(* ptrin++)];
      }
      * ptrout++ = (JSAMPLE )pixcode;
    }
  }
}

static void color_quantize3(j_decompress_ptr cinfo , JSAMPARRAY input_buf ,
  JSAMPARRAY output_buf , int num_rows )
{
  my_cquantize_ptr cquantize = (my_cquantize_ptr )cinfo->cquantize; /*decdef*/
  register int pixcode ; /*decdef*/
  register JSAMPROW ptrin , ptrout ; /*decdef*/
  JSAMPROW colorindex0 = (cquantize->colorindex)[0]; /*decdef*/
  JSAMPROW colorindex1 = (cquantize->colorindex)[1]; /*decdef*/
  JSAMPROW colorindex2 = (cquantize->colorindex)[2]; /*decdef*/
  int row ; /*decdef*/
  JDIMENSION col ; /*decdef*/
  JDIMENSION width = cinfo->output_width; /*decdef*/
  for(row = 0; row < num_rows; row++)
  {
    ptrin = input_buf[row];
    ptrout = output_buf[row];
    for(col = width; col > 0; col--)
    {
      pixcode = (int )colorindex0[(int )(* ptrin++)];
      pixcode += (int )colorindex1[(int )(* ptrin++)];
      pixcode += (int )colorindex2[(int )(* ptrin++)];
      * ptrout++ = (JSAMPLE )pixcode;
    }
  }
}

static void quantize_ord_dither(j_decompress_ptr cinfo , JSAMPARRAY input_buf ,
  JSAMPARRAY output_buf , int num_rows )
{
  my_cquantize_ptr cquantize = (my_cquantize_ptr )cinfo->cquantize; /*decdef*/
  register JSAMPROW input_ptr ; /*decdef*/
  register JSAMPROW output_ptr ; /*decdef*/
  JSAMPROW colorindex_ci ; /*decdef*/
  int *  dither ; /*decdef*/
  int row_index , col_index ; /*decdef*/
  int nc = cinfo->out_color_components; /*decdef*/
  int ci ; /*decdef*/
  int row ; /*decdef*/
  JDIMENSION col ; /*decdef*/
  JDIMENSION width = cinfo->output_width; /*decdef*/
  for(row = 0; row < num_rows; row++)
  {
    jzero_far((void *  )output_buf[row], (size_t )(width * (size_t
      )sizeof(JSAMPLE )));
    row_index = cquantize->row_index;
    for(ci = 0; ci < nc; ci++)
    {
      input_ptr = input_buf[row] + ci;
      output_ptr = output_buf[row];
      colorindex_ci = (cquantize->colorindex)[ci];
      dither = ((cquantize->odither)[ci])[row_index];
      col_index = 0;
      for(col = width; col > 0; col--)
      {
	* output_ptr += colorindex_ci[(int )(* input_ptr) + dither[col_index]];
	input_ptr += nc;
	output_ptr++;
	col_index = col_index + 1 & 3;
      }
    }
    row_index = row_index + 1 & 3;
    cquantize->row_index = row_index;
  }
}

static void quantize3_ord_dither(j_decompress_ptr cinfo , JSAMPARRAY input_buf ,
  JSAMPARRAY output_buf , int num_rows )
{
  my_cquantize_ptr cquantize = (my_cquantize_ptr )cinfo->cquantize; /*decdef*/
  register int pixcode ; /*decdef*/
  register JSAMPROW input_ptr ; /*decdef*/
  register JSAMPROW output_ptr ; /*decdef*/
  JSAMPROW colorindex0 = (cquantize->colorindex)[0]; /*decdef*/
  JSAMPROW colorindex1 = (cquantize->colorindex)[1]; /*decdef*/
  JSAMPROW colorindex2 = (cquantize->colorindex)[2]; /*decdef*/
  int *  dither0 ; /*decdef*/
  int *  dither1 ; /*decdef*/
  int *  dither2 ; /*decdef*/
  int row_index , col_index ; /*decdef*/
  int row ; /*decdef*/
  JDIMENSION col ; /*decdef*/
  JDIMENSION width = cinfo->output_width; /*decdef*/
  for(row = 0; row < num_rows; row++)
  {
    row_index = cquantize->row_index;
    input_ptr = input_buf[row];
    output_ptr = output_buf[row];
    dither0 = ((cquantize->odither)[0])[row_index];
    dither1 = ((cquantize->odither)[1])[row_index];
    dither2 = ((cquantize->odither)[2])[row_index];
    col_index = 0;
    for(col = width; col > 0; col--)
    {
      pixcode = (int )colorindex0[(int )(* input_ptr++) + dither0[col_index]];
      pixcode += (int )colorindex1[(int )(* input_ptr++) + dither1[col_index]];
      pixcode += (int )colorindex2[(int )(* input_ptr++) + dither2[col_index]];
      * output_ptr++ = (JSAMPLE )pixcode;
      col_index = col_index + 1 & 3;
    }
    row_index = row_index + 1 & 3;
    cquantize->row_index = row_index;
  }
}

static void quantize_fs_dither(j_decompress_ptr cinfo , JSAMPARRAY input_buf ,
  JSAMPARRAY output_buf , int num_rows )
{
  my_cquantize_ptr cquantize = (my_cquantize_ptr )cinfo->cquantize; /*decdef*/
  register LOCFSERROR cur ; /*decdef*/
  LOCFSERROR belowerr ; /*decdef*/
  LOCFSERROR bpreverr ; /*decdef*/
  LOCFSERROR bnexterr ; /*decdef*/
  LOCFSERROR delta ; /*decdef*/
  register FSERRPTR errorptr ; /*decdef*/
  register JSAMPROW input_ptr ; /*decdef*/
  register JSAMPROW output_ptr ; /*decdef*/
  JSAMPROW colorindex_ci ; /*decdef*/
  JSAMPROW colormap_ci ; /*decdef*/
  int pixcode ; /*decdef*/
  int nc = cinfo->out_color_components; /*decdef*/
  int dir ; /*decdef*/
  int dirnc ; /*decdef*/
  int ci ; /*decdef*/
  int row ; /*decdef*/
  JDIMENSION col ; /*decdef*/
  JDIMENSION width = cinfo->output_width; /*decdef*/
  JSAMPLE *  range_limit = cinfo->sample_range_limit; /*decdef*/
  for(row = 0; row < num_rows; row++)
  {
    jzero_far((void *  )output_buf[row], (size_t )(width * (size_t
      )sizeof(JSAMPLE )));
    for(ci = 0; ci < nc; ci++)
    {
      input_ptr = input_buf[row] + ci;
      output_ptr = output_buf[row];
      if(cquantize->on_odd_row)
      {
	input_ptr += (width - 1) * nc;
	output_ptr += width - 1;
	dir = - 1;
	dirnc = - nc;
	errorptr = (cquantize->fserrors)[ci] + (width + 1);
      }
      else
      {
	dir = 1;
	dirnc = nc;
	errorptr = (cquantize->fserrors)[ci];
      }
      colorindex_ci = (cquantize->colorindex)[ci];
      colormap_ci = (cinfo->colormap)[ci];
      cur = 0;
      belowerr = (bpreverr = 0);
      for(col = width; col > 0; col--)
      {
	cur = cur + errorptr[dir] + 8 >> 4;
	cur += (int )(* input_ptr);
	cur = (int )range_limit[cur];
	pixcode = (int )colorindex_ci[cur];
	* output_ptr += (JSAMPLE )pixcode;
	cur -= (int )colormap_ci[pixcode];
	bnexterr = cur;
	delta = cur * 2;
	cur += delta;
	errorptr[0] = (FSERROR )(bpreverr + cur);
	cur += delta;
	bpreverr = belowerr + cur;
	belowerr = bnexterr;
	cur += delta;
	input_ptr += dirnc;
	output_ptr += dir;
	errorptr += dir;
      }
      errorptr[0] = (FSERROR )bpreverr;
    }
    cquantize->on_odd_row = cquantize->on_odd_row ? 0 : 1;
  }
}

static void start_pass_1_quant(j_decompress_ptr cinfo , boolean is_pre_scan )
{
}

static void finish_pass_1_quant(j_decompress_ptr cinfo )
{
}

void jinit_1pass_quantizer(j_decompress_ptr cinfo )
{
  my_cquantize_ptr cquantize ; /*decdef*/
  size_t arraysize ; /*decdef*/
  int i ; /*decdef*/
  cquantize = (my_cquantize_ptr )(* (cinfo->mem)->alloc_small)((j_common_ptr
    )cinfo, 1, (size_t )sizeof(my_cquantizer ));
  cinfo->cquantize = (struct jpeg_color_quantizer *  )cquantize;
  (cquantize->pub).start_pass = start_pass_1_quant;
  (cquantize->pub).finish_pass = finish_pass_1_quant;
  if(cinfo->out_color_components > 4)
    (cinfo->err)->msg_code = JERR_QUANT_COMPONENTS,
      (((cinfo->err)->msg_parm).i)[0] = 4, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  if(cinfo->desired_number_of_colors > 255 + 1)
    (cinfo->err)->msg_code = JERR_QUANT_MANY_COLORS,
      (((cinfo->err)->msg_parm).i)[0] = 255 + 1, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  switch(cinfo->dither_mode)
  {
  case JDITHER_NONE:
      ;
    if(cinfo->out_color_components == 3)
      (cquantize->pub).color_quantize = color_quantize3;
    else
      (cquantize->pub).color_quantize = color_quantize;
    break;
  case JDITHER_ORDERED:
      ;
    if(cinfo->out_color_components == 3)
      (cquantize->pub).color_quantize = quantize3_ord_dither;
    else
      (cquantize->pub).color_quantize = quantize_ord_dither;
    cquantize->row_index = 0;
    break;
  case JDITHER_FS:
      ;
    (cquantize->pub).color_quantize = quantize_fs_dither;
    cquantize->on_odd_row = 0;
    arraysize = (size_t )((cinfo->output_width + 2) * (size_t )sizeof(FSERROR
      ));
    for(i = 0; i < cinfo->out_color_components; i++)
    {
      (cquantize->fserrors)[i] = (FSERRPTR )(*
	(cinfo->mem)->alloc_large)((j_common_ptr )cinfo, 1, arraysize);
      jzero_far((void *  )(cquantize->fserrors)[i], arraysize);
    }
    break;
  default :
      ;
    (cinfo->err)->msg_code = JERR_NOT_COMPILED, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
    break;
  }
  create_colormap(cinfo);
}


#pragma combiner("./jquant2.i", "-g -O -I/home/scott/wrk/safec/cil/lib ")

#pragma boxalloc("malloc", nozero, sizein(0))

#pragma boxalloc("alloca", nozero, sizein(0))

#pragma boxalloc("calloc", zero, sizemul(0, 1))

#pragma boxprintf("printf", 0)

#pragma boxprintf("fprintf", 1)

#pragma boxprintf("sprintf", 1)

#pragma boxprintf("snprintf", 2)

#pragma boxpoly("memcpy")

#pragma boxexported("main")
typedef UINT16 histcell ; /*typedef*/

typedef histcell *  histptr ; /*typedef*/

typedef histcell hist1d[1 << 5] ; /*typedef*/

typedef hist1d *  hist2d ; /*typedef*/

typedef hist2d *  hist3d ; /*typedef*/

typedef struct  {
  struct jpeg_color_quantizer pub ;
  hist3d histogram ;
  FSERRPTR fserrors ;
  boolean on_odd_row ;
  int *  error_limiter ;
} my_cquantizer_2 ; /*typedef*/

typedef my_cquantizer_2 *  my_cquantize_ptr__0 ; /*typedef*/

static void prescan_quantize(j_decompress_ptr cinfo , JSAMPARRAY input_buf ,
  JSAMPARRAY output_buf , int num_rows )
{
  my_cquantize_ptr__0 cquantize = (my_cquantize_ptr__0
    )cinfo->cquantize; /*decdef*/
  register JSAMPROW ptr ; /*decdef*/
  register histptr histp ; /*decdef*/
  register hist3d histogram = cquantize->histogram; /*decdef*/
  int row ; /*decdef*/
  JDIMENSION col ; /*decdef*/
  JDIMENSION width = cinfo->output_width; /*decdef*/
  for(row = 0; row < num_rows; row++)
  {
    ptr = input_buf[row];
    for(col = width; col > 0; col--)
    {
      histp = & ((histogram[(int )ptr[0] >> 8 - 5])[(int )ptr[1] >> 8 -
	6])[(int )ptr[2] >> 8 - 5];
      if(++ * histp <= 0)
	(* histp)--;
      ptr += 3;
    }
  }
}

typedef struct  {
  int c0min , c0max ;
  int c1min , c1max ;
  int c2min , c2max ;
  INT32 volume ;
  long colorcount ;
} box ; /*typedef*/

typedef box *  boxptr ; /*typedef*/

static boxptr find_biggest_color_pop(boxptr boxlist , int numboxes )
{
  register boxptr boxp ; /*decdef*/
  register int i ; /*decdef*/
  register long maxc = 0; /*decdef*/
  boxptr which = (void *  )0; /*decdef*/
  for(i = 0, boxp = boxlist; i < numboxes; i++, boxp++)
  {
    if(boxp->colorcount > maxc && boxp->volume > 0)
    {
      which = boxp;
      maxc = boxp->colorcount;
    }
  }
  return which;
}

static boxptr find_biggest_volume(boxptr boxlist , int numboxes )
{
  register boxptr boxp ; /*decdef*/
  register int i ; /*decdef*/
  register INT32 maxv = 0; /*decdef*/
  boxptr which = (void *  )0; /*decdef*/
  for(i = 0, boxp = boxlist; i < numboxes; i++, boxp++)
  {
    if(boxp->volume > maxv)
    {
      which = boxp;
      maxv = boxp->volume;
    }
  }
  return which;
}

static void update_box(j_decompress_ptr cinfo , boxptr boxp )
{
  my_cquantize_ptr__0 cquantize = (my_cquantize_ptr__0
    )cinfo->cquantize; /*decdef*/
  hist3d histogram = cquantize->histogram; /*decdef*/
  histptr histp ; /*decdef*/
  int c0 , c1 , c2 ; /*decdef*/
  int c0min , c0max , c1min , c1max , c2min , c2max ; /*decdef*/
  INT32 dist0 , dist1 , dist2 ; /*decdef*/
  long ccount ; /*decdef*/
  c0min = boxp->c0min;
  c0max = boxp->c0max;
  c1min = boxp->c1min;
  c1max = boxp->c1max;
  c2min = boxp->c2min;
  c2max = boxp->c2max;
  if(c0max > c0min)
    for(c0 = c0min; c0 <= c0max; c0++)
      for(c1 = c1min; c1 <= c1max; c1++)
      {
	histp = & ((histogram[c0])[c1])[c2min];
	for(c2 = c2min; c2 <= c2max; c2++)
	{
	  if(* histp++ != 0)
	  {
	    boxp->c0min = (c0min = c0);
	    goto have_c0min;
	  }
	}
      }
  have_c0min:
  {
    if(c0max > c0min)
      for(c0 = c0max; c0 >= c0min; c0--)
	for(c1 = c1min; c1 <= c1max; c1++)
	{
	  histp = & ((histogram[c0])[c1])[c2min];
	  for(c2 = c2min; c2 <= c2max; c2++)
	  {
	    if(* histp++ != 0)
	    {
	      boxp->c0max = (c0max = c0);
	      goto have_c0max;
	    }
	  }
	}
  }
  have_c0max:
  {
    if(c1max > c1min)
      for(c1 = c1min; c1 <= c1max; c1++)
	for(c0 = c0min; c0 <= c0max; c0++)
	{
	  histp = & ((histogram[c0])[c1])[c2min];
	  for(c2 = c2min; c2 <= c2max; c2++)
	  {
	    if(* histp++ != 0)
	    {
	      boxp->c1min = (c1min = c1);
	      goto have_c1min;
	    }
	  }
	}
  }
  have_c1min:
  {
    if(c1max > c1min)
      for(c1 = c1max; c1 >= c1min; c1--)
	for(c0 = c0min; c0 <= c0max; c0++)
	{
	  histp = & ((histogram[c0])[c1])[c2min];
	  for(c2 = c2min; c2 <= c2max; c2++)
	  {
	    if(* histp++ != 0)
	    {
	      boxp->c1max = (c1max = c1);
	      goto have_c1max;
	    }
	  }
	}
  }
  have_c1max:
  {
    if(c2max > c2min)
      for(c2 = c2min; c2 <= c2max; c2++)
	for(c0 = c0min; c0 <= c0max; c0++)
	{
	  histp = & ((histogram[c0])[c1min])[c2];
	  for(c1 = c1min; c1 <= c1max; c1++, histp += 1 << 5)
	  {
	    if(* histp != 0)
	    {
	      boxp->c2min = (c2min = c2);
	      goto have_c2min;
	    }
	  }
	}
  }
  have_c2min:
  {
    if(c2max > c2min)
      for(c2 = c2max; c2 >= c2min; c2--)
	for(c0 = c0min; c0 <= c0max; c0++)
	{
	  histp = & ((histogram[c0])[c1min])[c2];
	  for(c1 = c1min; c1 <= c1max; c1++, histp += 1 << 5)
	  {
	    if(* histp != 0)
	    {
	      boxp->c2max = (c2max = c2);
	      goto have_c2max;
	    }
	  }
	}
  }
  have_c2max:
    dist0 = (c0max - c0min << 8 - 5) * 2;
  dist1 = (c1max - c1min << 8 - 6) * 3;
  dist2 = (c2max - c2min << 8 - 5) * 1;
  boxp->volume = dist0 * dist0 + dist1 * dist1 + dist2 * dist2;
  ccount = 0;
  for(c0 = c0min; c0 <= c0max; c0++)
    for(c1 = c1min; c1 <= c1max; c1++)
    {
      histp = & ((histogram[c0])[c1])[c2min];
      for(c2 = c2min; c2 <= c2max; c2++, histp++)
      {
	if(* histp != 0)
	{
	  ccount++;
	}
      }
    }
  boxp->colorcount = ccount;
}

static int median_cut(j_decompress_ptr cinfo , boxptr boxlist , int numboxes ,
  int desired_colors )
{
  int n , lb ; /*decdef*/
  int c0 , c1 , c2 , cmax ; /*decdef*/
  register boxptr b1 , b2 ; /*decdef*/
  while(numboxes < desired_colors)
  {
    if(numboxes * 2 <= desired_colors)
    {
      b1 = find_biggest_color_pop(boxlist, numboxes);
    }
    else
    {
      b1 = find_biggest_volume(boxlist, numboxes);
    }
    if(b1 == (void *  )0)
      break;
    b2 = & boxlist[numboxes];
    b2->c0max = b1->c0max;
    b2->c1max = b1->c1max;
    b2->c2max = b1->c2max;
    b2->c0min = b1->c0min;
    b2->c1min = b1->c1min;
    b2->c2min = b1->c2min;
    c0 = (b1->c0max - b1->c0min << 8 - 5) * 2;
    c1 = (b1->c1max - b1->c1min << 8 - 6) * 3;
    c2 = (b1->c2max - b1->c2min << 8 - 5) * 1;
    cmax = c1;
    n = 1;
    if(c0 > cmax)
    {
      cmax = c0;
      n = 0;
    }
    if(c2 > cmax)
    {
      n = 2;
    }
    switch(n)
    {
    case 0:
	;
      lb = (b1->c0max + b1->c0min) / 2;
      b1->c0max = lb;
      b2->c0min = lb + 1;
      break;
    case 1:
	;
      lb = (b1->c1max + b1->c1min) / 2;
      b1->c1max = lb;
      b2->c1min = lb + 1;
      break;
    case 2:
	;
      lb = (b1->c2max + b1->c2min) / 2;
      b1->c2max = lb;
      b2->c2min = lb + 1;
      break;
    }
    update_box(cinfo, b1);
    update_box(cinfo, b2);
    numboxes++;
  }
  return numboxes;
}

static void compute_color(j_decompress_ptr cinfo , boxptr boxp , int icolor )
{
  my_cquantize_ptr__0 cquantize = (my_cquantize_ptr__0
    )cinfo->cquantize; /*decdef*/
  hist3d histogram = cquantize->histogram; /*decdef*/
  histptr histp ; /*decdef*/
  int c0 , c1 , c2 ; /*decdef*/
  int c0min , c0max , c1min , c1max , c2min , c2max ; /*decdef*/
  long count ; /*decdef*/
  long total = 0; /*decdef*/
  long c0total = 0; /*decdef*/
  long c1total = 0; /*decdef*/
  long c2total = 0; /*decdef*/
  c0min = boxp->c0min;
  c0max = boxp->c0max;
  c1min = boxp->c1min;
  c1max = boxp->c1max;
  c2min = boxp->c2min;
  c2max = boxp->c2max;
  for(c0 = c0min; c0 <= c0max; c0++)
    for(c1 = c1min; c1 <= c1max; c1++)
    {
      histp = & ((histogram[c0])[c1])[c2min];
      for(c2 = c2min; c2 <= c2max; c2++)
      {
	if((count = * histp++) != 0)
	{
	  total += count;
	  c0total += ((c0 << 8 - 5) + (1 << 8 - 5 >> 1)) * count;
	  c1total += ((c1 << 8 - 6) + (1 << 8 - 6 >> 1)) * count;
	  c2total += ((c2 << 8 - 5) + (1 << 8 - 5 >> 1)) * count;
	}
      }
    }
  ((cinfo->colormap)[0])[icolor] = (JSAMPLE )((c0total + (total >> 1)) / total);
  ((cinfo->colormap)[1])[icolor] = (JSAMPLE )((c1total + (total >> 1)) / total);
  ((cinfo->colormap)[2])[icolor] = (JSAMPLE )((c2total + (total >> 1)) / total);
}

static void select_colors(j_decompress_ptr cinfo )
{
  boxptr boxlist ; /*decdef*/
  int numboxes ; /*decdef*/
  int desired = cinfo->desired_number_of_colors; /*decdef*/
  int i ; /*decdef*/
  boxlist = (boxptr )(* (cinfo->mem)->alloc_small)((j_common_ptr )cinfo, 1,
    desired * (size_t )sizeof(box ));
  numboxes = 1;
  (boxlist[0]).c0min = 0;
  (boxlist[0]).c0max = 255 >> 8 - 5;
  (boxlist[0]).c1min = 0;
  (boxlist[0]).c1max = 255 >> 8 - 6;
  (boxlist[0]).c2min = 0;
  (boxlist[0]).c2max = 255 >> 8 - 5;
  update_box(cinfo, & boxlist[0]);
  numboxes = median_cut(cinfo, boxlist, numboxes, desired);
  for(i = 0; i < numboxes; i++)
    compute_color(cinfo, & boxlist[i], i);
  cinfo->actual_number_of_colors = numboxes;
  (cinfo->err)->msg_code = JTRC_QUANT_SELECTED, (((cinfo->err)->msg_parm).i)[0]
    = numboxes, (* (cinfo->err)->emit_message)((j_common_ptr )cinfo, 1);
}

static int find_nearby_colors(j_decompress_ptr cinfo , int minc0 , int minc1 ,
  int minc2 , JSAMPLE colorlist[] )
{
  int numcolors = cinfo->actual_number_of_colors; /*decdef*/
  int maxc0 , maxc1 , maxc2 ; /*decdef*/
  int centerc0 , centerc1 , centerc2 ; /*decdef*/
  int i , x , ncolors ; /*decdef*/
  INT32 minmaxdist , min_dist , max_dist , tdist ; /*decdef*/
  INT32 mindist[255 + 1] ; /*decdef*/
  maxc0 = minc0 + ((1 << 8 - 5 + (5 - 3)) - (1 << 8 - 5));
  centerc0 = minc0 + maxc0 >> 1;
  maxc1 = minc1 + ((1 << 8 - 6 + (6 - 3)) - (1 << 8 - 6));
  centerc1 = minc1 + maxc1 >> 1;
  maxc2 = minc2 + ((1 << 8 - 5 + (5 - 3)) - (1 << 8 - 5));
  centerc2 = minc2 + maxc2 >> 1;
  minmaxdist = 0x7FFFFFFFL;
  for(i = 0; i < numcolors; i++)
  {
    x = (int )((cinfo->colormap)[0])[i];
    if(x < minc0)
    {
      tdist = (x - minc0) * 2;
      min_dist = tdist * tdist;
      tdist = (x - maxc0) * 2;
      max_dist = tdist * tdist;
    }
    else
    {
      if(x > maxc0)
      {
	tdist = (x - maxc0) * 2;
	min_dist = tdist * tdist;
	tdist = (x - minc0) * 2;
	max_dist = tdist * tdist;
      }
      else
      {
	min_dist = 0;
	if(x <= centerc0)
	{
	  tdist = (x - maxc0) * 2;
	  max_dist = tdist * tdist;
	}
	else
	{
	  tdist = (x - minc0) * 2;
	  max_dist = tdist * tdist;
	}
      }
    }
    x = (int )((cinfo->colormap)[1])[i];
    if(x < minc1)
    {
      tdist = (x - minc1) * 3;
      min_dist += tdist * tdist;
      tdist = (x - maxc1) * 3;
      max_dist += tdist * tdist;
    }
    else
    {
      if(x > maxc1)
      {
	tdist = (x - maxc1) * 3;
	min_dist += tdist * tdist;
	tdist = (x - minc1) * 3;
	max_dist += tdist * tdist;
      }
      else
      {
	if(x <= centerc1)
	{
	  tdist = (x - maxc1) * 3;
	  max_dist += tdist * tdist;
	}
	else
	{
	  tdist = (x - minc1) * 3;
	  max_dist += tdist * tdist;
	}
      }
    }
    x = (int )((cinfo->colormap)[2])[i];
    if(x < minc2)
    {
      tdist = (x - minc2) * 1;
      min_dist += tdist * tdist;
      tdist = (x - maxc2) * 1;
      max_dist += tdist * tdist;
    }
    else
    {
      if(x > maxc2)
      {
	tdist = (x - maxc2) * 1;
	min_dist += tdist * tdist;
	tdist = (x - minc2) * 1;
	max_dist += tdist * tdist;
      }
      else
      {
	if(x <= centerc2)
	{
	  tdist = (x - maxc2) * 1;
	  max_dist += tdist * tdist;
	}
	else
	{
	  tdist = (x - minc2) * 1;
	  max_dist += tdist * tdist;
	}
      }
    }
    mindist[i] = min_dist;
    if(max_dist < minmaxdist)
      minmaxdist = max_dist;
  }
  ncolors = 0;
  for(i = 0; i < numcolors; i++)
  {
    if(mindist[i] <= minmaxdist)
      colorlist[ncolors++] = (JSAMPLE )i;
  }
  return ncolors;
}

static void find_best_colors(j_decompress_ptr cinfo , int minc0 , int minc1 ,
  int minc2 , int numcolors , JSAMPLE colorlist[] , JSAMPLE bestcolor[] )
{
  int ic0 , ic1 , ic2 ; /*decdef*/
  int i , icolor ; /*decdef*/
  register INT32 *  bptr ; /*decdef*/
  JSAMPLE *  cptr ; /*decdef*/
  INT32 dist0 , dist1 ; /*decdef*/
  register INT32 dist2 ; /*decdef*/
  INT32 xx0 , xx1 ; /*decdef*/
  register INT32 xx2 ; /*decdef*/
  INT32 inc0 , inc1 , inc2 ; /*decdef*/
  INT32 bestdist[(1 << 5 - 3) * (1 << 6 - 3) * (1 << 5 - 3)] ; /*decdef*/
  bptr = bestdist;
  for(i = (1 << 5 - 3) * (1 << 6 - 3) * (1 << 5 - 3) - 1; i >= 0; i--)
    * bptr++ = 0x7FFFFFFFL;
  for(i = 0; i < numcolors; i++)
  {
    icolor = (int )colorlist[i];
    inc0 = (minc0 - (int )((cinfo->colormap)[0])[icolor]) * 2;
    dist0 = inc0 * inc0;
    inc1 = (minc1 - (int )((cinfo->colormap)[1])[icolor]) * 3;
    dist0 += inc1 * inc1;
    inc2 = (minc2 - (int )((cinfo->colormap)[2])[icolor]) * 1;
    dist0 += inc2 * inc2;
    inc0 = inc0 * (2 * ((1 << 8 - 5) * 2)) + (1 << 8 - 5) * 2 * ((1 << 8 - 5) *
      2);
    inc1 = inc1 * (2 * ((1 << 8 - 6) * 3)) + (1 << 8 - 6) * 3 * ((1 << 8 - 6) *
      3);
    inc2 = inc2 * (2 * ((1 << 8 - 5) * 1)) + (1 << 8 - 5) * 1 * ((1 << 8 - 5) *
      1);
    bptr = bestdist;
    cptr = bestcolor;
    xx0 = inc0;
    for(ic0 = (1 << 5 - 3) - 1; ic0 >= 0; ic0--)
    {
      dist1 = dist0;
      xx1 = inc1;
      for(ic1 = (1 << 6 - 3) - 1; ic1 >= 0; ic1--)
      {
	dist2 = dist1;
	xx2 = inc2;
	for(ic2 = (1 << 5 - 3) - 1; ic2 >= 0; ic2--)
	{
	  if(dist2 < * bptr)
	  {
	    * bptr = dist2;
	    * cptr = (JSAMPLE )icolor;
	  }
	  dist2 += xx2;
	  xx2 += 2 * ((1 << 8 - 5) * 1) * ((1 << 8 - 5) * 1);
	  bptr++;
	  cptr++;
	}
	dist1 += xx1;
	xx1 += 2 * ((1 << 8 - 6) * 3) * ((1 << 8 - 6) * 3);
      }
      dist0 += xx0;
      xx0 += 2 * ((1 << 8 - 5) * 2) * ((1 << 8 - 5) * 2);
    }
  }
}

static void fill_inverse_cmap(j_decompress_ptr cinfo , int c0 , int c1 , int c2
  )
{
  my_cquantize_ptr__0 cquantize = (my_cquantize_ptr__0
    )cinfo->cquantize; /*decdef*/
  hist3d histogram = cquantize->histogram; /*decdef*/
  int minc0 , minc1 , minc2 ; /*decdef*/
  int ic0 , ic1 , ic2 ; /*decdef*/
  register JSAMPLE *  cptr ; /*decdef*/
  register histptr cachep ; /*decdef*/
  JSAMPLE colorlist[255 + 1] ; /*decdef*/
  int numcolors ; /*decdef*/
  JSAMPLE bestcolor[(1 << 5 - 3) * (1 << 6 - 3) * (1 << 5 - 3)] ; /*decdef*/
  c0 >>= 5 - 3;
  c1 >>= 6 - 3;
  c2 >>= 5 - 3;
  minc0 = (c0 << 8 - 5 + (5 - 3)) + (1 << 8 - 5 >> 1);
  minc1 = (c1 << 8 - 6 + (6 - 3)) + (1 << 8 - 6 >> 1);
  minc2 = (c2 << 8 - 5 + (5 - 3)) + (1 << 8 - 5 >> 1);
  numcolors = find_nearby_colors(cinfo, minc0, minc1, minc2, colorlist);
  find_best_colors(cinfo, minc0, minc1, minc2, numcolors, colorlist, bestcolor);
  c0 <<= 5 - 3;
  c1 <<= 6 - 3;
  c2 <<= 5 - 3;
  cptr = bestcolor;
  for(ic0 = 0; ic0 < 1 << 5 - 3; ic0++)
  {
    for(ic1 = 0; ic1 < 1 << 6 - 3; ic1++)
    {
      cachep = & ((histogram[c0 + ic0])[c1 + ic1])[c2];
      for(ic2 = 0; ic2 < 1 << 5 - 3; ic2++)
      {
	* cachep++ = (histcell )((int )(* cptr++) + 1);
      }
    }
  }
}

static void pass2_no_dither(j_decompress_ptr cinfo , JSAMPARRAY input_buf ,
  JSAMPARRAY output_buf , int num_rows )
{
  my_cquantize_ptr__0 cquantize = (my_cquantize_ptr__0
    )cinfo->cquantize; /*decdef*/
  hist3d histogram = cquantize->histogram; /*decdef*/
  register JSAMPROW inptr , outptr ; /*decdef*/
  register histptr cachep ; /*decdef*/
  register int c0 , c1 , c2 ; /*decdef*/
  int row ; /*decdef*/
  JDIMENSION col ; /*decdef*/
  JDIMENSION width = cinfo->output_width; /*decdef*/
  for(row = 0; row < num_rows; row++)
  {
    inptr = input_buf[row];
    outptr = output_buf[row];
    for(col = width; col > 0; col--)
    {
      c0 = (int )(* inptr++) >> 8 - 5;
      c1 = (int )(* inptr++) >> 8 - 6;
      c2 = (int )(* inptr++) >> 8 - 5;
      cachep = & ((histogram[c0])[c1])[c2];
      if(* cachep == 0)
	fill_inverse_cmap(cinfo, c0, c1, c2);
      * outptr++ = (JSAMPLE )(* cachep - 1);
    }
  }
}

static void pass2_fs_dither(j_decompress_ptr cinfo , JSAMPARRAY input_buf ,
  JSAMPARRAY output_buf , int num_rows )
{
  my_cquantize_ptr__0 cquantize = (my_cquantize_ptr__0
    )cinfo->cquantize; /*decdef*/
  hist3d histogram = cquantize->histogram; /*decdef*/
  register LOCFSERROR cur0 , cur1 , cur2 ; /*decdef*/
  LOCFSERROR belowerr0 , belowerr1 , belowerr2 ; /*decdef*/
  LOCFSERROR bpreverr0 , bpreverr1 , bpreverr2 ; /*decdef*/
  register FSERRPTR errorptr ; /*decdef*/
  JSAMPROW inptr ; /*decdef*/
  JSAMPROW outptr ; /*decdef*/
  histptr cachep ; /*decdef*/
  int dir ; /*decdef*/
  int dir3 ; /*decdef*/
  int row ; /*decdef*/
  JDIMENSION col ; /*decdef*/
  JDIMENSION width = cinfo->output_width; /*decdef*/
  JSAMPLE *  range_limit = cinfo->sample_range_limit; /*decdef*/
  int *  error_limit = cquantize->error_limiter; /*decdef*/
  JSAMPROW colormap0 = (cinfo->colormap)[0]; /*decdef*/
  JSAMPROW colormap1 = (cinfo->colormap)[1]; /*decdef*/
  JSAMPROW colormap2 = (cinfo->colormap)[2]; /*decdef*/
  for(row = 0; row < num_rows; row++)
  {
    inptr = input_buf[row];
    outptr = output_buf[row];
    if(cquantize->on_odd_row)
    {
      inptr += (width - 1) * 3;
      outptr += width - 1;
      dir = - 1;
      dir3 = - 3;
      errorptr = cquantize->fserrors + (width + 1) * 3;
      cquantize->on_odd_row = 0;
    }
    else
    {
      dir = 1;
      dir3 = 3;
      errorptr = cquantize->fserrors;
      cquantize->on_odd_row = 1;
    }
    cur0 = (cur1 = (cur2 = 0));
    belowerr0 = (belowerr1 = (belowerr2 = 0));
    bpreverr0 = (bpreverr1 = (bpreverr2 = 0));
    for(col = width; col > 0; col--)
    {
      cur0 = cur0 + errorptr[dir3 + 0] + 8 >> 4;
      cur1 = cur1 + errorptr[dir3 + 1] + 8 >> 4;
      cur2 = cur2 + errorptr[dir3 + 2] + 8 >> 4;
      cur0 = error_limit[cur0];
      cur1 = error_limit[cur1];
      cur2 = error_limit[cur2];
      cur0 += (int )inptr[0];
      cur1 += (int )inptr[1];
      cur2 += (int )inptr[2];
      cur0 = (int )range_limit[cur0];
      cur1 = (int )range_limit[cur1];
      cur2 = (int )range_limit[cur2];
      cachep = & ((histogram[cur0 >> 8 - 5])[cur1 >> 8 - 6])[cur2 >> 8 - 5];
      if(* cachep == 0)
	fill_inverse_cmap(cinfo, cur0 >> 8 - 5, cur1 >> 8 - 6, cur2 >> 8 - 5);
      {
	register int pixcode = * cachep - 1; /*decdef*/
	* outptr = (JSAMPLE )pixcode;
	cur0 -= (int )colormap0[pixcode];
	cur1 -= (int )colormap1[pixcode];
	cur2 -= (int )colormap2[pixcode];
      }
      {
	register LOCFSERROR bnexterr , delta ; /*decdef*/
	bnexterr = cur0;
	delta = cur0 * 2;
	cur0 += delta;
	errorptr[0] = (FSERROR )(bpreverr0 + cur0);
	cur0 += delta;
	bpreverr0 = belowerr0 + cur0;
	belowerr0 = bnexterr;
	cur0 += delta;
	bnexterr = cur1;
	delta = cur1 * 2;
	cur1 += delta;
	errorptr[1] = (FSERROR )(bpreverr1 + cur1);
	cur1 += delta;
	bpreverr1 = belowerr1 + cur1;
	belowerr1 = bnexterr;
	cur1 += delta;
	bnexterr = cur2;
	delta = cur2 * 2;
	cur2 += delta;
	errorptr[2] = (FSERROR )(bpreverr2 + cur2);
	cur2 += delta;
	bpreverr2 = belowerr2 + cur2;
	belowerr2 = bnexterr;
	cur2 += delta;
      }
      inptr += dir3;
      outptr += dir;
      errorptr += dir3;
    }
    errorptr[0] = (FSERROR )bpreverr0;
    errorptr[1] = (FSERROR )bpreverr1;
    errorptr[2] = (FSERROR )bpreverr2;
  }
}

static void init_error_limit(j_decompress_ptr cinfo )
{
  my_cquantize_ptr__0 cquantize = (my_cquantize_ptr__0
    )cinfo->cquantize; /*decdef*/
  int *  table ; /*decdef*/
  int in , out ; /*decdef*/
  table = (int *  )(* (cinfo->mem)->alloc_small)((j_common_ptr )cinfo, 1, (255 *
    2 + 1) * (size_t )sizeof(int ));
  table += 255;
  cquantize->error_limiter = table;
  out = 0;
  for(in = 0; in < (255 + 1) / 16; in++, out++)
  {
    table[in] = out;
    table[- in] = - out;
  }
  for(; in < (255 + 1) / 16 * 3; in++, out += in & 1 ? 0 : 1)
  {
    table[in] = out;
    table[- in] = - out;
  }
  for(; in <= 255; in++)
  {
    table[in] = out;
    table[- in] = - out;
  }
}

static void finish_pass1(j_decompress_ptr cinfo )
{
  select_colors(cinfo);
}

static void finish_pass2(j_decompress_ptr cinfo )
{
}

static void start_pass_2_quant(j_decompress_ptr cinfo , boolean is_pre_scan )
{
  my_cquantize_ptr__0 cquantize = (my_cquantize_ptr__0
    )cinfo->cquantize; /*decdef*/
  hist3d histogram = cquantize->histogram; /*decdef*/
  int i ; /*decdef*/
  if(is_pre_scan)
  {
    (cquantize->pub).color_quantize = prescan_quantize;
    (cquantize->pub).finish_pass = finish_pass1;
  }
  else
  {
    if(cinfo->dither_mode == JDITHER_FS)
      (cquantize->pub).color_quantize = pass2_fs_dither;
    else
      (cquantize->pub).color_quantize = pass2_no_dither;
    (cquantize->pub).finish_pass = finish_pass2;
  }
  for(i = 0; i < 1 << 5; i++)
  {
    jzero_far((void *  )histogram[i], (1 << 6) * (1 << 5) * (size_t
      )sizeof(histcell ));
  }
}

void jinit_2pass_quantizer(j_decompress_ptr cinfo )
{
  my_cquantize_ptr__0 cquantize ; /*decdef*/
  int i ; /*decdef*/
  cquantize = (my_cquantize_ptr__0 )(* (cinfo->mem)->alloc_small)((j_common_ptr
    )cinfo, 1, (size_t )sizeof(my_cquantizer_2 ));
  cinfo->cquantize = (struct jpeg_color_quantizer *  )cquantize;
  (cquantize->pub).start_pass = start_pass_2_quant;
  if(cinfo->out_color_components != 3)
    (cinfo->err)->msg_code = JERR_NOTIMPL, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  if(cinfo->dither_mode != JDITHER_NONE)
    cinfo->dither_mode = JDITHER_FS;
  i = cinfo->colormap != (void *  )0 ? cinfo->actual_number_of_colors
    : cinfo->desired_number_of_colors;
  if(i < 8)
    (cinfo->err)->msg_code = JERR_QUANT_FEW_COLORS,
      (((cinfo->err)->msg_parm).i)[0] = 8, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  if(i > 255 + 1)
    (cinfo->err)->msg_code = JERR_QUANT_MANY_COLORS,
      (((cinfo->err)->msg_parm).i)[0] = 255 + 1, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  cquantize->histogram = (hist3d )(* (cinfo->mem)->alloc_small)((j_common_ptr
    )cinfo, 1, (1 << 5) * (size_t )sizeof(* cquantize->histogram));
  for(i = 0; i < 1 << 5; i++)
  {
    (cquantize->histogram)[i] = (hist2d )(*
      (cinfo->mem)->alloc_large)((j_common_ptr )cinfo, 1, (1 << 6) * (1 << 5) *
      (size_t )sizeof(histcell ));
  }
  if(cinfo->colormap == (void *  )0)
  {
    cinfo->colormap = (* (cinfo->mem)->alloc_sarray)((j_common_ptr )cinfo, 1,
      (JDIMENSION )cinfo->desired_number_of_colors, (JDIMENSION )3);
  }
  if(cinfo->dither_mode == JDITHER_FS)
  {
    size_t arraysize = (size_t )((cinfo->output_width + 2) * (3 * (size_t
      )sizeof(FSERROR ))); /*decdef*/
    cquantize->fserrors = (FSERRPTR )(* (cinfo->mem)->alloc_large)((j_common_ptr
      )cinfo, 1, arraysize);
    jzero_far((void *  )cquantize->fserrors, arraysize);
    cquantize->on_odd_row = 0;
    init_error_limit(cinfo);
  }
}


#pragma combiner("./jdmerge.i", "-g -O -I/home/scott/wrk/safec/cil/lib ")

#pragma boxalloc("malloc", nozero, sizein(0))

#pragma boxalloc("alloca", nozero, sizein(0))

#pragma boxalloc("calloc", zero, sizemul(0, 1))

#pragma boxprintf("printf", 0)

#pragma boxprintf("fprintf", 1)

#pragma boxprintf("sprintf", 1)

#pragma boxprintf("snprintf", 2)

#pragma boxpoly("memcpy")

#pragma boxexported("main")
typedef struct  {
  struct jpeg_upsampler pub ;
  void ( *  upmethod )(j_decompress_ptr cinfo , JSAMPIMAGE input_buf ,
    JDIMENSION in_row_group_ctr , JSAMPARRAY output_buf ) ;
  int *  Cr_r_tab ;
  int *  Cb_b_tab ;
  INT32 *  Cr_g_tab ;
  INT32 *  Cb_g_tab ;
  JSAMPROW spare_row ;
  boolean spare_full ;
  JDIMENSION out_row_width ;
  JDIMENSION rows_to_go ;
} my_upsampler_merge ; /*typedef*/

typedef my_upsampler_merge *  my_upsample_ptr__0 ; /*typedef*/

static void start_pass_merged_upsample(j_decompress_ptr cinfo )
{
  my_upsample_ptr__0 upsample = (my_upsample_ptr__0 )cinfo->upsample; /*decdef*/
  INT32 i , x2 ; /*decdef*/
  upsample->spare_full = 0;
  upsample->rows_to_go = cinfo->output_height;
  upsample->Cr_r_tab = (int *  )(* (cinfo->mem)->alloc_small)((j_common_ptr
    )cinfo, 1, (255 + 1) * (size_t )sizeof(int ));
  upsample->Cb_b_tab = (int *  )(* (cinfo->mem)->alloc_small)((j_common_ptr
    )cinfo, 1, (255 + 1) * (size_t )sizeof(int ));
  upsample->Cr_g_tab = (INT32 *  )(* (cinfo->mem)->alloc_small)((j_common_ptr
    )cinfo, 1, (255 + 1) * (size_t )sizeof(INT32 ));
  upsample->Cb_g_tab = (INT32 *  )(* (cinfo->mem)->alloc_small)((j_common_ptr
    )cinfo, 1, (255 + 1) * (size_t )sizeof(INT32 ));
  for(i = 0; i <= 255; i++)
  {
    x2 = 2 * i - 255;
    (upsample->Cr_r_tab)[i] = (int )((INT32 )(1.40200 / 2 * (1L << 16) + 0.5) *
      x2 + ((INT32 )1 << 16 - 1) >> 16);
    (upsample->Cb_b_tab)[i] = (int )((INT32 )(1.77200 / 2 * (1L << 16) + 0.5) *
      x2 + ((INT32 )1 << 16 - 1) >> 16);
    (upsample->Cr_g_tab)[i] = - (INT32 )(0.71414 / 2 * (1L << 16) + 0.5) * x2;
    (upsample->Cb_g_tab)[i] = - (INT32 )(0.34414 / 2 * (1L << 16) + 0.5) * x2 +
      ((INT32 )1 << 16 - 1);
  }
}

static void merged_2v_upsample(j_decompress_ptr cinfo , JSAMPIMAGE input_buf ,
  JDIMENSION *  in_row_group_ctr , JDIMENSION in_row_groups_avail , JSAMPARRAY
  output_buf , JDIMENSION *  out_row_ctr , JDIMENSION out_rows_avail )
{
  my_upsample_ptr__0 upsample = (my_upsample_ptr__0 )cinfo->upsample; /*decdef*/
  JSAMPROW work_ptrs[2] ; /*decdef*/
  JDIMENSION num_rows ; /*decdef*/
  if(upsample->spare_full)
  {
    jcopy_sample_rows(& upsample->spare_row, 0, output_buf + * out_row_ctr, 0,
      1, upsample->out_row_width);
    num_rows = 1;
    upsample->spare_full = 0;
  }
  else
  {
    num_rows = 2;
    if(num_rows > upsample->rows_to_go)
      num_rows = upsample->rows_to_go;
    out_rows_avail -= * out_row_ctr;
    if(num_rows > out_rows_avail)
      num_rows = out_rows_avail;
    work_ptrs[0] = output_buf[* out_row_ctr];
    if(num_rows > 1)
    {
      work_ptrs[1] = output_buf[* out_row_ctr + 1];
    }
    else
    {
      work_ptrs[1] = upsample->spare_row;
      upsample->spare_full = 1;
    }
    (* upsample->upmethod)(cinfo, input_buf, * in_row_group_ctr, work_ptrs);
  }
  * out_row_ctr += num_rows;
  upsample->rows_to_go -= num_rows;
  if(! upsample->spare_full)
    (* in_row_group_ctr)++;
}

static void merged_1v_upsample(j_decompress_ptr cinfo , JSAMPIMAGE input_buf ,
  JDIMENSION *  in_row_group_ctr , JDIMENSION in_row_groups_avail , JSAMPARRAY
  output_buf , JDIMENSION *  out_row_ctr , JDIMENSION out_rows_avail )
{
  my_upsample_ptr__0 upsample = (my_upsample_ptr__0 )cinfo->upsample; /*decdef*/
  (* upsample->upmethod)(cinfo, input_buf, * in_row_group_ctr, output_buf + *
    out_row_ctr);
  (* out_row_ctr)++;
  (* in_row_group_ctr)++;
}

static void h2v1_merged_upsample(j_decompress_ptr cinfo , JSAMPIMAGE input_buf ,
  JDIMENSION in_row_group_ctr , JSAMPARRAY output_buf )
{
  my_upsample_ptr__0 upsample = (my_upsample_ptr__0 )cinfo->upsample; /*decdef*/
  register int y , cred , cgreen , cblue ; /*decdef*/
  int cb , cr ; /*decdef*/
  register JSAMPROW outptr ; /*decdef*/
  JSAMPROW inptr0 , inptr1 , inptr2 ; /*decdef*/
  JDIMENSION col ; /*decdef*/
  register JSAMPLE *  range_limit = cinfo->sample_range_limit; /*decdef*/
  int *  Crrtab = upsample->Cr_r_tab; /*decdef*/
  int *  Cbbtab = upsample->Cb_b_tab; /*decdef*/
  INT32 *  Crgtab = upsample->Cr_g_tab; /*decdef*/
  INT32 *  Cbgtab = upsample->Cb_g_tab; /*decdef*/
  inptr0 = (input_buf[0])[in_row_group_ctr];
  inptr1 = (input_buf[1])[in_row_group_ctr];
  inptr2 = (input_buf[2])[in_row_group_ctr];
  outptr = output_buf[0];
  for(col = cinfo->output_width >> 1; col > 0; col--)
  {
    cb = (int )(* inptr1++);
    cr = (int )(* inptr2++);
    cred = Crrtab[cr];
    cgreen = (int )(Cbgtab[cb] + Crgtab[cr] >> 16);
    cblue = Cbbtab[cb];
    y = (int )(* inptr0++);
    outptr[0] = range_limit[y + cred];
    outptr[1] = range_limit[y + cgreen];
    outptr[2] = range_limit[y + cblue];
    outptr += 3;
    y = (int )(* inptr0++);
    outptr[0] = range_limit[y + cred];
    outptr[1] = range_limit[y + cgreen];
    outptr[2] = range_limit[y + cblue];
    outptr += 3;
  }
  if(cinfo->output_width & 1)
  {
    cb = (int )(* inptr1);
    cr = (int )(* inptr2);
    cred = Crrtab[cr];
    cgreen = (int )(Cbgtab[cb] + Crgtab[cr] >> 16);
    cblue = Cbbtab[cb];
    y = (int )(* inptr0);
    outptr[0] = range_limit[y + cred];
    outptr[1] = range_limit[y + cgreen];
    outptr[2] = range_limit[y + cblue];
  }
}

static void h2v2_merged_upsample(j_decompress_ptr cinfo , JSAMPIMAGE input_buf ,
  JDIMENSION in_row_group_ctr , JSAMPARRAY output_buf )
{
  my_upsample_ptr__0 upsample = (my_upsample_ptr__0 )cinfo->upsample; /*decdef*/
  register int y , cred , cgreen , cblue ; /*decdef*/
  int cb , cr ; /*decdef*/
  register JSAMPROW outptr0 , outptr1 ; /*decdef*/
  JSAMPROW inptr00 , inptr01 , inptr1 , inptr2 ; /*decdef*/
  JDIMENSION col ; /*decdef*/
  register JSAMPLE *  range_limit = cinfo->sample_range_limit; /*decdef*/
  int *  Crrtab = upsample->Cr_r_tab; /*decdef*/
  int *  Cbbtab = upsample->Cb_b_tab; /*decdef*/
  INT32 *  Crgtab = upsample->Cr_g_tab; /*decdef*/
  INT32 *  Cbgtab = upsample->Cb_g_tab; /*decdef*/
  inptr00 = (input_buf[0])[in_row_group_ctr * 2];
  inptr01 = (input_buf[0])[in_row_group_ctr * 2 + 1];
  inptr1 = (input_buf[1])[in_row_group_ctr];
  inptr2 = (input_buf[2])[in_row_group_ctr];
  outptr0 = output_buf[0];
  outptr1 = output_buf[1];
  for(col = cinfo->output_width >> 1; col > 0; col--)
  {
    cb = (int )(* inptr1++);
    cr = (int )(* inptr2++);
    cred = Crrtab[cr];
    cgreen = (int )(Cbgtab[cb] + Crgtab[cr] >> 16);
    cblue = Cbbtab[cb];
    y = (int )(* inptr00++);
    outptr0[0] = range_limit[y + cred];
    outptr0[1] = range_limit[y + cgreen];
    outptr0[2] = range_limit[y + cblue];
    outptr0 += 3;
    y = (int )(* inptr00++);
    outptr0[0] = range_limit[y + cred];
    outptr0[1] = range_limit[y + cgreen];
    outptr0[2] = range_limit[y + cblue];
    outptr0 += 3;
    y = (int )(* inptr01++);
    outptr1[0] = range_limit[y + cred];
    outptr1[1] = range_limit[y + cgreen];
    outptr1[2] = range_limit[y + cblue];
    outptr1 += 3;
    y = (int )(* inptr01++);
    outptr1[0] = range_limit[y + cred];
    outptr1[1] = range_limit[y + cgreen];
    outptr1[2] = range_limit[y + cblue];
    outptr1 += 3;
  }
  if(cinfo->output_width & 1)
  {
    cb = (int )(* inptr1);
    cr = (int )(* inptr2);
    cred = Crrtab[cr];
    cgreen = (int )(Cbgtab[cb] + Crgtab[cr] >> 16);
    cblue = Cbbtab[cb];
    y = (int )(* inptr00);
    outptr0[0] = range_limit[y + cred];
    outptr0[1] = range_limit[y + cgreen];
    outptr0[2] = range_limit[y + cblue];
    y = (int )(* inptr01);
    outptr1[0] = range_limit[y + cred];
    outptr1[1] = range_limit[y + cgreen];
    outptr1[2] = range_limit[y + cblue];
  }
}

void jinit_merged_upsampler(j_decompress_ptr cinfo )
{
  my_upsample_ptr__0 upsample ; /*decdef*/
  upsample = (my_upsample_ptr__0 )(* (cinfo->mem)->alloc_small)((j_common_ptr
    )cinfo, 1, (size_t )sizeof(my_upsampler_merge ));
  cinfo->upsample = (struct jpeg_upsampler *  )upsample;
  (upsample->pub).start_pass = start_pass_merged_upsample;
  (upsample->pub).need_context_rows = 0;
  upsample->out_row_width = cinfo->output_width * cinfo->out_color_components;
  if(cinfo->max_v_samp_factor == 2)
  {
    (upsample->pub).upsample = merged_2v_upsample;
    upsample->upmethod = h2v2_merged_upsample;
    upsample->spare_row = (JSAMPROW )(* (cinfo->mem)->alloc_large)((j_common_ptr
      )cinfo, 1, (size_t )(upsample->out_row_width * (size_t )sizeof(JSAMPLE
      )));
  }
  else
  {
    (upsample->pub).upsample = merged_1v_upsample;
    upsample->upmethod = h2v1_merged_upsample;
    upsample->spare_row = (void *  )0;
  }
}


#pragma combiner("./jcomapi.i", "-g -O -I/home/scott/wrk/safec/cil/lib ")

#pragma boxalloc("malloc", nozero, sizein(0))

#pragma boxalloc("alloca", nozero, sizein(0))

#pragma boxalloc("calloc", zero, sizemul(0, 1))

#pragma boxprintf("printf", 0)

#pragma boxprintf("fprintf", 1)

#pragma boxprintf("sprintf", 1)

#pragma boxprintf("snprintf", 2)

#pragma boxpoly("memcpy")

#pragma boxexported("main")
void jpeg_abort(j_common_ptr cinfo )
{
  int pool ; /*decdef*/
  for(pool = 2 - 1; pool > 0; pool--)
  {
    (* (cinfo->mem)->free_pool)(cinfo, pool);
  }
  cinfo->global_state = cinfo->is_decompressor ? 200 : 100;
}

void jpeg_destroy(j_common_ptr cinfo )
{
  if(cinfo->mem != (void *  )0)
    (* (cinfo->mem)->self_destruct)(cinfo);
  cinfo->mem = (void *  )0;
  cinfo->global_state = 0;
}

JQUANT_TBL *  jpeg_alloc_quant_table(j_common_ptr cinfo )
{
  JQUANT_TBL *  tbl ; /*decdef*/
  tbl = (JQUANT_TBL *  )(* (cinfo->mem)->alloc_small)(cinfo, 0, (size_t
    )sizeof(JQUANT_TBL ));
  tbl->sent_table = 0;
  return tbl;
}

JHUFF_TBL *  jpeg_alloc_huff_table(j_common_ptr cinfo )
{
  JHUFF_TBL *  tbl ; /*decdef*/
  tbl = (JHUFF_TBL *  )(* (cinfo->mem)->alloc_small)(cinfo, 0, (size_t
    )sizeof(JHUFF_TBL ));
  tbl->sent_table = 0;
  return tbl;
}


#pragma combiner("./jutils.i", "-g -O -I/home/scott/wrk/safec/cil/lib ")

#pragma boxalloc("malloc", nozero, sizein(0))

#pragma boxalloc("alloca", nozero, sizein(0))

#pragma boxalloc("calloc", zero, sizemul(0, 1))

#pragma boxprintf("printf", 0)

#pragma boxprintf("fprintf", 1)

#pragma boxprintf("sprintf", 1)

#pragma boxprintf("snprintf", 2)

#pragma boxpoly("memcpy")

#pragma boxexported("main")
long jdiv_round_up(long a , long b )
{
  return (a + b - 1L) / b;
}

long jround_up(long a , long b )
{
  a += b - 1L;
  return a - a % b;
}

void jcopy_sample_rows(JSAMPARRAY input_array , int source_row , JSAMPARRAY
  output_array , int dest_row , int num_rows , JDIMENSION num_cols )
{
  register JSAMPROW inptr , outptr ; /*decdef*/
  register size_t count = (size_t )(num_cols * (size_t )sizeof(JSAMPLE
    )); /*decdef*/
  register int row ; /*decdef*/
  input_array += source_row;
  output_array += dest_row;
  for(row = num_rows; row > 0; row--)
  {
    inptr = * input_array++;
    outptr = * output_array++;
    memcpy((void *  )outptr, (const void *  )inptr, (size_t )count);
  }
}

void jcopy_block_row(JBLOCKROW input_row , JBLOCKROW output_row , JDIMENSION
  num_blocks )
{
  memcpy((void *  )output_row, (const void *  )input_row, (size_t )(num_blocks *
    (64 * (size_t )sizeof(JCOEF ))));
}

void jzero_far(void *  target , size_t bytestozero )
{
  memset((void *  )target, 0, (size_t )bytestozero);
}


#pragma combiner("./jerror.i", "-g -O -I/home/scott/wrk/safec/cil/lib ")

#pragma boxalloc("malloc", nozero, sizein(0))

#pragma boxalloc("alloca", nozero, sizein(0))

#pragma boxalloc("calloc", zero, sizemul(0, 1))

#pragma boxprintf("printf", 0)

#pragma boxprintf("fprintf", 1)

#pragma boxprintf("sprintf", 1)

#pragma boxprintf("snprintf", 2)

#pragma boxpoly("memcpy")

#pragma boxexported("main")
const char * const jpeg_message_table[] = {"Bogus message code %d",
  "Sorry, there are legal restrictions on arithmetic coding",
  "ALIGN_TYPE is wrong, please fix", "MAX_ALLOC_CHUNK is wrong, please fix",
  "Bogus buffer control mode", "Invalid component ID %d in SOS",
  "IDCT output block size %d not supported", "Bogus input colorspace",
  "Bogus JPEG colorspace", "Bogus marker length",
  "Sampling factors too large for interleaved scan",
  "Invalid memory pool code %d", "Unsupported JPEG data precision %d",
  "Bogus sampling factors", "Improper call to JPEG library in state %d",
  "Bogus virtual array access", "Buffer passed to JPEG library is too small",
  "Suspension not allowed here", "CCIR601 sampling not implemented yet",
  "Too many color components: %d, max %d",
  "Unsupported color conversion request", "Bogus DAC index %d",
  "Bogus DAC value 0x%x", "Bogus DHT counts", "Bogus DHT index %d",
  "Bogus DQT index %d", "Empty JPEG image (DNL not supported)",
  "Read from EMS failed", "Write to EMS failed",
  "Didn\'t expect more than one scan", "Input file read error",
  "Output file write error --- out of disk space?",
  "Fractional sampling not implemented yet", "Huffman code size table overflow",
  "Missing Huffman code table entry",
  "Maximum supported image dimension is %u pixels", "Empty input file",
  "Premature end of input file", "Unsupported JFIF revision number %d.%02d",
  "Not implemented yet", "Requested feature was omitted at compile time",
  "Backing store not supported", "Huffman table 0x%02x was not defined",
  "JPEG datastream contains no image",
  "Quantization table 0x%02x was not defined",
  "Not a JPEG file: starts with 0x%02x 0x%02x", "Insufficient memory (case %d)",
  "Cannot quantize more than %d color components",
  "Cannot quantize to fewer than %d colors",
  "Cannot quantize to more than %d colors",
  "Invalid JPEG file structure: two SOF markers",
  "Invalid JPEG file structure: missing SOS marker",
  "Unsupported JPEG process: SOF type 0x%02x",
  "Invalid JPEG file structure: two SOI markers",
  "Invalid JPEG file structure: SOS before SOF",
  "Failed to create temporary file %s", "Read failed on temporary file",
  "Seek failed on temporary file",
  "Write failed on temporary file --- out of disk space?",
  "Application transferred too few scanlines", "Unsupported marker type 0x%02x",
  "Virtual array controller messed up",
  "Image too wide for this implementation", "Read from XMS failed",
  "Write to XMS failed", "Copyright (C) 1994, Thomas G. Lane", "5  24-Sep-94",
  "Caution: quantization tables are too coarse for baseline JPEG",
  "Adobe APP14 marker: version %d, flags 0x%04x 0x%04x, transform %d",
  "Unknown APP0 marker (not JFIF), length %u",
  "Unknown APP14 marker (not Adobe), length %u",
  "Define Arithmetic Table 0x%02x: 0x%02x", "Define Huffman Table 0x%02x",
  "Define Quantization Table %d  precision %d", "Define Restart Interval %u",
  "Freed EMS handle %u", "Obtained EMS handle %u", "End Of Image",
  "        %3d %3d %3d %3d %3d %3d %3d %3d",
  "JFIF APP0 marker, density %dx%d  %d",
  "Warning: thumbnail image size does not match data length %u",
  "Warning: unknown JFIF revision number %d.%02d",
  "    with %d x %d thumbnail image", "Skipping marker 0x%02x, length %u",
  "Unexpected marker 0x%02x", "        %4u %4u %4u %4u %4u %4u %4u %4u",
  "Quantizing to %d = %d*%d*%d colors", "Quantizing to %d colors",
  "Selected %d colors for quantization", "At marker 0x%02x, recovery action %d",
  "RST%d", "Smoothing not supported with nonstandard sampling ratios",
  "Start Of Frame 0x%02x: width=%u, height=%u, components=%d",
  "    Component %d: %dhx%dv q=%d", "Start of Image",
  "Start Of Scan: %d components", "    Component %d: dc=%d ac=%d",
  "Closed temporary file %s", "Opened temporary file %s",
  "Unrecognized component IDs %d %d %d, assuming YCbCr", "Freed XMS handle %u",
  "Obtained XMS handle %u", "Unknown Adobe color transform code %d",
  "Corrupt JPEG data: %u extraneous bytes before marker 0x%02x",
  "Corrupt JPEG data: premature end of data segment",
  "Corrupt JPEG data: bad Huffman code", "Premature end of JPEG file",
  "Corrupt JPEG data: found marker 0x%02x instead of RST%d",
  "Invalid SOS parameters for sequential JPEG",
  "Application transferred too many scanlines", (void *  )0}; /*decdef*/

static void error_exit(j_common_ptr cinfo )
{
  (* (cinfo->err)->output_message)(cinfo);
  jpeg_destroy(cinfo);
  exit(1);
}

static void output_message(j_common_ptr cinfo )
{
  char buffer[200] ; /*decdef*/
  (* (cinfo->err)->format_message)(cinfo, buffer);
  fprintf(get_stderr(), "%s\n", buffer);
}

static void emit_message(j_common_ptr cinfo , int msg_level )
{
  struct jpeg_error_mgr *  err = cinfo->err; /*decdef*/
  if(msg_level < 0)
  {
    if(err->num_warnings == 0 || err->trace_level >= 3)
      (* err->output_message)(cinfo);
    err->num_warnings++;
  }
  else
  {
    if(err->trace_level >= msg_level)
      (* err->output_message)(cinfo);
  }
}

static void format_message(j_common_ptr cinfo , char *  buffer )
{
  struct jpeg_error_mgr *  err = cinfo->err; /*decdef*/
  int msg_code = err->msg_code; /*decdef*/
  const char *  msgtext = (void *  )0; /*decdef*/
  const char *  msgptr ; /*decdef*/
  char ch ; /*decdef*/
  boolean isstring ; /*decdef*/
  if(msg_code > 0 && msg_code <= err->last_jpeg_message)
  {
    msgtext = (err->jpeg_message_table)[msg_code];
  }
  else
  {
    if(err->addon_message_table != (void *  )0 && msg_code >=
      err->first_addon_message && msg_code <= err->last_addon_message)
    {
      msgtext = (err->addon_message_table)[msg_code - err->first_addon_message];
    }
  }
  if(msgtext == (void *  )0)
  {
    ((err->msg_parm).i)[0] = msg_code;
    msgtext = (err->jpeg_message_table)[0];
  }
  isstring = 0;
  msgptr = msgtext;
  while((ch = * msgptr++) != '\0')
  {
    if(ch == '%')
    {
      if(* msgptr == 's')
	isstring = 1;
      break;
    }
  }
  if(isstring)
    sprintf(buffer, msgtext, (err->msg_parm).s);
  else
    sprintf(buffer, msgtext, ((err->msg_parm).i)[0], ((err->msg_parm).i)[1],
      ((err->msg_parm).i)[2], ((err->msg_parm).i)[3], ((err->msg_parm).i)[4],
      ((err->msg_parm).i)[5], ((err->msg_parm).i)[6], ((err->msg_parm).i)[7]);
}

static void reset_error_mgr(j_common_ptr cinfo )
{
  (cinfo->err)->num_warnings = 0;
  (cinfo->err)->msg_code = 0;
}

struct jpeg_error_mgr *  jpeg_std_error(struct jpeg_error_mgr *  err )
{
  err->error_exit = error_exit;
  err->emit_message = emit_message;
  err->output_message = output_message;
  err->format_message = format_message;
  err->reset_error_mgr = reset_error_mgr;
  err->trace_level = 0;
  err->num_warnings = 0;
  err->msg_code = 0;
  err->jpeg_message_table = jpeg_message_table;
  err->last_jpeg_message = (int )JMSG_LASTMSGCODE - 1;
  err->addon_message_table = (void *  )0;
  err->first_addon_message = 0;
  err->last_addon_message = 0;
  return err;
}


// below here
#pragma combiner("./jmemmgr.i", "-g -O -I/home/scott/wrk/safec/cil/lib ")

#pragma boxalloc("malloc", nozero, sizein(0))

#pragma boxalloc("alloca", nozero, sizein(0))

#pragma boxalloc("calloc", zero, sizemul(0, 1))

#pragma boxprintf("printf", 0)

#pragma boxprintf("fprintf", 1)

#pragma boxprintf("sprintf", 1)

#pragma boxprintf("snprintf", 2)

#pragma boxpoly("memcpy")

#pragma boxexported("main")
extern void *  jpeg_get_small(j_common_ptr cinfo , size_t sizeofobject )
  ; /*decdef*/
extern void jpeg_free_small(j_common_ptr cinfo , void *  object , size_t
  sizeofobject ) ; /*decdef*/
extern void *  jpeg_get_large(j_common_ptr cinfo , size_t sizeofobject )
  ; /*decdef*/
extern void jpeg_free_large(j_common_ptr cinfo , void *  object , size_t
  sizeofobject ) ; /*decdef*/
extern long jpeg_mem_available(j_common_ptr cinfo , long min_bytes_needed ,
  long max_bytes_needed , long already_allocated ) ; /*decdef*/

typedef struct backing_store_struct *  backing_store_ptr ; /*typedef*/

typedef struct backing_store_struct {
  #if 0
  void ( *  read_backing_store )(j_common_ptr cinfo , backing_store_ptr info ,
    void *  buffer_address , long file_offset , long byte_count ) ;
  void ( *  write_backing_store )(j_common_ptr cinfo , backing_store_ptr info ,
    void *  buffer_address , long file_offset , long byte_count ) ;
  void ( *  close_backing_store )(j_common_ptr cinfo , backing_store_ptr info )
    ;
  FILE *  temp_file ;
  char temp_name[64] ;
  #endif // 0
} backing_store_info ; /*typedef*/

extern void jpeg_open_backing_store(j_common_ptr cinfo , backing_store_ptr info
  , long total_bytes_needed ) ; /*decdef*/
extern long jpeg_mem_init(j_common_ptr cinfo ) ; /*decdef*/
extern void jpeg_mem_term(j_common_ptr cinfo ) ; /*decdef*/

typedef union small_pool_struct *  small_pool_ptr ; /*typedef*/

typedef union small_pool_struct {
  struct  {
    small_pool_ptr next ;
    size_t bytes_used ;
    size_t bytes_left ;
  } hdr ;
  double dummy ;
} small_pool_hdr ; /*typedef*/

typedef union large_pool_struct *  large_pool_ptr ; /*typedef*/

typedef union large_pool_struct {
  struct  {
    large_pool_ptr next ;
    size_t bytes_used ;
    size_t bytes_left ;
  } hdr ;
  double dummy ;
} large_pool_hdr ; /*typedef*/

typedef struct  {
  struct jpeg_memory_mgr pub ;
  small_pool_ptr small_list[2] ;
  large_pool_ptr large_list[2] ;
  jvirt_sarray_ptr virt_sarray_list ;
  jvirt_barray_ptr virt_barray_list ;
  long total_space_allocated ;
  JDIMENSION last_rowsperchunk ;
} my_memory_mgr ; /*typedef*/

typedef my_memory_mgr *  my_mem_ptr ; /*typedef*/

// it's this structure
struct jvirt_sarray_control {
  JSAMPARRAY mem_buffer ;
  JDIMENSION rows_in_array ;
  JDIMENSION samplesperrow ;
  JDIMENSION unitheight ;
  JDIMENSION rows_in_mem ;
  JDIMENSION rowsperchunk ;
  JDIMENSION cur_start_row ;
  boolean dirty ;
  boolean b_s_open ;
  jvirt_sarray_ptr next ;
  backing_store_info b_s_info ;
} ; /*onlytypedef*/
#if 0

struct jvirt_barray_control {
  JBLOCKARRAY mem_buffer ;
  JDIMENSION rows_in_array ;
  JDIMENSION blocksperrow ;
  JDIMENSION unitheight ;
  JDIMENSION rows_in_mem ;
  JDIMENSION rowsperchunk ;
  JDIMENSION cur_start_row ;
  boolean dirty ;
  boolean b_s_open ;
  jvirt_barray_ptr next ;
  backing_store_info b_s_info ;
} ; /*onlytypedef*/

static void out_of_memory(j_common_ptr cinfo , int which )
{
  (cinfo->err)->msg_code = JERR_OUT_OF_MEMORY, (((cinfo->err)->msg_parm).i)[0] =
    which, (* (cinfo->err)->error_exit)((j_common_ptr )cinfo);
}

static const size_t first_pool_slop[2] = {1600, 16000}; /*decdef*/
static const size_t extra_pool_slop[2] = {0, 5000}; /*decdef*/

// above here
static void *  alloc_small(j_common_ptr cinfo , int pool_id , size_t
  sizeofobject )
{
  my_mem_ptr mem = (my_mem_ptr )cinfo->mem; /*decdef*/
  small_pool_ptr hdr_ptr , prev_hdr_ptr ; /*decdef*/
  char *  data_ptr ; /*decdef*/
  size_t odd_bytes , min_request , slop ; /*decdef*/
  if(sizeofobject > (size_t )(1000000000L - (size_t )sizeof(small_pool_hdr )))
    out_of_memory(cinfo, 1);
  odd_bytes = sizeofobject % (size_t )sizeof(double );
  if(odd_bytes > 0)
    sizeofobject += (size_t )sizeof(double ) - odd_bytes;
  if(pool_id < 0 || pool_id >= 2)
    (cinfo->err)->msg_code = JERR_BAD_POOL_ID, (((cinfo->err)->msg_parm).i)[0] =
      pool_id, (* (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  prev_hdr_ptr = (void *  )0;
  hdr_ptr = (mem->small_list)[pool_id];
  while(hdr_ptr != (void *  )0)
  {
    if((hdr_ptr->hdr).bytes_left >= sizeofobject)
      break;
    prev_hdr_ptr = hdr_ptr;
    hdr_ptr = (hdr_ptr->hdr).next;
  }
  if(hdr_ptr == (void *  )0)
  {
    min_request = sizeofobject + (size_t )sizeof(small_pool_hdr );
    if(prev_hdr_ptr == (void *  )0)
      slop = first_pool_slop[pool_id];
    else
      slop = extra_pool_slop[pool_id];
    if(slop > (size_t )(1000000000L - min_request))
      slop = (size_t )(1000000000L - min_request);
    for(; ; )
    {
      hdr_ptr = (small_pool_ptr )jpeg_get_small(cinfo, min_request + slop);
      if(hdr_ptr != (void *  )0)
	break;
      slop /= 2;
      if(slop < 50)
	out_of_memory(cinfo, 2);
    }
    mem->total_space_allocated += min_request + slop;
    (hdr_ptr->hdr).next = (void *  )0;
    (hdr_ptr->hdr).bytes_used = 0;
    (hdr_ptr->hdr).bytes_left = sizeofobject + slop;
    if(prev_hdr_ptr == (void *  )0)
      (mem->small_list)[pool_id] = hdr_ptr;
    else
      (prev_hdr_ptr->hdr).next = hdr_ptr;
  }
  data_ptr = (char *  )(hdr_ptr + 1);
  data_ptr += (hdr_ptr->hdr).bytes_used;
  (hdr_ptr->hdr).bytes_used += sizeofobject;
  (hdr_ptr->hdr).bytes_left -= sizeofobject;
  return (void *  )data_ptr;
}

static void *  alloc_large(j_common_ptr cinfo , int pool_id , size_t
  sizeofobject )
{
  my_mem_ptr mem = (my_mem_ptr )cinfo->mem; /*decdef*/
  large_pool_ptr hdr_ptr ; /*decdef*/
  size_t odd_bytes ; /*decdef*/
  if(sizeofobject > (size_t )(1000000000L - (size_t )sizeof(large_pool_hdr )))
    out_of_memory(cinfo, 3);
  odd_bytes = sizeofobject % (size_t )sizeof(double );
  if(odd_bytes > 0)
    sizeofobject += (size_t )sizeof(double ) - odd_bytes;
  if(pool_id < 0 || pool_id >= 2)
    (cinfo->err)->msg_code = JERR_BAD_POOL_ID, (((cinfo->err)->msg_parm).i)[0] =
      pool_id, (* (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  hdr_ptr = (large_pool_ptr )jpeg_get_large(cinfo, sizeofobject + (size_t
    )sizeof(large_pool_hdr ));
  if(hdr_ptr == (void *  )0)
    out_of_memory(cinfo, 4);
  mem->total_space_allocated += sizeofobject + (size_t )sizeof(large_pool_hdr );
  (hdr_ptr->hdr).next = (mem->large_list)[pool_id];
  (hdr_ptr->hdr).bytes_used = sizeofobject;
  (hdr_ptr->hdr).bytes_left = 0;
  (mem->large_list)[pool_id] = hdr_ptr;
  return (void *  )(hdr_ptr + 1);
}

static JSAMPARRAY alloc_sarray(j_common_ptr cinfo , int pool_id , JDIMENSION
  samplesperrow , JDIMENSION numrows )
{
  my_mem_ptr mem = (my_mem_ptr )cinfo->mem; /*decdef*/
  JSAMPARRAY result ; /*decdef*/
  JSAMPROW workspace ; /*decdef*/
  JDIMENSION rowsperchunk , currow , i ; /*decdef*/
  long ltemp ; /*decdef*/
  ltemp = (1000000000L - (size_t )sizeof(large_pool_hdr )) /
    ((long )samplesperrow * (size_t )sizeof(JSAMPLE ));
  if(ltemp <= 0)
    (cinfo->err)->msg_code = JERR_WIDTH_OVERFLOW, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  if(ltemp < (long )numrows)
    rowsperchunk = (JDIMENSION )ltemp;
  else
    rowsperchunk = numrows;
  mem->last_rowsperchunk = rowsperchunk;
  result = (JSAMPARRAY )alloc_small(cinfo, pool_id, (size_t )(numrows * (size_t
    )sizeof(* result)));
  currow = 0;
  while(currow < numrows)
  {
    rowsperchunk = rowsperchunk < numrows - currow ? rowsperchunk : numrows -
      currow;
    workspace = (JSAMPROW )alloc_large(cinfo, pool_id, (size_t )((size_t
      )rowsperchunk * (size_t )samplesperrow * (size_t )sizeof(JSAMPLE )));
    for(i = rowsperchunk; i > 0; i--)
    {
      result[currow++] = workspace;
      workspace += samplesperrow;
    }
  }
  return result;
}

static JBLOCKARRAY alloc_barray(j_common_ptr cinfo , int pool_id , JDIMENSION
  blocksperrow , JDIMENSION numrows )
{
  my_mem_ptr mem = (my_mem_ptr )cinfo->mem; /*decdef*/
  JBLOCKARRAY result ; /*decdef*/
  JBLOCKROW workspace ; /*decdef*/
  JDIMENSION rowsperchunk , currow , i ; /*decdef*/
  long ltemp ; /*decdef*/
  ltemp = (1000000000L - (size_t )sizeof(large_pool_hdr )) /
    ((long )blocksperrow * (size_t )sizeof(JBLOCK ));
  if(ltemp <= 0)
    (cinfo->err)->msg_code = JERR_WIDTH_OVERFLOW, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  if(ltemp < (long )numrows)
    rowsperchunk = (JDIMENSION )ltemp;
  else
    rowsperchunk = numrows;
  mem->last_rowsperchunk = rowsperchunk;
  result = (JBLOCKARRAY )alloc_small(cinfo, pool_id, (size_t )(numrows * (size_t
    )sizeof(* result)));
  currow = 0;
  while(currow < numrows)
  {
    rowsperchunk = rowsperchunk < numrows - currow ? rowsperchunk : numrows -
      currow;
    workspace = (JBLOCKROW )alloc_large(cinfo, pool_id, (size_t )((size_t
      )rowsperchunk * (size_t )blocksperrow * (size_t )sizeof(JBLOCK )));
    for(i = rowsperchunk; i > 0; i--)
    {
      result[currow++] = workspace;
      workspace += blocksperrow;
    }
  }
  return result;
}

static jvirt_sarray_ptr request_virt_sarray(j_common_ptr cinfo , int pool_id ,
  JDIMENSION samplesperrow , JDIMENSION numrows , JDIMENSION unitheight )
{
  my_mem_ptr mem = (my_mem_ptr )cinfo->mem; /*decdef*/
  jvirt_sarray_ptr result ; /*decdef*/
  if(pool_id != 1)
    (cinfo->err)->msg_code = JERR_BAD_POOL_ID, (((cinfo->err)->msg_parm).i)[0] =
      pool_id, (* (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  numrows = (JDIMENSION )jround_up((long )numrows, (long )unitheight);
  result = (jvirt_sarray_ptr )alloc_small(cinfo, pool_id, (size_t
    )sizeof(struct jvirt_sarray_control ));
  result->mem_buffer = (void *  )0;
  result->rows_in_array = numrows;
  result->samplesperrow = samplesperrow;
  result->unitheight = unitheight;
  result->b_s_open = 0;
  result->next = mem->virt_sarray_list;
  mem->virt_sarray_list = result;
  return result;
}

// above here

static jvirt_barray_ptr request_virt_barray(j_common_ptr cinfo , int pool_id ,
  JDIMENSION blocksperrow , JDIMENSION numrows , JDIMENSION unitheight )
{
  my_mem_ptr mem = (my_mem_ptr )cinfo->mem; /*decdef*/
  jvirt_barray_ptr result ; /*decdef*/
  if(pool_id != 1)
    (cinfo->err)->msg_code = JERR_BAD_POOL_ID, (((cinfo->err)->msg_parm).i)[0] =
      pool_id, (* (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  numrows = (JDIMENSION )jround_up((long )numrows, (long )unitheight);
  result = (jvirt_barray_ptr )alloc_small(cinfo, pool_id, (size_t
    )sizeof(struct jvirt_barray_control ));
  result->mem_buffer = (void *  )0;
  result->rows_in_array = numrows;
  result->blocksperrow = blocksperrow;
  result->unitheight = unitheight;
  result->b_s_open = 0;
  result->next = mem->virt_barray_list;
  mem->virt_barray_list = result;
  return result;
}

static void realize_virt_arrays(j_common_ptr cinfo )
{
  my_mem_ptr mem = (my_mem_ptr )cinfo->mem; /*decdef*/
  long space_per_unitheight , maximum_space , avail_mem ; /*decdef*/
  long unitheights , max_unitheights ; /*decdef*/
  jvirt_sarray_ptr sptr ; /*decdef*/
  jvirt_barray_ptr bptr ; /*decdef*/
  space_per_unitheight = 0;
  maximum_space = 0;
  for(sptr = mem->virt_sarray_list; sptr != (void *  )0; sptr = sptr->next)
  {
    if(sptr->mem_buffer == (void *  )0)
    {
      space_per_unitheight += (long )sptr->unitheight *
	(long )sptr->samplesperrow * (size_t )sizeof(JSAMPLE );
      maximum_space += (long )sptr->rows_in_array * (long )sptr->samplesperrow *
	(size_t )sizeof(JSAMPLE );
    }
  }
  for(bptr = mem->virt_barray_list; bptr != (void *  )0; bptr = bptr->next)
  {
    if(bptr->mem_buffer == (void *  )0)
    {
      space_per_unitheight += (long )bptr->unitheight *
	(long )bptr->blocksperrow * (size_t )sizeof(JBLOCK );
      maximum_space += (long )bptr->rows_in_array * (long )bptr->blocksperrow *
	(size_t )sizeof(JBLOCK );
    }
  }
  if(space_per_unitheight <= 0)
    return;
  avail_mem = jpeg_mem_available(cinfo, space_per_unitheight, maximum_space,
    mem->total_space_allocated);
  if(avail_mem >= maximum_space)
    max_unitheights = 1000000000L;
  else
  {
    max_unitheights = avail_mem / space_per_unitheight;
    if(max_unitheights <= 0)
      max_unitheights = 1;
  }
  for(sptr = mem->virt_sarray_list; sptr != (void *  )0; sptr = sptr->next)
  {
    if(sptr->mem_buffer == (void *  )0)
    {
      unitheights = ((long )sptr->rows_in_array - 1L) / sptr->unitheight + 1L;
      if(unitheights <= max_unitheights)
      {
	sptr->rows_in_mem = sptr->rows_in_array;
      }
      else
      {
	sptr->rows_in_mem = (JDIMENSION )(max_unitheights * sptr->unitheight);
	jpeg_open_backing_store(cinfo, & sptr->b_s_info,
	  (long )sptr->rows_in_array * (long )sptr->samplesperrow *
	  (long )((size_t )sizeof(JSAMPLE )));
	sptr->b_s_open = 1;
      }
      sptr->mem_buffer = alloc_sarray(cinfo, 1, sptr->samplesperrow,
	sptr->rows_in_mem);
      sptr->rowsperchunk = mem->last_rowsperchunk;
      sptr->cur_start_row = 0;
      sptr->dirty = 0;
    }
  }
  for(bptr = mem->virt_barray_list; bptr != (void *  )0; bptr = bptr->next)
  {
    if(bptr->mem_buffer == (void *  )0)
    {
      unitheights = ((long )bptr->rows_in_array - 1L) / bptr->unitheight + 1L;
      if(unitheights <= max_unitheights)
      {
	bptr->rows_in_mem = bptr->rows_in_array;
      }
      else
      {
	bptr->rows_in_mem = (JDIMENSION )(max_unitheights * bptr->unitheight);
	jpeg_open_backing_store(cinfo, & bptr->b_s_info,
	  (long )bptr->rows_in_array * (long )bptr->blocksperrow *
	  (long )((size_t )sizeof(JBLOCK )));
	bptr->b_s_open = 1;
      }
      bptr->mem_buffer = alloc_barray(cinfo, 1, bptr->blocksperrow,
	bptr->rows_in_mem);
      bptr->rowsperchunk = mem->last_rowsperchunk;
      bptr->cur_start_row = 0;
      bptr->dirty = 0;
    }
  }
}

static void do_sarray_io(j_common_ptr cinfo , jvirt_sarray_ptr ptr , boolean
  writing )
{
  long bytesperrow , file_offset , byte_count , rows , i ; /*decdef*/
  bytesperrow = (long )ptr->samplesperrow * (size_t )sizeof(JSAMPLE );
  file_offset = ptr->cur_start_row * bytesperrow;
  for(i = 0; i < (long )ptr->rows_in_mem; i += ptr->rowsperchunk)
  {
    rows = (long )ptr->rowsperchunk < (long )ptr->rows_in_mem - i
      ? (long )ptr->rowsperchunk : (long )ptr->rows_in_mem - i;
    rows = rows < (long )ptr->rows_in_array - ((long )ptr->cur_start_row + i)
      ? rows : (long )ptr->rows_in_array - ((long )ptr->cur_start_row + i);
    if(rows <= 0)
      break;
    byte_count = rows * bytesperrow;
    if(writing)
      (* (ptr->b_s_info).write_backing_store)(cinfo, & ptr->b_s_info, (void * 
	)(ptr->mem_buffer)[i], file_offset, byte_count);
    else
      (* (ptr->b_s_info).read_backing_store)(cinfo, & ptr->b_s_info, (void * 
	)(ptr->mem_buffer)[i], file_offset, byte_count);
    file_offset += byte_count;
  }
}

static void do_barray_io(j_common_ptr cinfo , jvirt_barray_ptr ptr , boolean
  writing )
{
  long bytesperrow , file_offset , byte_count , rows , i ; /*decdef*/
  bytesperrow = (long )ptr->blocksperrow * (size_t )sizeof(JBLOCK );
  file_offset = ptr->cur_start_row * bytesperrow;
  for(i = 0; i < (long )ptr->rows_in_mem; i += ptr->rowsperchunk)
  {
    rows = (long )ptr->rowsperchunk < (long )ptr->rows_in_mem - i
      ? (long )ptr->rowsperchunk : (long )ptr->rows_in_mem - i;
    rows = rows < (long )ptr->rows_in_array - ((long )ptr->cur_start_row + i)
      ? rows : (long )ptr->rows_in_array - ((long )ptr->cur_start_row + i);
    if(rows <= 0)
      break;
    byte_count = rows * bytesperrow;
    if(writing)
      (* (ptr->b_s_info).write_backing_store)(cinfo, & ptr->b_s_info, (void * 
	)(ptr->mem_buffer)[i], file_offset, byte_count);
    else
      (* (ptr->b_s_info).read_backing_store)(cinfo, & ptr->b_s_info, (void * 
	)(ptr->mem_buffer)[i], file_offset, byte_count);
    file_offset += byte_count;
  }
}

static JSAMPARRAY access_virt_sarray(j_common_ptr cinfo , jvirt_sarray_ptr ptr ,
  JDIMENSION start_row , boolean writable )
{
  if(start_row >= ptr->rows_in_array || ptr->mem_buffer == (void *  )0)
    (cinfo->err)->msg_code = JERR_BAD_VIRTUAL_ACCESS, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  if(start_row < ptr->cur_start_row || start_row + ptr->unitheight >
    ptr->cur_start_row + ptr->rows_in_mem)
  {
    if(! ptr->b_s_open)
      (cinfo->err)->msg_code = JERR_VIRTUAL_BUG, (*
	(cinfo->err)->error_exit)((j_common_ptr )cinfo);
    if(ptr->dirty)
    {
      do_sarray_io(cinfo, ptr, 1);
      ptr->dirty = 0;
    }
    if(start_row > ptr->cur_start_row)
    {
      ptr->cur_start_row = start_row;
    }
    else
    {
      long ltemp ; /*decdef*/
      ltemp = (long )start_row + (long )ptr->unitheight -
	(long )ptr->rows_in_mem;
      if(ltemp < 0)
	ltemp = 0;
      ptr->cur_start_row = (JDIMENSION )ltemp;
    }
    if(! writable)
    {
      do_sarray_io(cinfo, ptr, 0);
    }
  }
  if(writable)
    ptr->dirty = 1;
  return ptr->mem_buffer + (start_row - ptr->cur_start_row);
}

static JBLOCKARRAY access_virt_barray(j_common_ptr cinfo , jvirt_barray_ptr ptr
  , JDIMENSION start_row , boolean writable )
{
  if(start_row >= ptr->rows_in_array || ptr->mem_buffer == (void *  )0)
    (cinfo->err)->msg_code = JERR_BAD_VIRTUAL_ACCESS, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  if(start_row < ptr->cur_start_row || start_row + ptr->unitheight >
    ptr->cur_start_row + ptr->rows_in_mem)
  {
    if(! ptr->b_s_open)
      (cinfo->err)->msg_code = JERR_VIRTUAL_BUG, (*
	(cinfo->err)->error_exit)((j_common_ptr )cinfo);
    if(ptr->dirty)
    {
      do_barray_io(cinfo, ptr, 1);
      ptr->dirty = 0;
    }
    if(start_row > ptr->cur_start_row)
    {
      ptr->cur_start_row = start_row;
    }
    else
    {
      long ltemp ; /*decdef*/
      ltemp = (long )start_row + (long )ptr->unitheight -
	(long )ptr->rows_in_mem;
      if(ltemp < 0)
	ltemp = 0;
      ptr->cur_start_row = (JDIMENSION )ltemp;
    }
    if(! writable)
    {
      do_barray_io(cinfo, ptr, 0);
    }
  }
  if(writable)
    ptr->dirty = 1;
  return ptr->mem_buffer + (start_row - ptr->cur_start_row);
}

static void free_pool(j_common_ptr cinfo , int pool_id )
{
  my_mem_ptr mem = (my_mem_ptr )cinfo->mem; /*decdef*/
  small_pool_ptr shdr_ptr ; /*decdef*/
  large_pool_ptr lhdr_ptr ; /*decdef*/
  size_t space_freed ; /*decdef*/
  if(pool_id < 0 || pool_id >= 2)
    (cinfo->err)->msg_code = JERR_BAD_POOL_ID, (((cinfo->err)->msg_parm).i)[0] =
      pool_id, (* (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  if(pool_id == 1)
  {
    jvirt_sarray_ptr sptr ; /*decdef*/
    jvirt_barray_ptr bptr ; /*decdef*/
    for(sptr = mem->virt_sarray_list; sptr != (void *  )0; sptr = sptr->next)
    {
      if(sptr->b_s_open)
      {
	sptr->b_s_open = 0;
	(* (sptr->b_s_info).close_backing_store)(cinfo, & sptr->b_s_info);
      }
    }
    mem->virt_sarray_list = (void *  )0;
    for(bptr = mem->virt_barray_list; bptr != (void *  )0; bptr = bptr->next)
    {
      if(bptr->b_s_open)
      {
	bptr->b_s_open = 0;
	(* (bptr->b_s_info).close_backing_store)(cinfo, & bptr->b_s_info);
      }
    }
    mem->virt_barray_list = (void *  )0;
  }
  lhdr_ptr = (mem->large_list)[pool_id];
  (mem->large_list)[pool_id] = (void *  )0;
  while(lhdr_ptr != (void *  )0)
  {
    large_pool_ptr next_lhdr_ptr = (lhdr_ptr->hdr).next; /*decdef*/
    space_freed = (lhdr_ptr->hdr).bytes_used + (lhdr_ptr->hdr).bytes_left +
      (size_t )sizeof(large_pool_hdr );
    jpeg_free_large(cinfo, (void *  )lhdr_ptr, space_freed);
    mem->total_space_allocated -= space_freed;
    lhdr_ptr = next_lhdr_ptr;
  }
  shdr_ptr = (mem->small_list)[pool_id];
  (mem->small_list)[pool_id] = (void *  )0;
  while(shdr_ptr != (void *  )0)
  {
    small_pool_ptr next_shdr_ptr = (shdr_ptr->hdr).next; /*decdef*/
    space_freed = (shdr_ptr->hdr).bytes_used + (shdr_ptr->hdr).bytes_left +
      (size_t )sizeof(small_pool_hdr );
    jpeg_free_small(cinfo, (void *  )shdr_ptr, space_freed);
    mem->total_space_allocated -= space_freed;
    shdr_ptr = next_shdr_ptr;
  }
}

static void self_destruct(j_common_ptr cinfo )
{
  int pool ; /*decdef*/
  for(pool = 2 - 1; pool >= 0; pool--)
  {
    free_pool(cinfo, pool);
  }
  jpeg_free_small(cinfo, (void *  )cinfo->mem, (size_t )sizeof(my_memory_mgr ));
  cinfo->mem = (void *  )0;
  jpeg_mem_term(cinfo);
}

void jinit_memory_mgr(j_common_ptr cinfo )
{
  my_mem_ptr mem ; /*decdef*/
  long max_to_use ; /*decdef*/
  int pool ; /*decdef*/
  size_t test_mac ; /*decdef*/
  cinfo->mem = (void *  )0;
  if(((size_t )sizeof(double ) & (size_t )sizeof(double ) - 1) != 0)
    (cinfo->err)->msg_code = JERR_BAD_ALIGN_TYPE, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  test_mac = (size_t )1000000000L;
  if((long )test_mac != 1000000000L || 1000000000L % (size_t )sizeof(double ) !=
    0)
    (cinfo->err)->msg_code = JERR_BAD_ALLOC_CHUNK, (*
      (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  max_to_use = jpeg_mem_init(cinfo);
  mem = (my_mem_ptr )jpeg_get_small(cinfo, (size_t )sizeof(my_memory_mgr ));
  if(mem == (void *  )0)
  {
    jpeg_mem_term(cinfo);
    (cinfo->err)->msg_code = JERR_OUT_OF_MEMORY, (((cinfo->err)->msg_parm).i)[0]
      = 0, (* (cinfo->err)->error_exit)((j_common_ptr )cinfo);
  }
  (mem->pub).alloc_small = alloc_small;
  (mem->pub).alloc_large = alloc_large;
  (mem->pub).alloc_sarray = alloc_sarray;
  (mem->pub).alloc_barray = alloc_barray;
  (mem->pub).request_virt_sarray = request_virt_sarray;
  (mem->pub).request_virt_barray = request_virt_barray;
  (mem->pub).realize_virt_arrays = realize_virt_arrays;
  (mem->pub).access_virt_sarray = access_virt_sarray;
  (mem->pub).access_virt_barray = access_virt_barray;
  (mem->pub).free_pool = free_pool;
  (mem->pub).self_destruct = self_destruct;
  (mem->pub).max_memory_to_use = max_to_use;
  for(pool = 2 - 1; pool >= 0; pool--)
  {
    (mem->small_list)[pool] = (void *  )0;
    (mem->large_list)[pool] = (void *  )0;
  }
  mem->virt_sarray_list = (void *  )0;
  mem->virt_barray_list = (void *  )0;
  mem->total_space_allocated = (size_t )sizeof(my_memory_mgr );
  cinfo->mem = & mem->pub;
  {
    char *  memenv ; /*decdef*/
    if((memenv = getenv("JPEGMEM")) != (void *  )0)
    {
      char ch = 'x'; /*decdef*/
      if(sscanf(memenv, "%ld%c", & max_to_use, & ch) > 0)
      {
	if(ch == 'm' || ch == 'M')
	  max_to_use *= 1000L;
	(mem->pub).max_memory_to_use = max_to_use * 1000L;
      }
    }
  }
}


#pragma combiner("./jmemnobs.i", "-g -O -I/home/scott/wrk/safec/cil/lib ")

#pragma boxalloc("malloc", nozero, sizein(0))

#pragma boxalloc("alloca", nozero, sizein(0))

#pragma boxalloc("calloc", zero, sizemul(0, 1))

#pragma boxprintf("printf", 0)

#pragma boxprintf("fprintf", 1)

#pragma boxprintf("sprintf", 1)

#pragma boxprintf("snprintf", 2)

#pragma boxpoly("memcpy")

#pragma boxexported("main")
void *  jpeg_get_small(j_common_ptr cinfo , size_t sizeofobject )
{
  return (void *  )malloc(sizeofobject);
}

void jpeg_free_small(j_common_ptr cinfo , void *  object , size_t sizeofobject )
{
  free(object);
}

void *  jpeg_get_large(j_common_ptr cinfo , size_t sizeofobject )
{
  return (void *  )malloc(sizeofobject);
}

void jpeg_free_large(j_common_ptr cinfo , void *  object , size_t sizeofobject )
{
  free(object);
}

long jpeg_mem_available(j_common_ptr cinfo , long min_bytes_needed ,
  long max_bytes_needed , long already_allocated )
{
  return max_bytes_needed;
}

void jpeg_open_backing_store(j_common_ptr cinfo , backing_store_ptr info ,
  long total_bytes_needed )
{
  (cinfo->err)->msg_code = JERR_NO_BACKING_STORE, (*
    (cinfo->err)->error_exit)((j_common_ptr )cinfo);
}

long jpeg_mem_init(j_common_ptr cinfo )
{
  return 0;
}

void jpeg_mem_term(j_common_ptr cinfo )
{
}

#endif // 0
