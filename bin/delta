#!/usr/bin/perl -w
use strict;

# Implementation by Daniel Wilkerson of the delta debugging algorithm:
# http://www.st.cs.uni-sb.de/dd/


# FIX: 1) Want to hash the marker boundary points, not the string
# itself. 2) Want to build up the string by writing it out to disk,
# not by building in memory first.

# FIX: This ought to be a Perl module where you can plug in your own
# test function, but for now, just take this script and hack the test
# function yourself.

# FIX: There might be more opportunites to prevent extra string
# copying that I don't see, or the places where I think I'm preventing
# it I might not be.  I'm not sure I understand Perl references
# completely.

# FIX: I don't understand why in test I say
#  sub test (\$) {
#      my $test_data_ref = shift;
#      print $$test_data_ref;
#  and in run I need to say
#  sub run (\$) {
#      my $line_ref = shift;
#      print $line_ref, "\n";
#  Note that when used one must have a $$ prefix whereas the other
#  only one $.  Why?

# NOTE: There might be times when you can be sure you won't find
# anything in the cache ever again and you can just dump it.  Come to
# think of it, I don't see any opportunity for this.


# Global State ****************

my @chunks = ();                # Once input, is read only.
my @markers = ();               # Delimits a dynamic subsequence of @chunks being considered.
my %test_cache = ();            # Cached test results.
my $tmp_index = 0;              # Cache the last index used to make a tmp file.
my $tmpdir_index = 0;           # Cache the last index used to make a tmp directory.

my $tmpdir;                     # Temporary directory for external programs.
my $logfile = "Log";            # File in $tmpdir where log of successful runs is written.
my $granularity = "line";       # What is the size of an input chunk?
my $dump_input = 0;             # Dump out the input after reading it in.
my $cp_minimal;                 # Copy the minimal successful test to the current dir.
my $verbose = 0;                # Be more verbose.

my $help_message = <<END
    Delta Debugging
    delta.pl implements the delta-debugging algorithm: http://www.st.cs.uni-sb.de/dd/
    Implemented by Daniel Wilkerson.
    To get help.
      -help
    For verbose output.
      -verbose
    To read input in line or C-top-level-form granularity.
      -granularity=line or -granularity=top_form
    To dump the input after reading.
      -dump_input
    To copy the minimal successful test to the current directory when done.
      -cp_minimal=<filename>
END
;

# Functions ****************

# Return true iff this input produces an error (which we want).
sub test (\$) {
    my $test_data_ref = shift;  # NOTE: I'm careful to not copy the input.
    my $cached_result = $test_cache{$$test_data_ref}; # This has to be slow for big strings.
    if (defined $cached_result) {return $cached_result;}
    my @command_lines = ();
    my @tmp_files = ();
#    print "\nRunning test on data ****************\n", $$test_data_ref, "****************\n";

    # Test case.
    my $filename = unused_tempfile();
    my $input = "${tmpdir}/${filename}.c"; push @tmp_files, $input;
    put_into_file($$test_data_ref, $input);
    my $cmp_output = "${tmpdir}/${filename}.cmp"; push @tmp_files, $cmp_output;
    my $command = "gcc $input &> $cmp_output";
    push @command_lines, $command;
    my $result = 0;
    if (run($command)) {        # Only interesting if it compiles
        my $run_output = "${tmpdir}/${filename}.run"; push @tmp_files, $run_output;
        $command = "./a.out &> $run_output";
        push @command_lines, $command;
        if (! run($command)) {  # But does not run.
            $result = 1;
        }
    }

    # Actual ccured run.
#      my $command = <<END
#  CILLY_DONT_LINK_AFTER_MERGE=1 CILLY_DONT_COMPILE_AFTER_MERGE=1 /home/dsw/cil/bin/ccured --curetype=infer -I/home/dsw/cil/include -I/home/dsw/cil/include/gcc_2.95.3 --commPrintLn --tr=sm --verbose -D_GNUCC ${tmpdir}/$filename -o structs-cured 2>&1 | tee ${tmpdir}/${filename}.run | grep 'Bug:'
#  END
#      ;
#      my $result = run ($command);

    # Keep around info on successful runs.
    if ($result) {
        print "\tSUCCESS ****************\n";
        open LOG, ">>${tmpdir}/${logfile}" or die $!;
        print LOG "\n$filename\n";
        print LOG join("\n", @command_lines), "\n";
        close LOG or die $!;
    } else {
        foreach my $file (@tmp_files) {unlink $file;}
    }
    print "\n";
    $test_cache{$$test_data_ref} = $result;
    return $result;
}

# Append the marker-delimited data to the data string.  This modifies
# it second argument.
sub append_marker ($\$) {
  my $marker = shift;
  my $data_ref = shift;
  for (my $i=$marker->{start}; $i<$marker->{stop}; ++$i) {
    $$data_ref .= $chunks[$i];
  }
}

sub run (\$) {
    my $line_ref = shift;
    print $line_ref, "\n";
    my $unix_ret_val = system $line_ref;
    return $unix_ret_val ? 0 : 1;
}

sub put_into_file {
  my ($data, $filename) = @_;
#  die if -f $filename;
  open F, ">$filename" or die $!;
  print F $data;
  close F or die $!;
}

sub unused_tempfile {
    die unless defined $tmpdir;
    my $filename;
    do {
        $filename = sprintf("%03d", $tmp_index);
        $tmp_index++;
    } while -e "${tmpdir}/$filename";
    # FIX: This should be generalized.
    die if -f "${tmpdir}/${filename}";
    die if -f "${tmpdir}/${filename}.cmp";
    die if -f "${tmpdir}/${filename}.run";
    return $filename;
}

sub unused_tempdir {
  my $dirname;
  for (; $dirname = "deltatmp.${tmpdir_index}", -e $dirname; ++$tmpdir_index) {}
  return $dirname;
}

sub parse_command_line {
    my $str;
    my @non_flags = ();
    while(defined ($str = shift @ARGV)) {
        if ($str=~/^-([^=]+)(=(.+))?/) {
            my ($flag, $argument) = ($1, $3);
            if ($flag eq "help") {
                print $help_message;
                exit 0;
            } elsif ($flag eq "dump_input") {
                $dump_input++;
            } elsif ($flag eq "verbose") {
                $verbose++;
            } elsif ($flag eq "granularity") {
                if ($argument eq "line" || $argument eq "top_form") {
                    $granularity = $argument;
                }
            } elsif ($flag eq "cp_minimal") {
                $cp_minimal = $argument;
            } else {die "Illegal flag: $flag \n"}
        } else {push @non_flags, $str;}
    }
    push @ARGV, @non_flags;
}

sub dump_settings {
  print "Settings:\n";
  print "\ttemporary directory: $tmpdir\n";
  print "\tgranularity: $granularity\n";
  print "\tinput: ", join (" ", @ARGV), "\n";
  print "\n";
}

sub read_input_chunks {
    if ($granularity eq "line") {
        while (<>) {push @chunks, $_;} # Read one line at a time.
    } elsif ($granularity eq "top_form") {
        # Read chunks of C top-level forms.  I assume that any line
        # starting with '//# ' followed by a line that does not start
        # with a whitespace is a good boundary for a top-level form.
        # I'm sure you could do this in one line with the proper
        # setting to the regex that is the line seperator.
        my $chunk = "";
        my $a = <>;
        while (<>) {
            if ($a=~m|^//\# | and $_=~m|^\S|) {
                push @chunks, $chunk;
                $chunk = $a;
            } else {
                $chunk .= $a;
            }
            $a = $_;
        }
        $chunk .= $a;
        push @chunks, $chunk;
    } else {die "Illegal granularity setting: $granularity\n"}
}

sub dump_input {
  print "Dumping input ****************\n";
  if ($granularity eq "line") {
      foreach my $chunk (@chunks) {print $chunk;}
  } elsif ($granularity eq "top_form") {
      foreach my $chunk (@chunks) {print "\t-----\n", $chunk}
  } else {die "Illegal granularity setting: $granularity\n"}
  print "****************\n";
}

sub save_minimal_test {
  my ($marked) = @_;
  if (defined $cp_minimal) {
      print "Copying minimal run to $cp_minimal\n";
      put_into_file($marked, $cp_minimal);
  }
}

sub dump_markers {
  my $i = 0;
  foreach my $marker (@markers) {
    print "\t$i [", $marker->{start}, ", ", $marker->{stop}, "]\n";
    ++$i;
  }
}

sub increase_granularity {
  print "Increase granularity\n";
  print "Before ";
  dump_markers();
  my @newmarkers = ();
  my $split_one = 0;
  foreach my $marker (@markers) {
    my $half = int (($marker->{start} + $marker->{stop}) / 2);
    if ($half == $marker->{start} or $half == $marker->{stop}) {
#      warn "Can't split\n";
      push @newmarkers, $marker;
    } else {
      ++$split_one;
      push @newmarkers, {start=>$marker->{start}, stop=>$half};
      push @newmarkers, {start=>$half, stop=>$marker->{stop}};
    }
  }
  @markers = @newmarkers;
  print "After ";
  dump_markers();
  print "\n";
  return $split_one;
}

# Main ****************

parse_command_line();

# Perhaps I'll let the user pick the tmpdir name, but it had better
# not already exist.
$tmpdir = unused_tempdir() unless defined $tmpdir;
die if -e $tmpdir;
mkdir $tmpdir, 0777;

if ($verbose) {
    print "Delta debugging algorithm, implemented by Daniel Wilkerson.\n";
    dump_settings();
}

read_input_chunks();
die "The input must consist of at least one chunk." unless @chunks;
dump_input() if $dump_input;

$markers[0] = {start=>0, stop=>(scalar @chunks)}; # Initialize one marker.
my $marked = "";
append_marker($markers[0], $marked);
die "\n\t**************** FAIL: The initial input does not pass the test.\n\n"
  unless test($marked);

big_loop: {
  # Test the single markers.
  foreach my $test_marker (@markers) {
    # Test this marker.
    my $marked = "";
    append_marker($test_marker, $marked);
    if (test($marked)) {
      @markers = ($test_marker); # Get rid of all markers but this one.
      if (increase_granularity()) {redo big_loop;}
      else {
        print "Could not increase granularity; we are done.\n";
        print "A log of successful runs is in ${tmpdir}/${logfile}\n";
        save_minimal_test($marked);
        exit 0;
      }
    }
  }

  # Test the complements to single markers.
  foreach my $anti_test_marker (@markers) {
    # Test the complement to this marker.
    my $marked = "";
    my @newmarkers = ();        # Will become markers if we find something.
    foreach my $marker (@markers) {
      next if $marker eq $anti_test_marker;
      push @newmarkers, $marker;
      append_marker($marker, $marked);
    }
    if (test($marked)) {
      @markers = @newmarkers;   # Get rid of this marker.
      redo big_loop;
    }
  }

  # None of them worked, increase the granularity.
  if (increase_granularity()) {
    redo big_loop;
  } else {
    print "Could not increase granularity; we are done.\n";
    print "A log of successful runs is in ${tmpdir}/${logfile}\n";
    my $marked = "";
    foreach my $marker (@markers) {append_marker($marker, $marked);}
    save_minimal_test($marked);
    exit 0;
  }
}
