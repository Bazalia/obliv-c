#!/usr/bin/perl -w
use strict;

# Implementation by Daniel Wilkerson of the delta debugging algorithm:
# http://www.st.cs.uni-sb.de/dd/


# NOTE: This ought to be a Perl module where you can plug in your own
# test function, but for now, just take this script and hack the test
# function yourself.



# FIX: It might be a faster implementation to not hash the input to
# the test to see if the test_cache has it already, but instead to
# somehow hash the set of markers, as it is much smaller.  Then again,
# I'm sure the hashing algorithm in Perl for strings is very
# optimized.

# FIX: There might be times when you can be sure you won't find
# anything in the cache ever again and you can just dump it.

# FIX: There might be more opportunites to prevent extra string
# copying that I don't see, or the places where I think I'm preventing
# it I might not be.

# FIX: I don't understand why in test I say
#  sub test (\$) {
#      my $test_data_ref = shift;
#      print $$test_data_ref;
#  and in run I need to say
#  sub run (\$) {
#      my $line_ref = shift;
#      print $line_ref, "\n";
#  Note that when used one has a $$ prefix and the other a $.

# Global State ****************

my @chunks = ();                # Once input, is read only.
my @markers = ();               # Delimits a dynamic subsequence of @chunks being considered.
my %test_cache = ();            # Cached test results.
my $tmp_index = 0;              # Cache the last index used to make a tmp file.

my $tmpdir = "tmp";             # Temporary directory for external programs.
my $granularity = "line";       # What is the size of an input chunk?

my $help_message = <<END
    Delta Debugging
    delta.pl implements the delta-debugging algorithm: http://www.st.cs.uni-sb.de/dd/
    Implemented by Daniel Wilkerson.
    You can get help by specifying the help flag.
      -help
    It can read input in line or C top-level form granularity.
      -granularity=line or -granularity=top_form
END
;

# Functions ****************

# Return true iff this input produces an error (which we want).
sub test (\$) {
    my $test_data_ref = shift; # NOTE: I'm careful to not copy the input.
    my $cached_result = $test_cache{$$test_data_ref}; # This has to be slow for big strings.
    if (defined $cached_result) {return $cached_result;}
#    print "\nRunning test on data ****************\n", $$test_data_ref, "****************\n";
    my $filename = unused_tempfile();
    put_into_file($$test_data_ref, "${tmpdir}/$filename");
    my $result = 0;
    if (run("gcc ${tmpdir}/$filename &> ${tmpdir}/${filename}.cmp")) {    # Interesting if compiles
        if (! run("./a.out &> ${tmpdir}/${filename}.run")) {      # But does not run.
            $result = 1;
        }
    }
    $test_cache{$$test_data_ref} = $result;
    return $result;
}

sub parse_command_line {
  my $str;
  my @non_flags = ();
  while(defined ($str = shift @ARGV)) {
    if ($str=~/^-([^=]+)(=(.+))?/) {
      my ($flag, $argument) = ($1, $3);
#      warn "\tflag:$flag\n";
      if ($flag eq "help") {
        print $help_message;
        exit 0;
      } elsif ($flag eq "granularity") {
        if ($argument eq "line" || $argument eq "top_form") {
          $granularity = $argument;
        }
      } else {die "Illegal flag: $flag \n"}
    } else {push @non_flags, $str;}
  }
  push @ARGV, @non_flags;
}

sub dump_settings {
  print "Settings:\n";
  print "\tgranularity: $granularity\n";
  print "\tinput: ", join (" ", @ARGV), "\n";
  print "\n";
}

sub save_minimal_test {
  my ($marked) = @_;
  my $output_file = "minimal_test.c";
  print "Minimal test saved in $output_file\n";
  put_into_file($marked, $output_file);
}

sub run (\$) {
    my $line_ref = shift;
    print $line_ref, "\n";
    my $unix_ret_val = system $line_ref;
    return $unix_ret_val ? 0 : 1;
}

sub read_input_chunks {
  if ($granularity eq "line") {
    while (<>) {push @chunks, $_;} # Read one line at a time.
  } elsif ($granularity eq "top_form") {
    # Read chunks of C top-level forms.
  } else {die "Illegal granularity setting: $granularity\n"}
}

sub dump_input {
  print "Dumping input ****************\n";
  foreach my $chunk (@chunks) {print $chunk;}
  print "****************\n";
}

sub dump_markers {
  my $i = 0;
  foreach my $marker (@markers) {
    print "\t$i [", $marker->{start}, ", ", $marker->{stop}, "]\n";
    ++$i;
  }
}

sub unused_tempfile {
  my $filename;
  for (; $filename = "tmp${tmp_index}.c", -f "${tmpdir}/$filename"; ++$tmp_index) {}
  die if
    -f "${tmpdir}/${filename}" || -f "${tmpdir}/${filename}.cmp" || -f "${tmpdir}/${filename}.run";
  return $filename;
}

sub put_into_file {
  my ($data, $filename) = @_;
  die if -f $filename;
  open F, ">$filename" or die $!;
  print F $data;
  close F or die $!;
}

sub increase_granularity {
  print "Increase granularity\n";
  print "Before ";
  dump_markers();
  my @newmarkers = ();
  my $split_one = 0;
  foreach my $marker (@markers) {
    my $half = int (($marker->{start} + $marker->{stop}) / 2);
    if ($half == $marker->{start} or $half == $marker->{stop}) {
#      warn "Can't split\n";
      push @newmarkers, $marker;
    } else {
      ++$split_one;
      push @newmarkers, {start=>$marker->{start}, stop=>$half};
      push @newmarkers, {start=>$half, stop=>$marker->{stop}};
    }
  }
  @markers = @newmarkers;
  print "After ";
  dump_markers();
  return $split_one;
}

# Append the marker-delimited data to the data string.  This modifies
# it second argument.
sub append_marker ($\$) {
  my $marker = shift;
  my $data_ref = shift;
  for (my $i=$marker->{start}; $i<$marker->{stop}; ++$i) {
    $$data_ref .= $chunks[$i];
  }
}

# Main ****************

parse_command_line();
dump_settings();

if (! -d $tmpdir) {mkdir $tmpdir, 0777}
read_input_chunks();
die "The input must consist of at least one chunk." unless @chunks;
# dump_input();
$markers[0] = {start=>0, stop=>(scalar @chunks)}; # Initialize one marker.
my $marked = "";
append_marker($markers[0], $marked);
die "\n\t**************** FAIL: The initial input does not pass the test.\n\n"
  unless test($marked);

big_loop: {
  # Test the single markers.
  foreach my $test_marker (@markers) {
    # Test this marker.
    my $marked = "";
    append_marker($test_marker, $marked);
    if (test($marked)) {
      @markers = ($test_marker); # Get rid of all markers but this one.
      if (increase_granularity()) {redo big_loop;}
      else {
        print "Could not increase granularity; we are done.\n";
        save_minimal_test($marked);
        exit 0;
      }
    }
  }

  # Test the complements to single markers.
  foreach my $anti_test_marker (@markers) {
    # Test the complement to this marker.
    my $marked = "";
    my @newmarkers = ();        # Will become markers if we find something.
    foreach my $marker (@markers) {
      next if $marker eq $anti_test_marker;
      push @newmarkers, $marker;
      append_marker($marker, $marked);
    }
    if (test($marked)) {
      @markers = @newmarkers;   # Get rid of this marker.
      redo big_loop;
    }
  }

  # None of them worked, increase the granularity.
  if (increase_granularity()) {
    redo big_loop;
  } else {
    print "Could not increase granularity; we are done.\n";
    my $marked = "";
    foreach my $marker (@markers) {append_marker($marker, $marked);}
    save_minimal_test($marked);
    exit 0;
  }
}
