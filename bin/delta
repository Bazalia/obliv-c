#!/usr/bin/perl -w
use strict;

# Implementation by Daniel Wilkerson of the delta debugging algorithm:
# http://www.st.cs.uni-sb.de/dd/

# FIX: This ought to be a Perl module where you can plug in your own
# test function, but for now, just take this script and hack the test
# function yourself.

# FIX: What is the deal with this pass where we try every marker
# individually?  Does this ever find anything?  It seems very
# unlikely.  Take stats on this.  I think we can just remove it.

# FIX: It should probably start by throwing away things at the end
# rather than at the start, since I think they are least likely to be
# relevant.

# FIX: Could have running at various increasing base granularities.


# Global State ****************

my @chunks = ();                # Once input, is read only.
my @markers = ();               # Delimits a dynamic subsequence of @chunks being considered.
my %test_cache = ();            # Cached test results.

# Mark boundaries that uniquely determine the marked contents.  This
# is used as a shorter key to hash on than the contents themselves.
# Since Perl hashes retain their keys if you don't do this you get a
# horrible memory leak in the test_cache.
my $mark_signature;

# End of the last marker rendered to the tmp file.  Used to figure out
# if the next one abuts it or not.
my $last_mark_stop;
my @current_markers;            # Markers to be rendered to $tmpinput if answer not in cache.

#my @log_if_success;             # Messages to be written to the log on a successful test.
#my @delete_if_failure;          # Files to be unlinked on a failed test.

my $tmpinput;                   # Temporary file to render marked subsequence to.
my $last_successful_tmpinput;   # Last one to past the test.

my $tmp_index = 0;              # Cache the last index used to make a tmp file.
my $tmpdir_index = 0;           # Cache the last index used to make a tmp directory.
my $tmpdir;                     # Temporary directory for external programs.
my $logfile = "Log";            # File in $tmpdir where log of successful runs is written.
chomp (my $this_dir = `pwd`);   # The current directory.

my $granularity = "line";       # What is the size of an input chunk?
my $dump_input = 0;             # Dump out the input after reading it in.
my $cp_minimal;                 # Copy the minimal successful test to the current dir.
my $verbose = 0;                # Be more verbose.
my $input_suffix = ".c";        # For now, our input files are .c files.

my $help_message = <<END
    Delta Debugging
    delta.pl implements the delta-debugging algorithm: http://www.st.cs.uni-sb.de/dd/
    Implemented by Daniel Wilkerson.
    To get help.
      -help
    For verbose output.
      -verbose
    To read input in line or C-top-level-form granularity.
      -granularity=line or -granularity=top_form
    To dump the input after reading.
      -dump_input
    To copy the minimal successful test to the current directory when done.
      -cp_minimal=<filename>
END
;

# Functions ****************

sub make_tmpfile ($) {
    my ($filename) = @_;
    die if -e $filename;
#    push @delete_if_failure, $filename;
    return $filename;
}

# Return true if the current_markers pass the interesting test.
sub test {
    my $cached_result = $test_cache{$mark_signature};
    if (defined $cached_result) {
        print "\tcached\n";
        return $cached_result;
    }
    render_tmpinput();
#    @log_if_success = ();
#    @delete_if_failure = ();
    my $input = "${tmpdir}/${tmpinput}";
#    die unless -f $input; push @delete_if_failure, $input;

    die if system "rm -f ${tmpdir}/arena/*";
    my $arena_name = "input${input_suffix}";
    link $input, "${tmpdir}/arena/${arena_name}";
    my $result = ! system "cd ${tmpdir}/arena; ${this_dir}/hello.test ${arena_name}";

    # Test case specific.
#      my $result = 0;
#      my $cmp_output = make_tmpfile "${tmpdir}/${tmpinput}.cmp";
#      if (run("gcc $input &> $cmp_output")) {        # Only interesting if it compiles
#          my $run_output = make_tmpfile "${tmpdir}/${tmpinput}.run";
#          $result = ! run("./a.out &> $run_output"); # But does not run.
#      }

    # Actual ccured run.
#      my $command = <<END
#  CILLY_DONT_LINK_AFTER_MERGE=1 CILLY_DONT_COMPILE_AFTER_MERGE=1 /home/dsw/cil/bin/ccured --curetype=infer -I/home/dsw/cil/include -I/home/dsw/cil/include/gcc_2.95.3 --commPrintLn --tr=sm --verbose -D_GNUCC ${tmpdir}/$filename -o structs-cured 2>&1 | tee ${tmpdir}/${filename}.run | grep 'Bug:'
#  END
#      ;
#      my $result = run ($command);

    # Keep around info on successful runs.
    if ($result) {
        my $size = (split " ", `wc -l $input`)[0];
        print "\tSUCCESS, lines: $size ****************\n";
        open LOG, ">>${tmpdir}/${logfile}" or die $!;
        print LOG "$tmpinput, lines: $size\n";
#        print LOG join("\n", @log_if_success), "\n";
        close LOG or die $!;
        $last_successful_tmpinput = $tmpinput;
    } else {
        print "\n";
        unlink $input;
#        foreach my $file (@delete_if_failure) {
#            print "UNLINKING $file\n";
#            unlink $file;
#        }
    }
#    undef @log_if_success;
#    undef @delete_if_failure;
    return $test_cache{$mark_signature} = $result;
}

sub run ($) {
    my ($command) = @_;
    print $command, "\n";
#    push @log_if_success, $command;
    my $unix_ret_val = system $command;
    return $unix_ret_val ? 0 : 1;
}

sub render_tmpinput {
    $tmpinput = unused_tempfile();
    open TMPINPUT, ">${tmpdir}/$tmpinput" or die $!;
    foreach my $marker (@current_markers) {
        for (my $i=$marker->{start}; $i<$marker->{stop}; ++$i) {
            print TMPINPUT $chunks[$i];
        }
    }
    close TMPINPUT or die $!;   # NOTE: Leave $tmpinput defined.
}

sub start_marking {
    @current_markers = ();
    $mark_signature = "";
    undef $last_mark_stop;
}

sub mark {
    my ($marker) = @_;
    push @current_markers, $marker;
    if (defined $last_mark_stop) {
        if ($last_mark_stop < $marker->{start}) {
            $mark_signature .= $last_mark_stop . "]";
            $mark_signature .= "[" . $marker->{start} . ",";
        } elsif ($last_mark_stop == $marker->{start}) {
            # This marker abuts the previous one.
        } else {die}
    } else {
        $mark_signature .= "[" . $marker->{start} . ",";
    }
    $last_mark_stop = $marker->{stop};
}

sub stop_marking {
    $mark_signature .= $last_mark_stop . "]" if defined $last_mark_stop;
    print $mark_signature;
}

sub unused_tempfile {
    die unless defined $tmpdir;
    my $filename;
    do {
        $filename = sprintf("%03d", $tmp_index) . $input_suffix;
        $tmp_index++;
    } while -e "${tmpdir}/$filename";
    return $filename;
}

sub unused_tempdir {
  my $dirname;
  for (; $dirname = "tmp.${tmpdir_index}", -e $dirname; ++$tmpdir_index) {}
  return $dirname;
}

sub select_tmpdir {
    $tmpdir = unused_tempdir() unless defined $tmpdir;
    die if -e $tmpdir;
    mkdir $tmpdir, 0777;
    mkdir "${tmpdir}/arena", 0777;
}

sub parse_command_line {
    my $str;
    my @non_flags = ();
    while(defined ($str = shift @ARGV)) {
        if ($str=~/^-([^=]+)(=(.+))?/) {
            my ($flag, $argument) = ($1, $3);
            if ($flag eq "help") {
                print $help_message;
                exit 0;
            } elsif ($flag eq "dump_input") {
                $dump_input++;
            } elsif ($flag eq "verbose") {
                $verbose++;
            } elsif ($flag eq "granularity") {
                if ($argument eq "line" || $argument eq "top_form") {
                    $granularity = $argument;
                }
            } elsif ($flag eq "cp_minimal") {
                $cp_minimal = $argument;
            } else {die "Illegal flag: $flag \n"}
        } else {push @non_flags, $str;}
    }
    push @ARGV, @non_flags;
}

sub dump_settings {
  print "Settings:\n";
  print "\ttemporary directory: $tmpdir\n";
  print "\tgranularity: $granularity\n";
  print "\tinput: ", join (" ", @ARGV), "\n";
  print "\n";
}

sub read_input_chunks {
    if ($granularity eq "line") {
        while (<>) {push @chunks, $_;} # Read one line at a time.
    } elsif ($granularity eq "top_form") {
        # Read chunks of C top-level forms.  I assume that any line
        # starting with '//# ' followed by a line that does not start
        # with a whitespace is a good boundary for a top-level form.
        # I'm sure you could do this in one line with the proper
        # setting to the regex that is the line seperator.
        my $chunk = "";
        my $a = <>;
        while (<>) {
            if ($a=~m|^//\# | and $_=~m|^\S|) {
                push @chunks, $chunk;
                $chunk = $a;
            } else {
                $chunk .= $a;
            }
            $a = $_;
        }
        $chunk .= $a;
        push @chunks, $chunk;
    } else {die "Illegal granularity setting: $granularity\n"}
}

sub dump_input {
  print "Dumping input ****************\n";
  if ($granularity eq "line") {
      foreach my $chunk (@chunks) {print $chunk;}
  } elsif ($granularity eq "top_form") {
      foreach my $chunk (@chunks) {print "\t-----\n", $chunk}
  } else {die "Illegal granularity setting: $granularity\n"}
  print "****************\n";
}

sub check_initial_input {
    die "The input must consist of at least one chunk." unless @chunks;
    start_marking();
    mark($markers[0]);
    stop_marking();
    die "\n\t**************** FAIL: The initial input does not pass the test.\n\n"
        unless test();
}

sub dump_markers {
  my $i = 0;
  foreach my $marker (@markers) {
    print "\t$i [", $marker->{start}, ", ", $marker->{stop}, "]\n";
    ++$i;
  }
}

sub increase_granularity {
  print "\nIncrease granularity\n";
  print "Before ";
  dump_markers();
  my @newmarkers = ();
  my $split_one = 0;
  foreach my $marker (@markers) {
    my $half = int (($marker->{start} + $marker->{stop}) / 2);
    if ($half == $marker->{start} or $half == $marker->{stop}) {
      push @newmarkers, $marker;
    } else {
      ++$split_one;
      push @newmarkers, {start=>$marker->{start}, stop=>$half};
      push @newmarkers, {start=>$half, stop=>$marker->{stop}};
    }
  }
  @markers = @newmarkers;
  print "After ";
  dump_markers();
  print "\n";
  return $split_one;
}

sub done {
    print "Could not increase granularity; we are done.\n";
    print "A log of successful runs is in ${tmpdir}/${logfile}\n";
    if (defined $cp_minimal) {
        print "Copying minimal run to $cp_minimal\n";
        die "cp failed" if system "cp ${tmpdir}/${last_successful_tmpinput} $cp_minimal";
    }
    open LOG, ">>${tmpdir}/${logfile}" or die $!;
    print LOG "\nDone.\n";
    close LOG or die $!;
    exit 0;
}

# Main ****************

parse_command_line();
select_tmpdir();
if ($verbose) {
    print "\nDelta debugging algorithm, implemented by Daniel Wilkerson.\n";
    dump_settings();
}

read_input_chunks();
dump_input() if $dump_input;
$markers[0] = {start=>0, stop=>(scalar @chunks)}; # Initialize one marker.
check_initial_input();          # This is a vital step!  Don't omit it!

big_loop: {
    # Test the single markers.
    foreach my $test_marker (@markers) {
        start_marking();
        mark($test_marker);
        stop_marking();
        if (test()) {
            @markers = ($test_marker); # Get rid of all markers but this one.
            if (increase_granularity()) {redo big_loop;}
            else {done()}
        }
    }

    # Test the complements to single markers.
    foreach my $anti_test_marker (@markers) {
        start_marking();
        my @newmarkers = ();    # Will become markers if we find something.
        foreach my $marker (@markers) {
            next if $marker eq $anti_test_marker;
            mark($marker);
            push @newmarkers, $marker;
        }
        stop_marking();
        if (test()) {
            @markers = @newmarkers; # Get rid of this marker.
            redo big_loop;
        }
    }

    # None of them worked, increase the granularity.
    if (increase_granularity()) {redo big_loop;}
    else {done()}
}
