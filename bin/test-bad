#!/bin/sh
# run a regression test containing one or more intentional failures
#
# To create a source file to be processed by this script do:
# - the file should be a standalone program with main without any arguments
# - add a comment
#    // NUMERRORS n
#   where n is the number of errors to be tested by this file
# - add after certain lines in your file comments (1 <= k <= n)
#    // ERROR(k)
# - first all ERROR-lines are removed and the program must succeed.
# - to test for error k all ERROR lines except those with label ERROR(k)
#   are removed from the file, and the program is expected to fail
# - If you add after the ERROR(k) label a ":" then the failure is considered
#   expected only if everything that follows the 
#   colon in that line appears in the output of the program 
# Simple example:
#   // simple.c
#   // NUMERRORS 2
#   int main()
#   {
#     char *p = (char*)0;   // ERROR(1)
#     *p = 0;               // ERROR(1) - segfault
#     return 2;             // ERROR(2) - returning failure code
#     return 0;             // non-error case
#   }
#

if [ "$1" = "" ]; then
  # most parameters are passed by name, instead of as positional
  # arguments, for better impedance match with Makefile; but it's
  # good to have at least 1 positional arg so when it's missing I
  # can easily tell, and print this message
  echo "usage: CCUREDHOME=... CCURED=... CFLAGS=... $0 source-file.c"
  echo "You can also set RUNONLY=n to run only the nth iteration"
  exit 0
fi
srcfile="$1"
# Construct the name of the temporary file to use
srcfilenoext=`echo $srcfile | sed s/.c\$//`
tmpname="$srcfilenoext-tmp"
cd "$CCUREDHOME/test/small2" || exit

# read how many failure cases are in the file; expect line of form
# "// NUMERRORS n"
numcases=`grep NUMERRORS "$srcfile" | awk '{ print $3 }'`
if [ -z "$numcases" ]; then
  echo "didn't find a string of form NUMERRORS <n> in the file"
  exit 2
fi
echo "there are $numcases failure cases in this file"


# iterate through the cases; first case (0) is where no errors are present
i=0
if [ "$RUNONLY" != "" ] ;then
   i=$RUNONLY
fi
while [ $i -le $numcases ]; do
  echo
  echo
  echo "********************** Iteration $i"
  echo
  echo
  # generate a temporary file; first hide the ERROR tags which identify
  # the current test, then remove all remaining ERROR lines
  # (syntax for errors has parentheses so if I have >=10 cases I don't
  # run into problems where e.g. ERROR1 is a substring of ERROR10)
  echo "generating test $i"
  rm -f $tmpname.c 2>/dev/null
  cat "$srcfile" | sed "s/ERROR($i)/(selected: $i)/" \
                 | grep -v ERROR > "$tmpname.c"
  chmod a-w "$tmpname.c"

  # Grab the errorline for this test case
  themsg=`cat "$srcfile" | grep "ERROR($i).*:" | sed "s/^.*ERROR.*://" `
  if [ "x$themsg" != "x" ] ;then 
     echo "Expecting error message:$themsg"
  fi

  # compile this with our tool
  rm -f test-bad.out test-bad.err
  echo $CCURED $CFLAGS $tmpname.c -o $tmpname
  $CCUREDHOME/bin/teetwo test-bad.out test-bad.err \
                         $CCURED $CFLAGS $tmpname.c -o $tmpname
  status=$?
  if [ $status != 0 ]; then
    if [ $i = 0 ] ;then
      echo "The 0th iteration failed to CURE! It is supposed to succeed."
      exit $status
    else
      if [ "x$themsg" != "x" ] ;then
         echo grep "$themsg" test-bad.out test-bad.err
         if ! grep "$themsg" test-bad.out test-bad.err  ;then
            echo "The ${i}th iteration failed to CURE but cannot find: $themsg"
            exit 3
         else
           echo "The ${i}th iteration failed to CURE, as expected!"
         fi
      else
         echo "The ${i}th iteration failed to CURE. We expected some failure!"
      fi
      i=`expr $i + 1`
      continue
    fi
  fi

  # run it
  echo "./$tmpname"
  rm -f test-bad.out test-bad.err
  if $CCUREDHOME/bin/teetwo test-bad.out test-bad.err ./$tmpname ; then
    if [ $i = 0 ]; then
      # expected success on 0th iteration
      echo "(succeeded as expected)"
    else
      # unexpected success on >0th iteration
      echo "The ${i}th iteration did not fail!  It is supposed to fail."
      exit 2
    fi
  else
    if [ $i = 0 ]; then
      # unexpected failure on 0th iteration
      echo "The 0th iteration failed! It is supposed to succeed."
      #cat $tmpname.c
      exit 2
    else
      # expected failure on >0th iteration
      if [ "x$themsg" != "x" ] ;then
         echo grep "$themsg" test-bad.out test-bad.err
         if ! grep "$themsg" test-bad.out test-bad.err ;then
            echo "The ${i}th iteration failed but cannot find:$themsg"
            exit 3
         fi
      fi
      echo "(failed as expected)"
    fi
  fi

  # possibly bail after 0th
  if [ "$TESTBADONCE" != "" ]; then
    echo "bailing after 0th iteration because TESTBADONCE is set"
    exit 0
  fi

  if [ "$RUNONLY" != "" ]; then
    echo "bailing after ${RUNONLY}th iteration because RUNONLY is set"
    exit 0
  fi

  i=`expr $i + 1`
done

echo "all $numcases cases in $srcfile failed as expected"

