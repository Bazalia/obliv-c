#!/usr/bin/perl -w
# -*-perl-*-
use strict;

# Identifier minimizer, idmin, by Daniel Wilkerson.

# Minimize identifiers by reducing them to prefixes while maintaining
# uniqueness.  Has optional support for smooshing out the underscores
# in identifiers.  Has optional support for ignoring reserved words.

# Feature: Might need to add support for ignoring whole regular
# expressions, not just words.

# Globals ****************
my $quote_regex = qr/".*?(?<!\\)"/; # Definition of a quoted string.
my $id_regex = qr/[a-zA-Z_][a-zA-Z_0-9]*/; # Definition of an identifier.

my $input;                      # The initial input.
my @lumps;                      # Input separated into identifiers and stuff in-between.
my %identifiers = ();            # Hash where the keys are the identifiers.
my %abbrev = ();                # Maps identifiers to their abbreviations.
my %taken = ();                 # Tells if an abbreviation is taken.

my $verbose = 0;                # Be verbose.
my $smoosh_underscores;         # Remove underscores where possible from identifiers.
my @ignore_files = ();          # Files containing identifiers to ignore.
my %ignore_idents = ();         # Identifiers to ignore.
my $title_message = "Identifier minimizer, by Daniel Wilkerson.";

my $help_message = <<END
$title_message
    -smoosh Smoosh underscores as much as possible.
    -ignore=<file> (multiple) Load identifiers to ignore.
    -verbose Be verbose about what is going on.
    -help Print this message.
END
    ;

# Functions ****************
sub read_input {
    undef local $/;
    $input = <>;
}

sub lump_into_identifiers {
    warn "\nPrinting identifiers [] and inter-identifier text. ****************\n" if $verbose;
    foreach my $quotelump (split /($quote_regex)/o, $input) { # Split at quoted strings.
        if ($quotelump=~/^$quote_regex$/o) {
            push @lumps, $quotelump;
            print STDERR $quotelump if $verbose;
            next;
        }
        # If not a quoted string, split at identifiers.
        foreach my $idlump (split /($id_regex)/o, $quotelump) {
            if ($idlump=~/^$id_regex$/o) {
                push @lumps, $idlump;
                $identifiers{$idlump}++;
                if ($verbose) {print STDERR "[", $idlump, "]";}
            } else {
                push @lumps, $idlump;
                print STDERR $idlump if $verbose;
            }
        }
    }
}

sub smoosh_underscores {
    my ($ident) = @_;
    my $original_ident = $ident;
    1 while($ident=~s/__/_/g);  # No multiple ones.
    $ident=~s/^_//;             # No leading one.
    $ident=~s/_$//;             # No trailing one.
    $ident = "_" if $ident=~/^$/; # Make sure don't end up with the empty string.
    warn "smoosh: $ident\n" if $verbose && $original_ident ne $ident;
    return $ident;
}

sub compute_identifier_abbreviations {
    warn "\nComputing identifer abbreviations. ****************\n" if $verbose;
    # Set abbreviations of ignore identifiers to be themselves, and do
    # it first, giving them priority.
    foreach my $ident (keys %ignore_idents) {
        $abbrev{$ident} = $ident;
        $taken{$ident}++;
    }
    # Make sure non-underscore ids come first.
    my @underscore_ids = ();
    my @non_underscore_ids = ();
    foreach (keys %identifiers) {
        if (/^_/) {push @underscore_ids, $_}
        else {push @non_underscore_ids, $_}
    }
    # Compute minimal prefix that preserves uniqueness.
    foreach my $ident (sort(@non_underscore_ids), sort(@underscore_ids)) {
        die "Can't happen:$ident" if $abbrev{$ident} && !$ignore_idents{$ident};
        print STDERR "**** $ident" if $verbose;
        if ($ignore_idents{$ident}) {
            print STDERR " ignore\n" if $verbose;
            next;
        } else {print STDERR "\n" if $verbose}
        my $ident2 = $ident;
        $ident2 = smoosh_underscores($ident2) if $smoosh_underscores;
        my @chars = split //, $ident2;
        for (my $i=0; $i<@chars; ++$i) {
            my $newident = join "", @chars[0..$i];
            warn $newident, "\n" if $verbose;
            if (!$taken{$newident}++) {
                $abbrev{$ident} = $newident;
                goto found_one;
            }
        }
        # Fell through.
        # Theorem: This is not possible.  Proof: This can only happen if a
        # previous identifier was abbreviated of which this one is a
        # prefix.  But by the definition of sort, this can't happen.
        die "Can't happen:$ident" unless $smoosh_underscores;
        # Just make a unique one.
        for (my $j=0; ; ++$j) {
            my $newident = "${ident2}$j";
            if (!$taken{$newident}++) {
                $abbrev{$ident} = $newident;
                last;
            }
        }
      found_one:
        die "Can't happen:$ident" unless $abbrev{$ident}; # Make sure we picked something.
    }
    # Check preserves uniqueness.
    check_abbrev_one_to_one();
}

sub check_abbrev_one_to_one {
    # FIX: There must be a better way to get the length of a list.
    my $numkeys = 0;
    ++$numkeys foreach (keys %abbrev);
    my $numvalues = 0;
    ++$numvalues foreach (values %abbrev);
    die "Can't happen: abbrev not one to one" unless $numkeys == $numvalues;
}

sub render_using_abbreviations {
    foreach my $lump (@lumps) {
        if ($abbrev{$lump}) {
            print $abbrev{$lump};
        } else {
            print $lump;
        }
    }
}

sub load_ignore_files() {
    return unless @ignore_files;
    foreach my $file (@ignore_files) {
        die "Not a proper file:$file" unless -f $file;
        open F, $file or die "Can't find ignore file $file:$!";
        my $line;
        while(defined ($line = <F>)) {
            $line=~s/\#.*$//;   # Delete everything after a #.
            $line=~s/^\s*//;    # Delete leading whitespace.
            $line=~s/\s*$//;    # Delete trailing whitespace.
            next if $line=~/^\s*$/; # Skip if blank.
#            warn "Ignoring:$line:\n" if $verbose;
            $ignore_idents{$line}++;
        }
        close F or die "Can't close ignore file $file:$!";
    }
    warn "\nIgnoring the following identifiers. ****************\n",
    join ("\n", sort keys %ignore_idents), "\n" if $verbose;
}

sub parse_command_line {
    my $str;
    my @non_flags = ();
    while(defined ($str = shift @ARGV)) {
        if ($str=~/^-([^=]+)(=(.+))?/) {
            my ($flag, $argument) = ($1, $3);
            if ($flag eq "help") {
                print $help_message;
                exit 0;
            } elsif ($flag eq "verbose") {
                $verbose++;
            } elsif ($flag eq "smoosh") {
                $smoosh_underscores++;
            } elsif ($flag eq "ignore") {
                push @ignore_files, $argument;
            } else {die "Illegal flag: $flag \n"}
        } else {push @non_flags, $str;}
    }
    push @ARGV, @non_flags;
}

# Main ****************

parse_command_line();
warn "\n\t$title_message\n" if $verbose;
load_ignore_files();
read_input();
lump_into_identifiers();
compute_identifier_abbreviations();
render_using_abbreviations();
